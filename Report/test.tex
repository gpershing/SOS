\documentclass[main.tex]{subfiles}

\begin{document}
	\section{Test Plan}
	
	The end-to-end integration tests can be found in the test/ directory. An an end-to-end integration test suite, it was used to rigorously test the functionality of SOS, including lower level lexical, syntactic, and semantic checks. %The test suite ensured that new features did not break previously working features.
	
	A complete set of tests can be found in Appendix NNNN Integration Tests Files (Negative tests) and Appendix NNNNN Integration Tests Files (Positive tests).
	
	Tojo, Sheron, and Sitong created the tests/test-* and tests/fail-* test cases to test specific features of SOS. G, Sitong, and Tojo created sample programs as end-to-end tests.
	
	\subsection{Test Automation}
	
	While in the docker environment, running ./testall in the SOS directory will run all of the tests and say whether each test passed with “OK” or failed with “FAILED”. Each test case that should successfully pass and produce output follow the naming pattern of using test-*.sos for the test program and a corresponding (in file name represented by *) test-*.out for the expected output of the program. Similarly, each negative test case used fail-*.sos for the test program that should fail and fail-*.err (instead of .out) for the expected error message.

	For our integration tests, we modified the testall.sh script provided by Professor Edwards for the MicroC compiler. The script works by compiling and executing all of the test-*.sos and fail-*.sos programs. For each test case (test and fail), the script compares the produced outputs (.out) or errors (.err) with their corresponding references made by us, to see if what was produced  matches their expected values. If the produced output or error files fail to match what is expected, the script will print out 'FAILED' next to the test name along with an error message. A more detailed error message can be found by looking in testall.log. One can refer to either the produced .out/.err file and compare it to the reference, or the .diff file, which summarizes the differences between the two files. If the test is successful, the script prints an ‘OK’, and the compiled .out/.err files are removed from the directory for cleanliness.
	
	For larger end-to-end tests, (i.e. sample programs), we created a separate directory called "sample\_programs" to hold these programs. These tests can be run using the compile\_exec.sh script, which takes the file path to the program to run as an argument.
	
	Example: ./compile\_exec.sh sample\_programs/dragon.sos
	
	testall.sh and compile\_exec.sh can be found in Appendix NNNN testall.sh and Appendix NNNN compile\_exec.sh, respectively. 
	
	\newpage
	\subsection{Example Test Programs}
	
	\subsection{Example Test Programs}
	\subsubsection{Square}
	\colorbox{blue!30}{test-helloworld.sos}
	\begin{lstlisting}
import renderer.sos

p1: point = {-0.5, -0.5}
p2: point = {-0.5, 0.5}
p3: point = {0.5, 0.5}
p4: point = {0.5, -0.5}
point_arr : path = [p1, p2, p3, p4] 

c1 : color = {255.0, 0.0, 0.0, 0.8}
c2 : color = {0.0, 255.0, 0.0, 0.8}
c3 : color = {0.0, 0.0, 255.0, 0.8}
c4 : color = {100.0, 100.0, 0.0, 0.8}
color_arr : colors = [c1, c2, c3, c4] 

//create first canvas, draw square, and save and end canvas
canvas1 : canvas = {400, 400, 0}

startCanvas(canvas1)
drawShape(point_arr, color_arr, 0, 1)
endCanvas(canvas1)

//create a second canvas, draw same shape, and close this canvas
//there should now be two images of the same drawing saved in root directory
canvas2 : canvas = {400, 400, 1}

startCanvas(canvas2)
drawShape(point_arr, color_arr, 0, 1)
endCanvas(canvas2)
\end{lstlisting}

{\tiny
\colorbox{green!30}{test-helloworld.ll}
\begin{lstlisting}
; ModuleID = 'SOS'
source_filename = "SOS"

declare i32 @printf(i8*, ...)

define i32 @main() {
entry:
  %p1 = alloca { float, float }*
  %malloccall = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2) to i32))
  %anon = bitcast i8* %malloccall to { float, float }*
  %fieldaddr = getelementptr { float, float }, { float, float }* %anon, i32 0, i32 0
  store float -5.000000e-01, float* %fieldaddr
  %fieldaddr1 = getelementptr { float, float }, { float, float }* %anon, i32 0, i32 1
  store float -5.000000e-01, float* %fieldaddr1
  store { float, float }* %anon, { float, float }** %p1
  %p2 = alloca { float, float }*
  %malloccall2 = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2) to i32))
  %anon3 = bitcast i8* %malloccall2 to { float, float }*
  %fieldaddr4 = getelementptr { float, float }, { float, float }* %anon3, i32 0, i32 0
  store float -5.000000e-01, float* %fieldaddr4
  %fieldaddr5 = getelementptr { float, float }, { float, float }* %anon3, i32 0, i32 1
  store float 5.000000e-01, float* %fieldaddr5
  store { float, float }* %anon3, { float, float }** %p2
  %p3 = alloca { float, float }*
  %malloccall6 = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2) to i32))
  %anon7 = bitcast i8* %malloccall6 to { float, float }*
  %fieldaddr8 = getelementptr { float, float }, { float, float }* %anon7, i32 0, i32 0
  store float 5.000000e-01, float* %fieldaddr8
  %fieldaddr9 = getelementptr { float, float }, { float, float }* %anon7, i32 0, i32 1
  store float 5.000000e-01, float* %fieldaddr9
  store { float, float }* %anon7, { float, float }** %p3
  %p4 = alloca { float, float }*
  %malloccall10 = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2) to i32))
  %anon11 = bitcast i8* %malloccall10 to { float, float }*
  %fieldaddr12 = getelementptr { float, float }, { float, float }* %anon11, i32 0, i32 0
  store float 5.000000e-01, float* %fieldaddr12
  %fieldaddr13 = getelementptr { float, float }, { float, float }* %anon11, i32 0, i32 1
  store float -5.000000e-01, float* %fieldaddr13
  store { float, float }* %anon11, { float, float }** %p4
  %point_arr = alloca { { float, float }**, i32 }*
  %malloccall14 = tail call i8* @malloc(i32 mul (i32 ptrtoint (i1** getelementptr (i1*, i1** null, i32 1) to i32), i32 4))
  %arrdata = bitcast i8* %malloccall14 to { float, float }**
  %p115 = load { float, float }*, { float, float }** %p1
  %storeref = getelementptr { float, float }*, { float, float }** %arrdata, i32 0
  store { float, float }* %p115, { float, float }** %storeref
  %p216 = load { float, float }*, { float, float }** %p2
  %storeref17 = getelementptr { float, float }*, { float, float }** %arrdata, i32 1
  store { float, float }* %p216, { float, float }** %storeref17
  %p318 = load { float, float }*, { float, float }** %p3
  %storeref19 = getelementptr { float, float }*, { float, float }** %arrdata, i32 2
  store { float, float }* %p318, { float, float }** %storeref19
  %p420 = load { float, float }*, { float, float }** %p4
  %storeref21 = getelementptr { float, float }*, { float, float }** %arrdata, i32 3
  store { float, float }* %p420, { float, float }** %storeref21
  %malloccall22 = tail call i8* @malloc(i32 ptrtoint ({ { float, float }**, i32 }* getelementptr ({ { float, float }**, i32 }, { { float, float }**, i32 }* null, i32 1) to i32))
  %arr = bitcast i8* %malloccall22 to { { float, float }**, i32 }*
  %arrdata23 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 0
  %arrlen = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 1
  store { float, float }** %arrdata, { float, float }*** %arrdata23
  store i32 4, i32* %arrlen
  store { { float, float }**, i32 }* %arr, { { float, float }**, i32 }** %point_arr
  %c1 = alloca { float, float, float, float }*
  %malloccall24 = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 4) to i32))
  %anon25 = bitcast i8* %malloccall24 to { float, float, float, float }*
  %fieldaddr26 = getelementptr { float, float, float, float }, { float, float, float, float }* %anon25, i32 0, i32 0
  store float 2.550000e+02, float* %fieldaddr26
  %fieldaddr27 = getelementptr { float, float, float, float }, { float, float, float, float }* %anon25, i32 0, i32 1
  store float 0.000000e+00, float* %fieldaddr27
  %fieldaddr28 = getelementptr { float, float, float, float }, { float, float, float, float }* %anon25, i32 0, i32 2
  store float 0.000000e+00, float* %fieldaddr28
  %fieldaddr29 = getelementptr { float, float, float, float }, { float, float, float, float }* %anon25, i32 0, i32 3
  store float 0x3FE99999A0000000, float* %fieldaddr29
  store { float, float, float, float }* %anon25, { float, float, float, float }** %c1
  %c2 = alloca { float, float, float, float }*
  %malloccall30 = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 4) to i32))
  %anon31 = bitcast i8* %malloccall30 to { float, float, float, float }*
  %fieldaddr32 = getelementptr { float, float, float, float }, { float, float, float, float }* %anon31, i32 0, i32 0
  store float 0.000000e+00, float* %fieldaddr32
  %fieldaddr33 = getelementptr { float, float, float, float }, { float, float, float, float }* %anon31, i32 0, i32 1
  store float 2.550000e+02, float* %fieldaddr33
  %fieldaddr34 = getelementptr { float, float, float, float }, { float, float, float, float }* %anon31, i32 0, i32 2
  store float 0.000000e+00, float* %fieldaddr34
  %fieldaddr35 = getelementptr { float, float, float, float }, { float, float, float, float }* %anon31, i32 0, i32 3
  store float 0x3FE99999A0000000, float* %fieldaddr35
  store { float, float, float, float }* %anon31, { float, float, float, float }** %c2
  %c3 = alloca { float, float, float, float }*
  %malloccall36 = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 4) to i32))
  %anon37 = bitcast i8* %malloccall36 to { float, float, float, float }*
  %fieldaddr38 = getelementptr { float, float, float, float }, { float, float, float, float }* %anon37, i32 0, i32 0
  store float 0.000000e+00, float* %fieldaddr38
  %fieldaddr39 = getelementptr { float, float, float, float }, { float, float, float, float }* %anon37, i32 0, i32 1
  store float 0.000000e+00, float* %fieldaddr39
  %fieldaddr40 = getelementptr { float, float, float, float }, { float, float, float, float }* %anon37, i32 0, i32 2
  store float 2.550000e+02, float* %fieldaddr40
  %fieldaddr41 = getelementptr { float, float, float, float }, { float, float, float, float }* %anon37, i32 0, i32 3
  store float 0x3FE99999A0000000, float* %fieldaddr41
  store { float, float, float, float }* %anon37, { float, float, float, float }** %c3
  %c4 = alloca { float, float, float, float }*
  %malloccall42 = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 4) to i32))
  %anon43 = bitcast i8* %malloccall42 to { float, float, float, float }*
  %fieldaddr44 = getelementptr { float, float, float, float }, { float, float, float, float }* %anon43, i32 0, i32 0
  store float 1.000000e+02, float* %fieldaddr44
  %fieldaddr45 = getelementptr { float, float, float, float }, { float, float, float, float }* %anon43, i32 0, i32 1
  store float 1.000000e+02, float* %fieldaddr45
  %fieldaddr46 = getelementptr { float, float, float, float }, { float, float, float, float }* %anon43, i32 0, i32 2
  store float 0.000000e+00, float* %fieldaddr46
  %fieldaddr47 = getelementptr { float, float, float, float }, { float, float, float, float }* %anon43, i32 0, i32 3
  store float 0x3FE99999A0000000, float* %fieldaddr47
  store { float, float, float, float }* %anon43, { float, float, float, float }** %c4
  %color_arr = alloca { { float, float, float, float }**, i32 }*
  %malloccall48 = tail call i8* @malloc(i32 mul (i32 ptrtoint (i1** getelementptr (i1*, i1** null, i32 1) to i32), i32 4))
  %arrdata49 = bitcast i8* %malloccall48 to { float, float, float, float }**
  %c150 = load { float, float, float, float }*, { float, float, float, float }** %c1
  %storeref51 = getelementptr { float, float, float, float }*, { float, float, float, float }** %arrdata49, i32 0
  store { float, float, float, float }* %c150, { float, float, float, float }** %storeref51
  %c252 = load { float, float, float, float }*, { float, float, float, float }** %c2
  %storeref53 = getelementptr { float, float, float, float }*, { float, float, float, float }** %arrdata49, i32 1
  store { float, float, float, float }* %c252, { float, float, float, float }** %storeref53
  %c354 = load { float, float, float, float }*, { float, float, float, float }** %c3
  %storeref55 = getelementptr { float, float, float, float }*, { float, float, float, float }** %arrdata49, i32 2
  store { float, float, float, float }* %c354, { float, float, float, float }** %storeref55
  %c456 = load { float, float, float, float }*, { float, float, float, float }** %c4
  %storeref57 = getelementptr { float, float, float, float }*, { float, float, float, float }** %arrdata49, i32 3
  store { float, float, float, float }* %c456, { float, float, float, float }** %storeref57
  %malloccall58 = tail call i8* @malloc(i32 ptrtoint ({ { float, float, float, float }**, i32 }* getelementptr ({ { float, float, float, float }**, i32 }, { { float, float, float, float }**, i32 }* null, i32 1) to i32))
  %arr59 = bitcast i8* %malloccall58 to { { float, float, float, float }**, i32 }*
  %arrdata60 = getelementptr { { float, float, float, float }**, i32 }, { { float, float, float, float }**, i32 }* %arr59, i32 0, i32 0
  %arrlen61 = getelementptr { { float, float, float, float }**, i32 }, { { float, float, float, float }**, i32 }* %arr59, i32 0, i32 1
  store { float, float, float, float }** %arrdata49, { float, float, float, float }*** %arrdata60
  store i32 4, i32* %arrlen61
  store { { float, float, float, float }**, i32 }* %arr59, { { float, float, float, float }**, i32 }** %color_arr
  %canvas1 = alloca { i32, i32, i32 }*
  %malloccall62 = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i64), i64 3) to i32))
  %anon63 = bitcast i8* %malloccall62 to { i32, i32, i32 }*
  %fieldaddr64 = getelementptr { i32, i32, i32 }, { i32, i32, i32 }* %anon63, i32 0, i32 0
  store i32 400, i32* %fieldaddr64
  %fieldaddr65 = getelementptr { i32, i32, i32 }, { i32, i32, i32 }* %anon63, i32 0, i32 1
  store i32 400, i32* %fieldaddr65
  %fieldaddr66 = getelementptr { i32, i32, i32 }, { i32, i32, i32 }* %anon63, i32 0, i32 2
  store i32 0, i32* %fieldaddr66
  store { i32, i32, i32 }* %anon63, { i32, i32, i32 }** %canvas1
  %canvas167 = load { i32, i32, i32 }*, { i32, i32, i32 }** %canvas1
  call void @startCanvas({ i32, i32, i32 }* %canvas167)
  %point_arr68 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %point_arr
  %color_arr69 = load { { float, float, float, float }**, i32 }*, { { float, float, float, float }**, i32 }** %color_arr
  call void @drawShape({ { float, float }**, i32 }* %point_arr68, { { float, float, float, float }**, i32 }* %color_arr69, i32 0, i32 1)
  %canvas170 = load { i32, i32, i32 }*, { i32, i32, i32 }** %canvas1
  call void @endCanvas({ i32, i32, i32 }* %canvas170)
  %canvas2 = alloca { i32, i32, i32 }*
  %malloccall71 = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i64), i64 3) to i32))
  %anon72 = bitcast i8* %malloccall71 to { i32, i32, i32 }*
  %fieldaddr73 = getelementptr { i32, i32, i32 }, { i32, i32, i32 }* %anon72, i32 0, i32 0
  store i32 400, i32* %fieldaddr73
  %fieldaddr74 = getelementptr { i32, i32, i32 }, { i32, i32, i32 }* %anon72, i32 0, i32 1
  store i32 400, i32* %fieldaddr74
  %fieldaddr75 = getelementptr { i32, i32, i32 }, { i32, i32, i32 }* %anon72, i32 0, i32 2
  store i32 1, i32* %fieldaddr75
  store { i32, i32, i32 }* %anon72, { i32, i32, i32 }** %canvas2
  %canvas276 = load { i32, i32, i32 }*, { i32, i32, i32 }** %canvas2
  call void @startCanvas({ i32, i32, i32 }* %canvas276)
  %point_arr77 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %point_arr
  %color_arr78 = load { { float, float, float, float }**, i32 }*, { { float, float, float, float }**, i32 }** %color_arr
  call void @drawShape({ { float, float }**, i32 }* %point_arr77, { { float, float, float, float }**, i32 }* %color_arr78, i32 0, i32 1)
  %canvas279 = load { i32, i32, i32 }*, { i32, i32, i32 }** %canvas2
  call void @endCanvas({ i32, i32, i32 }* %canvas279)
  ret i32 0
}

declare float @sqrtf(float)

declare float @sinf(float)

declare float @cosf(float)

declare float @tanf(float)

declare float @asinf(float)

declare float @acosf(float)

declare float @atanf(float)

declare float @toradiansf(float)

declare void @gl_startRendering(i32, i32)

declare void @gl_endRendering(i32, i32, i32)

declare void @gl_drawCurve({ float*, i32 }*, { float*, i32 }*, i32)

declare void @gl_drawShape({ float*, i32 }*, { float*, i32 }*, i32, i32)

declare void @gl_drawPoint({ float*, i32 }*, { float*, i32 }*, i32)

define float @floor(float %x) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %z = alloca float
  %y = alloca i32
  %x2 = load float, float* %x1
  %cast = fptosi float %x2 to i32
  store i32 %cast, i32* %y
  %cast3 = sitofp i32 %cast to float
  store float %cast3, float* %z
  %z4 = load float, float* %z
  %x5 = load float, float* %x1
  %tmp = fcmp ole float %z4, %x5
  %if_tmp = alloca float
  br i1 %tmp, label %then, label %else

merge:                                            ; preds = %else, %then
  %if_tmp9 = load float, float* %if_tmp
  ret float %if_tmp9

then:                                             ; preds = %entry
  %z6 = load float, float* %z
  store float %z6, float* %if_tmp
  br label %merge

else:                                             ; preds = %entry
  %z7 = load float, float* %z
  %tmp8 = fsub float %z7, 1.000000e+00
  store float %tmp8, float* %if_tmp
  br label %merge
}

define float @ceil(float %x) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %x2 = load float, float* %x1
  %tmp = fneg float %x2
  %fxn_result = call float @floor(float %tmp)
  %tmp3 = fneg float %fxn_result
  ret float %tmp3
}

define float @frac(float %x) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %x2 = load float, float* %x1
  %x3 = load float, float* %x1
  %fxn_result = call float @floor(float %x3)
  %tmp = fsub float %x2, %fxn_result
  ret float %tmp
}

define float @max(float %a, float %b) {
entry:
  %a1 = alloca float
  store float %a, float* %a1
  %b2 = alloca float
  store float %b, float* %b2
  %a3 = load float, float* %a1
  %b4 = load float, float* %b2
  %tmp = fcmp olt float %a3, %b4
  %if_tmp = alloca float
  br i1 %tmp, label %then, label %else

merge:                                            ; preds = %else, %then
  %if_tmp7 = load float, float* %if_tmp
  ret float %if_tmp7

then:                                             ; preds = %entry
  %b5 = load float, float* %b2
  store float %b5, float* %if_tmp
  br label %merge

else:                                             ; preds = %entry
  %a6 = load float, float* %a1
  store float %a6, float* %if_tmp
  br label %merge
}

define float @min(float %a, float %b) {
entry:
  %a1 = alloca float
  store float %a, float* %a1
  %b2 = alloca float
  store float %b, float* %b2
  %a3 = load float, float* %a1
  %b4 = load float, float* %b2
  %tmp = fcmp olt float %a3, %b4
  %if_tmp = alloca float
  br i1 %tmp, label %then, label %else

merge:                                            ; preds = %else, %then
  %if_tmp7 = load float, float* %if_tmp
  ret float %if_tmp7

then:                                             ; preds = %entry
  %a5 = load float, float* %a1
  store float %a5, float* %if_tmp
  br label %merge

else:                                             ; preds = %entry
  %b6 = load float, float* %b2
  store float %b6, float* %if_tmp
  br label %merge
}

define float @clamp(float %x, float %m, float %M) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %m2 = alloca float
  store float %m, float* %m2
  %M3 = alloca float
  store float %M, float* %M3
  %M4 = load float, float* %M3
  %x5 = load float, float* %x1
  %m6 = load float, float* %m2
  %fxn_result = call float @max(float %x5, float %m6)
  %fxn_result7 = call float @min(float %M4, float %fxn_result)
  ret float %fxn_result7
}

define float @abs(float %x) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %x2 = load float, float* %x1
  %tmp = fcmp olt float %x2, 0.000000e+00
  %if_tmp = alloca float
  br i1 %tmp, label %then, label %else

merge:                                            ; preds = %else, %then
  %if_tmp6 = load float, float* %if_tmp
  ret float %if_tmp6

then:                                             ; preds = %entry
  %x3 = load float, float* %x1
  %tmp4 = fneg float %x3
  store float %tmp4, float* %if_tmp
  br label %merge

else:                                             ; preds = %entry
  %x5 = load float, float* %x1
  store float %x5, float* %if_tmp
  br label %merge
}

define float @modf(float %x, float %m) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %m2 = alloca float
  store float %m, float* %m2
  %m3 = load float, float* %m2
  %x4 = load float, float* %x1
  %m5 = load float, float* %m2
  %tmp = fdiv float %x4, %m5
  %fxn_result = call float @frac(float %tmp)
  %tmp6 = fmul float %m3, %fxn_result
  ret float %tmp6
}

define float @sin(float %x) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %x2 = load float, float* %x1
  %fxn_result = call float @sinf(float %x2)
  ret float %fxn_result
}

define float @cos(float %x) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %x2 = load float, float* %x1
  %fxn_result = call float @cosf(float %x2)
  ret float %fxn_result
}

define float @tan(float %x) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %x2 = load float, float* %x1
  %fxn_result = call float @tanf(float %x2)
  ret float %fxn_result
}

define float @asin(float %x) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %x2 = load float, float* %x1
  %fxn_result = call float @asinf(float %x2)
  ret float %fxn_result
}

define float @acos(float %x) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %x2 = load float, float* %x1
  %fxn_result = call float @acosf(float %x2)
  ret float %fxn_result
}

define float @atan(float %x) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %x2 = load float, float* %x1
  %fxn_result = call float @atanf(float %x2)
  ret float %fxn_result
}

define float @sqrt(float %x) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %x2 = load float, float* %x1
  %fxn_result = call float @sqrtf(float %x2)
  ret float %fxn_result
}

define float @toradians(float %x) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %x2 = load float, float* %x1
  %fxn_result = call float @toradiansf(float %x2)
  ret float %fxn_result
}

define float @sqrMagnitude({ float, float }* %p) {
entry:
  %p1 = alloca { float, float }*
  store { float, float }* %p, { float, float }** %p1
  %p2 = load { float, float }*, { float, float }** %p1
  %p3 = load { float, float }*, { float, float }** %p1
  %result = call float @__dotf2({ float, float }* %p2, { float, float }* %p3)
  ret float %result
}

define float @__dotf2({ float, float }* %a, { float, float }* %b) {
entry:
  %a1 = alloca { float, float }*
  store { float, float }* %a, { float, float }** %a1
  %a2 = load { float, float }*, { float, float }** %a1
  %b3 = alloca { float, float }*
  store { float, float }* %b, { float, float }** %b3
  %b4 = load { float, float }*, { float, float }** %b3
  %dot = alloca float
  %tmp = alloca float
  store float 0.000000e+00, float* %dot
  %avalref = getelementptr { float, float }, { float, float }* %a2, i32 0, i32 0
  %aval = load float, float* %avalref
  %bvalref = getelementptr { float, float }, { float, float }* %b4, i32 0, i32 0
  %bval = load float, float* %bvalref
  %tmp5 = fmul float %aval, %bval
  store float %tmp5, float* %tmp
  %tmp6 = load float, float* %tmp
  %res = load float, float* %dot
  %tmp7 = fadd float %tmp6, %res
  store float %tmp7, float* %dot
  %avalref8 = getelementptr { float, float }, { float, float }* %a2, i32 0, i32 1
  %aval9 = load float, float* %avalref8
  %bvalref10 = getelementptr { float, float }, { float, float }* %b4, i32 0, i32 1
  %bval11 = load float, float* %bvalref10
  %tmp12 = fmul float %aval9, %bval11
  store float %tmp12, float* %tmp
  %tmp13 = load float, float* %tmp
  %res14 = load float, float* %dot
  %tmp15 = fadd float %tmp13, %res14
  store float %tmp15, float* %dot
  %res16 = load float, float* %dot
  ret float %res16
}

define float @magnitude({ float, float }* %p) {
entry:
  %p1 = alloca { float, float }*
  store { float, float }* %p, { float, float }** %p1
  %p2 = load { float, float }*, { float, float }** %p1
  %fxn_result = call float @sqrMagnitude({ float, float }* %p2)
  %fxn_result3 = call float @sqrt(float %fxn_result)
  ret float %fxn_result3
}

define float @sqrDistance({ float, float }* %a, { float, float }* %b) {
entry:
  %a1 = alloca { float, float }*
  store { float, float }* %a, { float, float }** %a1
  %b2 = alloca { float, float }*
  store { float, float }* %b, { float, float }** %b2
  %p = alloca { float, float }*
  %a3 = load { float, float }*, { float, float }** %a1
  %b4 = load { float, float }*, { float, float }** %b2
  %result = call { float, float }* @__subf2({ float, float }* %a3, { float, float }* %b4)
  store { float, float }* %result, { float, float }** %p
  %d = alloca float
  %p5 = load { float, float }*, { float, float }** %p
  %fxn_result = call float @sqrMagnitude({ float, float }* %p5)
  store float %fxn_result, float* %d
  %p6 = load { float, float }*, { float, float }** %p
  %0 = bitcast { float, float }* %p6 to i8*
  tail call void @free(i8* %0)
  %d7 = load float, float* %d
  ret float %d7
}

define { float, float }* @__subf2({ float, float }* %a, { float, float }* %b) {
entry:
  %a1 = alloca { float, float }*
  store { float, float }* %a, { float, float }** %a1
  %a2 = load { float, float }*, { float, float }** %a1
  %b3 = alloca { float, float }*
  store { float, float }* %b, { float, float }** %b3
  %b4 = load { float, float }*, { float, float }** %b3
  %malloccall = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2) to i32))
  %ret = bitcast i8* %malloccall to { float, float }*
  %avalref = getelementptr { float, float }, { float, float }* %a2, i32 0, i32 0
  %aval = load float, float* %avalref
  %bvalref = getelementptr { float, float }, { float, float }* %b4, i32 0, i32 0
  %bval = load float, float* %bvalref
  %tmp = fsub float %aval, %bval
  %ref = getelementptr { float, float }, { float, float }* %ret, i32 0, i32 0
  store float %tmp, float* %ref
  %avalref5 = getelementptr { float, float }, { float, float }* %a2, i32 0, i32 1
  %aval6 = load float, float* %avalref5
  %bvalref7 = getelementptr { float, float }, { float, float }* %b4, i32 0, i32 1
  %bval8 = load float, float* %bvalref7
  %tmp9 = fsub float %aval6, %bval8
  %ref10 = getelementptr { float, float }, { float, float }* %ret, i32 0, i32 1
  store float %tmp9, float* %ref10
  ret { float, float }* %ret
}

declare noalias i8* @malloc(i32)

declare void @free(i8*)

define float @distance({ float, float }* %a, { float, float }* %b) {
entry:
  %a1 = alloca { float, float }*
  store { float, float }* %a, { float, float }** %a1
  %b2 = alloca { float, float }*
  store { float, float }* %b, { float, float }** %b2
  %a3 = load { float, float }*, { float, float }** %a1
  %b4 = load { float, float }*, { float, float }** %b2
  %fxn_result = call float @sqrDistance({ float, float }* %a3, { float, float }* %b4)
  %fxn_result5 = call float @sqrt(float %fxn_result)
  ret float %fxn_result5
}

define { float, float }* @copy_point({ float, float }* %p) {
entry:
  %p1 = alloca { float, float }*
  store { float, float }* %p, { float, float }** %p1
  %p2 = load { float, float }*, { float, float }** %p1
  %copied = call { float, float }* @__copy2({ float, float }* %p2)
  ret { float, float }* %copied
}

define { float, float }* @__copy2({ float, float }* %to_copy) {
entry:
  %to_copy1 = alloca { float, float }*
  store { float, float }* %to_copy, { float, float }** %to_copy1
  %to_copy2 = load { float, float }*, { float, float }** %to_copy1
  %malloccall = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2) to i32))
  %struct = bitcast i8* %malloccall to { float, float }*
  %flref = getelementptr { float, float }, { float, float }* %to_copy2, i32 0, i32 0
  %fl = load float, float* %flref
  %ref = getelementptr { float, float }, { float, float }* %struct, i32 0, i32 0
  store float %fl, float* %ref
  %flref3 = getelementptr { float, float }, { float, float }* %to_copy2, i32 0, i32 1
  %fl4 = load float, float* %flref3
  %ref5 = getelementptr { float, float }, { float, float }* %struct, i32 0, i32 1
  store float %fl4, float* %ref5
  ret { float, float }* %struct
}

define void @free_point({ float, float }* %p) {
entry:
  %p1 = alloca { float, float }*
  store { float, float }* %p, { float, float }** %p1
  %p2 = load { float, float }*, { float, float }** %p1
  %0 = bitcast { float, float }* %p2 to i8*
  tail call void @free(i8* %0)
  ret void
}

define { { float, float }**, i32 }* @copy_path({ { float, float }**, i32 }* %p) {
entry:
  %p1 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %p, { { float, float }**, i32 }** %p1
  %p2 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  %lenref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p2, i32 0, i32 1
  %len = load i32, i32* %lenref
  %dataref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p2, i32 0, i32 0
  %data = load { float, float }**, { float, float }*** %dataref
  %mallocsize = mul i32 %len, ptrtoint (i1** getelementptr (i1*, i1** null, i32 1) to i32)
  %malloccall = tail call i8* @malloc(i32 %mallocsize)
  %arrdata = bitcast i8* %malloccall to { float, float }**
  %i = alloca i32
  store i32 0, i32* %i
  br label %loop

loop:                                             ; preds = %loop, %entry
  %i3 = load i32, i32* %i
  %elref = getelementptr { float, float }*, { float, float }** %data, i32 %i3
  %el = load { float, float }*, { float, float }** %elref
  %fxn_result = call { float, float }* @copy_point({ float, float }* %el)
  %storeref = getelementptr { float, float }*, { float, float }** %arrdata, i32 %i3
  store { float, float }* %fxn_result, { float, float }** %storeref
  %i4 = add i32 %i3, 1
  store i32 %i4, i32* %i
  %i5 = load i32, i32* %i
  %tmp = icmp slt i32 %i5, %len
  br i1 %tmp, label %loop, label %continue

continue:                                         ; preds = %loop
  %malloccall6 = tail call i8* @malloc(i32 ptrtoint ({ { float, float }**, i32 }* getelementptr ({ { float, float }**, i32 }, { { float, float }**, i32 }* null, i32 1) to i32))
  %arr = bitcast i8* %malloccall6 to { { float, float }**, i32 }*
  %arrdata7 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 0
  %arrlen = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 1
  store { float, float }** %arrdata, { float, float }*** %arrdata7
  store i32 %len, i32* %arrlen
  ret { { float, float }**, i32 }* %arr
}

define void @free_path({ { float, float }**, i32 }* %p) {
entry:
  %p1 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %p, { { float, float }**, i32 }** %p1
  %p2 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  %lenref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p2, i32 0, i32 1
  %len = load i32, i32* %lenref
  %dataref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p2, i32 0, i32 0
  %data = load { float, float }**, { float, float }*** %dataref
  %i = alloca i32
  store i32 0, i32* %i
  br label %loop

loop:                                             ; preds = %loop, %entry
  %i3 = load i32, i32* %i
  %elref = getelementptr { float, float }*, { float, float }** %data, i32 %i3
  %el = load { float, float }*, { float, float }** %elref
  call void @free_point({ float, float }* %el)
  %i4 = add i32 %i3, 1
  store i32 %i4, i32* %i
  %i5 = load i32, i32* %i
  %tmp = icmp slt i32 %i5, %len
  br i1 %tmp, label %loop, label %continue

continue:                                         ; preds = %loop
  ret void
}

define void @appendhelp_copyin({ { float, float }**, i32 }* %in, { { float, float }**, i32 }* %from, i32 %i) {
entry:
  %in1 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %in, { { float, float }**, i32 }** %in1
  %from2 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %from, { { float, float }**, i32 }** %from2
  %i3 = alloca i32
  store i32 %i, i32* %i3
  %i4 = load i32, i32* %i3
  %in5 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %in1
  %lenref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %in5, i32 0, i32 1
  %len = load i32, i32* %lenref
  %tmp = icmp slt i32 %i4, %len
  br i1 %tmp, label %then, label %else

merge:                                            ; preds = %else, %then
  ret void

then:                                             ; preds = %entry
  %in6 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %in1
  %datarefref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %in6, i32 0, i32 0
  %dataref = load { float, float }**, { float, float }*** %datarefref
  %i7 = load i32, i32* %i3
  %from8 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %from2
  %i9 = load i32, i32* %i3
  %tmp10 = add i32 %i9, 1
  %dataref11 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %from8, i32 0, i32 0
  %data = load { float, float }**, { float, float }*** %dataref11
  %elref = getelementptr { float, float }*, { float, float }** %data, i32 %tmp10
  %el = load { float, float }*, { float, float }** %elref
  %copied = call { float, float }* @__copy2.1({ float, float }* %el)
  %storeref = getelementptr { float, float }*, { float, float }** %dataref, i32 %i7
  store { float, float }* %copied, { float, float }** %storeref
  %in12 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %in1
  %from13 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %from2
  %i14 = load i32, i32* %i3
  %tmp15 = add i32 %i14, 1
  call void @appendhelp_copyin({ { float, float }**, i32 }* %in12, { { float, float }**, i32 }* %from13, i32 %tmp15)
  br label %merge

else:                                             ; preds = %entry
  br label %merge
}

define { float, float }* @__copy2.1({ float, float }* %to_copy) {
entry:
  %to_copy1 = alloca { float, float }*
  store { float, float }* %to_copy, { float, float }** %to_copy1
  %to_copy2 = load { float, float }*, { float, float }** %to_copy1
  %malloccall = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2) to i32))
  %struct = bitcast i8* %malloccall to { float, float }*
  %flref = getelementptr { float, float }, { float, float }* %to_copy2, i32 0, i32 0
  %fl = load float, float* %flref
  %ref = getelementptr { float, float }, { float, float }* %struct, i32 0, i32 0
  store float %fl, float* %ref
  %flref3 = getelementptr { float, float }, { float, float }* %to_copy2, i32 0, i32 1
  %fl4 = load float, float* %flref3
  %ref5 = getelementptr { float, float }, { float, float }* %struct, i32 0, i32 1
  store float %fl4, float* %ref5
  ret { float, float }* %struct
}

define { { float, float }**, i32 }* @appendhelp_tail({ { float, float }**, i32 }* %p) {
entry:
  %p1 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %p, { { float, float }**, i32 }** %p1
  %tail = alloca { { float, float }**, i32 }*
  %p2 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  %lenref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p2, i32 0, i32 1
  %len = load i32, i32* %lenref
  %tmp = sub i32 %len, 1
  %malloccall = tail call i8* @malloc(i32 ptrtoint (i1** getelementptr (i1*, i1** null, i32 1) to i32))
  %arrdata = bitcast i8* %malloccall to { float, float }**
  %malloccall3 = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2) to i32))
  %anon = bitcast i8* %malloccall3 to { float, float }*
  %fieldaddr = getelementptr { float, float }, { float, float }* %anon, i32 0, i32 0
  store float 0.000000e+00, float* %fieldaddr
  %fieldaddr4 = getelementptr { float, float }, { float, float }* %anon, i32 0, i32 1
  store float 0.000000e+00, float* %fieldaddr4
  %storeref = getelementptr { float, float }*, { float, float }** %arrdata, i32 0
  store { float, float }* %anon, { float, float }** %storeref
  %malloccall5 = tail call i8* @malloc(i32 ptrtoint ({ { float, float }**, i32 }* getelementptr ({ { float, float }**, i32 }, { { float, float }**, i32 }* null, i32 1) to i32))
  %arr = bitcast i8* %malloccall5 to { { float, float }**, i32 }*
  %arrdata6 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 0
  %arrlen = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 1
  store { float, float }** %arrdata, { float, float }*** %arrdata6
  store i32 1, i32* %arrlen
  %lenref7 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 1
  %len8 = load i32, i32* %lenref7
  %oflen = mul i32 %tmp, %len8
  %olddataref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 0
  %olddata = load { float, float }**, { float, float }*** %olddataref
  %mallocsize = mul i32 %oflen, ptrtoint (i1** getelementptr (i1*, i1** null, i32 1) to i32)
  %malloccall9 = tail call i8* @malloc(i32 %mallocsize)
  %arrdata10 = bitcast i8* %malloccall9 to { float, float }**
  %i = alloca i32
  store i32 0, i32* %i
  %j = alloca i32
  store i32 0, i32* %j
  br label %inner

loop:                                             ; preds = %inner
  %i18 = load i32, i32* %i
  store i32 0, i32* %j
  %tmp19 = icmp slt i32 %i18, %oflen
  br i1 %tmp19, label %inner, label %continue

inner:                                            ; preds = %loop, %inner, %entry
  %i11 = load i32, i32* %j
  %i12 = load i32, i32* %i
  %elref = getelementptr { float, float }*, { float, float }** %olddata, i32 %i11
  %el = load { float, float }*, { float, float }** %elref
  %storeref13 = getelementptr { float, float }*, { float, float }** %arrdata10, i32 %i12
  store { float, float }* %el, { float, float }** %storeref13
  %i14 = add i32 %i12, 1
  store i32 %i14, i32* %i
  %j15 = add i32 %i11, 1
  store i32 %j15, i32* %j
  %j16 = load i32, i32* %j
  %tmp17 = icmp slt i32 %j16, %len8
  br i1 %tmp17, label %inner, label %loop

continue:                                         ; preds = %loop
  %malloccall20 = tail call i8* @malloc(i32 ptrtoint ({ { float, float }**, i32 }* getelementptr ({ { float, float }**, i32 }, { { float, float }**, i32 }* null, i32 1) to i32))
  %arr21 = bitcast i8* %malloccall20 to { { float, float }**, i32 }*
  %arrdata22 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr21, i32 0, i32 0
  %arrlen23 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr21, i32 0, i32 1
  store { float, float }** %arrdata10, { float, float }*** %arrdata22
  store i32 %oflen, i32* %arrlen23
  store { { float, float }**, i32 }* %arr21, { { float, float }**, i32 }** %tail
  %tail24 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %tail
  %p25 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  call void @appendhelp_copyin({ { float, float }**, i32 }* %tail24, { { float, float }**, i32 }* %p25, i32 0)
  %tail26 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %tail
  ret { { float, float }**, i32 }* %tail26
}

define { { float, float }**, i32 }* @append({ { float, float }**, i32 }* %p1, { { float, float }**, i32 }* %p2, float %epsilon) {
entry:
  %p11 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %p1, { { float, float }**, i32 }** %p11
  %p22 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %p2, { { float, float }**, i32 }** %p22
  %epsilon3 = alloca float
  store float %epsilon, float* %epsilon3
  %p14 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p11
  %lenref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p14, i32 0, i32 1
  %len = load i32, i32* %lenref
  %tmp = icmp eq i32 %len, 0
  %if_tmp = alloca { { float, float }**, i32 }*
  br i1 %tmp, label %then, label %else

merge:                                            ; preds = %merge11, %then
  %if_tmp66 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %if_tmp
  ret { { float, float }**, i32 }* %if_tmp66

then:                                             ; preds = %entry
  %p25 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p22
  %fxn_result = call { { float, float }**, i32 }* @copy_path({ { float, float }**, i32 }* %p25)
  store { { float, float }**, i32 }* %fxn_result, { { float, float }**, i32 }** %if_tmp
  br label %merge

else:                                             ; preds = %entry
  %p26 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p22
  %lenref7 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p26, i32 0, i32 1
  %len8 = load i32, i32* %lenref7
  %tmp9 = icmp eq i32 %len8, 0
  %if_tmp10 = alloca { { float, float }**, i32 }*
  br i1 %tmp9, label %then12, label %else13

merge11:                                          ; preds = %contb, %then12
  %if_tmp65 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %if_tmp10
  store { { float, float }**, i32 }* %if_tmp65, { { float, float }**, i32 }** %if_tmp
  br label %merge

then12:                                           ; preds = %else
  %p114 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p11
  %fxn_result15 = call { { float, float }**, i32 }* @copy_path({ { float, float }**, i32 }* %p114)
  store { { float, float }**, i32 }* %fxn_result15, { { float, float }**, i32 }** %if_tmp10
  br label %merge11

else13:                                           ; preds = %else
  %merge16 = alloca i1
  %p117 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p11
  %p118 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p11
  %lenref19 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p118, i32 0, i32 1
  %len20 = load i32, i32* %lenref19
  %tmp21 = sub i32 %len20, 1
  %dataref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p117, i32 0, i32 0
  %data = load { float, float }**, { float, float }*** %dataref
  %elref = getelementptr { float, float }*, { float, float }** %data, i32 %tmp21
  %el = load { float, float }*, { float, float }** %elref
  %p222 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p22
  %dataref23 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p222, i32 0, i32 0
  %data24 = load { float, float }**, { float, float }*** %dataref23
  %elref25 = getelementptr { float, float }*, { float, float }** %data24, i32 0
  %el26 = load { float, float }*, { float, float }** %elref25
  %fxn_result27 = call float @sqrDistance({ float, float }* %el, { float, float }* %el26)
  %epsilon28 = load float, float* %epsilon3
  %epsilon29 = load float, float* %epsilon3
  %tmp30 = fmul float %epsilon28, %epsilon29
  %tmp31 = fcmp olt float %fxn_result27, %tmp30
  store i1 %tmp31, i1* %merge16
  %p2c = alloca { { float, float }**, i32 }*
  %merge32 = load i1, i1* %merge16
  %if_tmp33 = alloca { { float, float }**, i32 }*
  br i1 %merge32, label %then35, label %else36

merge34:                                          ; preds = %else36, %then35
  %if_tmp40 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %if_tmp33
  store { { float, float }**, i32 }* %if_tmp40, { { float, float }**, i32 }** %p2c
  %ret = alloca { { float, float }**, i32 }*
  %p141 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p11
  %fxn_result42 = call { { float, float }**, i32 }* @copy_path({ { float, float }**, i32 }* %p141)
  %p2c43 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p2c
  %fxn_result44 = call { { float, float }**, i32 }* @copy_path({ { float, float }**, i32 }* %p2c43)
  %len1ref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %fxn_result42, i32 0, i32 1
  %len1 = load i32, i32* %len1ref
  %len2ref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %fxn_result44, i32 0, i32 1
  %len2 = load i32, i32* %len2ref
  %n = add i32 %len1, %len2
  %data1ref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %fxn_result42, i32 0, i32 0
  %data1 = load { float, float }**, { float, float }*** %data1ref
  %data2ref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %fxn_result44, i32 0, i32 0
  %data2 = load { float, float }**, { float, float }*** %data2ref
  %mallocsize = mul i32 %n, ptrtoint (i1** getelementptr (i1*, i1** null, i32 1) to i32)
  %malloccall = tail call i8* @malloc(i32 %mallocsize)
  %data45 = bitcast i8* %malloccall to { float, float }**
  %i = alloca i32
  store i32 0, i32* %i
  %j = alloca i32
  store i32 0, i32* %j
  br label %loop1

then35:                                           ; preds = %else13
  %p237 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p22
  %fxn_result38 = call { { float, float }**, i32 }* @appendhelp_tail({ { float, float }**, i32 }* %p237)
  store { { float, float }**, i32 }* %fxn_result38, { { float, float }**, i32 }** %if_tmp33
  br label %merge34

else36:                                           ; preds = %else13
  %p239 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p22
  store { { float, float }**, i32 }* %p239, { { float, float }**, i32 }** %if_tmp33
  br label %merge34

loop1:                                            ; preds = %loop1, %merge34
  %i46 = load i32, i32* %j
  %i47 = load i32, i32* %i
  %elref48 = getelementptr { float, float }*, { float, float }** %data1, i32 %i46
  %el49 = load { float, float }*, { float, float }** %elref48
  %storeref = getelementptr { float, float }*, { float, float }** %data45, i32 %i47
  store { float, float }* %el49, { float, float }** %storeref
  %tmp50 = add i32 %i47, 1
  store i32 %tmp50, i32* %i
  %j51 = add i32 %i46, 1
  store i32 %j51, i32* %j
  %j52 = load i32, i32* %j
  %tmp53 = icmp slt i32 %j52, %len1
  br i1 %tmp53, label %loop1, label %inbtw

inbtw:                                            ; preds = %loop1
  store i32 0, i32* %j
  br label %loop2

loop2:                                            ; preds = %loop2, %inbtw
  %i54 = load i32, i32* %j
  %i55 = load i32, i32* %i
  %elref56 = getelementptr { float, float }*, { float, float }** %data2, i32 %i54
  %el57 = load { float, float }*, { float, float }** %elref56
  %storeref58 = getelementptr { float, float }*, { float, float }** %data45, i32 %i55
  store { float, float }* %el57, { float, float }** %storeref58
  %tmp59 = add i32 %i55, 1
  store i32 %tmp59, i32* %i
  %j60 = add i32 %i54, 1
  store i32 %j60, i32* %j
  %j61 = load i32, i32* %j
  %tmp62 = icmp slt i32 %j61, %len2
  br i1 %tmp62, label %loop2, label %contb

contb:                                            ; preds = %loop2
  %malloccall63 = tail call i8* @malloc(i32 ptrtoint ({ { float, float }**, i32 }* getelementptr ({ { float, float }**, i32 }, { { float, float }**, i32 }* null, i32 1) to i32))
  %arr = bitcast i8* %malloccall63 to { { float, float }**, i32 }*
  %arrdata = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 0
  %arrlen = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 1
  store { float, float }** %data45, { float, float }*** %arrdata
  store i32 %n, i32* %arrlen
  store { { float, float }**, i32 }* %arr, { { float, float }**, i32 }** %ret
  %ret64 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %ret
  store { { float, float }**, i32 }* %ret64, { { float, float }**, i32 }** %if_tmp10
  br label %merge11
}

define void @reversedhelp({ { float, float }**, i32 }* %in, { { float, float }**, i32 }* %from, i32 %i) {
entry:
  %in1 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %in, { { float, float }**, i32 }** %in1
  %from2 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %from, { { float, float }**, i32 }** %from2
  %i3 = alloca i32
  store i32 %i, i32* %i3
  %i4 = load i32, i32* %i3
  %in5 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %in1
  %lenref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %in5, i32 0, i32 1
  %len = load i32, i32* %lenref
  %tmp = icmp slt i32 %i4, %len
  br i1 %tmp, label %then, label %else

merge:                                            ; preds = %else, %then
  ret void

then:                                             ; preds = %entry
  %in6 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %in1
  %i7 = load i32, i32* %i3
  %dataref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %in6, i32 0, i32 0
  %data = load { float, float }**, { float, float }*** %dataref
  %elref = getelementptr { float, float }*, { float, float }** %data, i32 %i7
  %el = load { float, float }*, { float, float }** %elref
  %from8 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %from2
  %in9 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %in1
  %lenref10 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %in9, i32 0, i32 1
  %len11 = load i32, i32* %lenref10
  %tmp12 = sub i32 %len11, 1
  %i13 = load i32, i32* %i3
  %tmp14 = sub i32 %tmp12, %i13
  %dataref15 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %from8, i32 0, i32 0
  %data16 = load { float, float }**, { float, float }*** %dataref15
  %elref17 = getelementptr { float, float }*, { float, float }** %data16, i32 %tmp14
  %el18 = load { float, float }*, { float, float }** %elref17
  %fieldadr = getelementptr { float, float }, { float, float }* %el18, i32 0, i32 0
  %x = load float, float* %fieldadr
  %ref = getelementptr { float, float }, { float, float }* %el, i32 0, i32 0
  store float %x, float* %ref
  %in19 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %in1
  %i20 = load i32, i32* %i3
  %dataref21 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %in19, i32 0, i32 0
  %data22 = load { float, float }**, { float, float }*** %dataref21
  %elref23 = getelementptr { float, float }*, { float, float }** %data22, i32 %i20
  %el24 = load { float, float }*, { float, float }** %elref23
  %from25 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %from2
  %in26 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %in1
  %lenref27 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %in26, i32 0, i32 1
  %len28 = load i32, i32* %lenref27
  %tmp29 = sub i32 %len28, 1
  %i30 = load i32, i32* %i3
  %tmp31 = sub i32 %tmp29, %i30
  %dataref32 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %from25, i32 0, i32 0
  %data33 = load { float, float }**, { float, float }*** %dataref32
  %elref34 = getelementptr { float, float }*, { float, float }** %data33, i32 %tmp31
  %el35 = load { float, float }*, { float, float }** %elref34
  %fieldadr36 = getelementptr { float, float }, { float, float }* %el35, i32 0, i32 1
  %y = load float, float* %fieldadr36
  %ref37 = getelementptr { float, float }, { float, float }* %el24, i32 0, i32 1
  store float %y, float* %ref37
  %in38 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %in1
  %from39 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %from2
  %i40 = load i32, i32* %i3
  %tmp41 = add i32 %i40, 1
  call void @reversedhelp({ { float, float }**, i32 }* %in38, { { float, float }**, i32 }* %from39, i32 %tmp41)
  br label %merge

else:                                             ; preds = %entry
  br label %merge
}

define { { float, float }**, i32 }* @reversed({ { float, float }**, i32 }* %p) {
entry:
  %p1 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %p, { { float, float }**, i32 }** %p1
  %newpath = alloca { { float, float }**, i32 }*
  %p2 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  %lenref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p2, i32 0, i32 1
  %len = load i32, i32* %lenref
  %malloccall = tail call i8* @malloc(i32 ptrtoint (i1** getelementptr (i1*, i1** null, i32 1) to i32))
  %arrdata = bitcast i8* %malloccall to { float, float }**
  %malloccall3 = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2) to i32))
  %anon = bitcast i8* %malloccall3 to { float, float }*
  %fieldaddr = getelementptr { float, float }, { float, float }* %anon, i32 0, i32 0
  store float 0.000000e+00, float* %fieldaddr
  %fieldaddr4 = getelementptr { float, float }, { float, float }* %anon, i32 0, i32 1
  store float 0.000000e+00, float* %fieldaddr4
  %storeref = getelementptr { float, float }*, { float, float }** %arrdata, i32 0
  store { float, float }* %anon, { float, float }** %storeref
  %malloccall5 = tail call i8* @malloc(i32 ptrtoint ({ { float, float }**, i32 }* getelementptr ({ { float, float }**, i32 }, { { float, float }**, i32 }* null, i32 1) to i32))
  %arr = bitcast i8* %malloccall5 to { { float, float }**, i32 }*
  %arrdata6 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 0
  %arrlen = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 1
  store { float, float }** %arrdata, { float, float }*** %arrdata6
  store i32 1, i32* %arrlen
  %lenref7 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 1
  %len8 = load i32, i32* %lenref7
  %oflen = mul i32 %len, %len8
  %olddataref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 0
  %olddata = load { float, float }**, { float, float }*** %olddataref
  %mallocsize = mul i32 %oflen, ptrtoint (i1** getelementptr (i1*, i1** null, i32 1) to i32)
  %malloccall9 = tail call i8* @malloc(i32 %mallocsize)
  %arrdata10 = bitcast i8* %malloccall9 to { float, float }**
  %i = alloca i32
  store i32 0, i32* %i
  %j = alloca i32
  store i32 0, i32* %j
  br label %inner

loop:                                             ; preds = %inner
  %i17 = load i32, i32* %i
  store i32 0, i32* %j
  %tmp18 = icmp slt i32 %i17, %oflen
  br i1 %tmp18, label %inner, label %continue

inner:                                            ; preds = %loop, %inner, %entry
  %i11 = load i32, i32* %j
  %i12 = load i32, i32* %i
  %elref = getelementptr { float, float }*, { float, float }** %olddata, i32 %i11
  %el = load { float, float }*, { float, float }** %elref
  %storeref13 = getelementptr { float, float }*, { float, float }** %arrdata10, i32 %i12
  store { float, float }* %el, { float, float }** %storeref13
  %i14 = add i32 %i12, 1
  store i32 %i14, i32* %i
  %j15 = add i32 %i11, 1
  store i32 %j15, i32* %j
  %j16 = load i32, i32* %j
  %tmp = icmp slt i32 %j16, %len8
  br i1 %tmp, label %inner, label %loop

continue:                                         ; preds = %loop
  %malloccall19 = tail call i8* @malloc(i32 ptrtoint ({ { float, float }**, i32 }* getelementptr ({ { float, float }**, i32 }, { { float, float }**, i32 }* null, i32 1) to i32))
  %arr20 = bitcast i8* %malloccall19 to { { float, float }**, i32 }*
  %arrdata21 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr20, i32 0, i32 0
  %arrlen22 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr20, i32 0, i32 1
  store { float, float }** %arrdata10, { float, float }*** %arrdata21
  store i32 %oflen, i32* %arrlen22
  store { { float, float }**, i32 }* %arr20, { { float, float }**, i32 }** %newpath
  %newpath23 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %newpath
  %p24 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  call void @reversedhelp({ { float, float }**, i32 }* %newpath23, { { float, float }**, i32 }* %p24, i32 0)
  %newpath25 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %newpath
  ret { { float, float }**, i32 }* %newpath25
}

define void @reversehelp({ { float, float }**, i32 }* %p, i32 %i) {
entry:
  %p1 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %p, { { float, float }**, i32 }** %p1
  %i2 = alloca i32
  store i32 %i, i32* %i2
  %i3 = load i32, i32* %i2
  %p4 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  %lenref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p4, i32 0, i32 1
  %len = load i32, i32* %lenref
  %tmp = sdiv i32 %len, 2
  %tmp5 = icmp slt i32 %i3, %tmp
  br i1 %tmp5, label %then, label %else

merge:                                            ; preds = %else, %then
  ret void

then:                                             ; preds = %entry
  %q = alloca { float, float }*
  %p6 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  %i7 = load i32, i32* %i2
  %dataref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p6, i32 0, i32 0
  %data = load { float, float }**, { float, float }*** %dataref
  %elref = getelementptr { float, float }*, { float, float }** %data, i32 %i7
  %el = load { float, float }*, { float, float }** %elref
  store { float, float }* %el, { float, float }** %q
  %p8 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  %datarefref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p8, i32 0, i32 0
  %dataref9 = load { float, float }**, { float, float }*** %datarefref
  %i10 = load i32, i32* %i2
  %p11 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  %p12 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  %lenref13 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p12, i32 0, i32 1
  %len14 = load i32, i32* %lenref13
  %tmp15 = sub i32 %len14, 1
  %i16 = load i32, i32* %i2
  %tmp17 = sub i32 %tmp15, %i16
  %dataref18 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p11, i32 0, i32 0
  %data19 = load { float, float }**, { float, float }*** %dataref18
  %elref20 = getelementptr { float, float }*, { float, float }** %data19, i32 %tmp17
  %el21 = load { float, float }*, { float, float }** %elref20
  %storeref = getelementptr { float, float }*, { float, float }** %dataref9, i32 %i10
  store { float, float }* %el21, { float, float }** %storeref
  %p22 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  %datarefref23 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p22, i32 0, i32 0
  %dataref24 = load { float, float }**, { float, float }*** %datarefref23
  %p25 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  %lenref26 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p25, i32 0, i32 1
  %len27 = load i32, i32* %lenref26
  %tmp28 = sub i32 %len27, 1
  %i29 = load i32, i32* %i2
  %tmp30 = sub i32 %tmp28, %i29
  %q31 = load { float, float }*, { float, float }** %q
  %storeref32 = getelementptr { float, float }*, { float, float }** %dataref24, i32 %tmp30
  store { float, float }* %q31, { float, float }** %storeref32
  %p33 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  %i34 = load i32, i32* %i2
  %tmp35 = add i32 %i34, 1
  call void @reversehelp({ { float, float }**, i32 }* %p33, i32 %tmp35)
  br label %merge

else:                                             ; preds = %entry
  br label %merge
}

define void @reverse({ { float, float }**, i32 }* %p) {
entry:
  %p1 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %p, { { float, float }**, i32 }** %p1
  %p2 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  call void @reversehelp({ { float, float }**, i32 }* %p2, i32 0)
  ret void
}

define { float, float, float, float }* @rgb(float %r, float %g, float %b) {
entry:
  %r1 = alloca float
  store float %r, float* %r1
  %g2 = alloca float
  store float %g, float* %g2
  %b3 = alloca float
  store float %b, float* %b3
  %malloccall = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 4) to i32))
  %anon = bitcast i8* %malloccall to { float, float, float, float }*
  %fieldaddr = getelementptr { float, float, float, float }, { float, float, float, float }* %anon, i32 0, i32 0
  %r4 = load float, float* %r1
  store float %r4, float* %fieldaddr
  %fieldaddr5 = getelementptr { float, float, float, float }, { float, float, float, float }* %anon, i32 0, i32 1
  %g6 = load float, float* %g2
  store float %g6, float* %fieldaddr5
  %fieldaddr7 = getelementptr { float, float, float, float }, { float, float, float, float }* %anon, i32 0, i32 2
  %b8 = load float, float* %b3
  store float %b8, float* %fieldaddr7
  %fieldaddr9 = getelementptr { float, float, float, float }, { float, float, float, float }* %anon, i32 0, i32 3
  store float 1.000000e+00, float* %fieldaddr9
  ret { float, float, float, float }* %anon
}

define { float, float, float, float }* @hsv(float %h, float %s, float %v) {
entry:
  %h1 = alloca float
  store float %h, float* %h1
  %s2 = alloca float
  store float %s, float* %s2
  %v3 = alloca float
  store float %v, float* %v3
  %c = alloca float
  %v4 = load float, float* %v3
  %s5 = load float, float* %s2
  %tmp = fmul float %v4, %s5
  store float %tmp, float* %c
  %hfac = alloca float
  %h6 = load float, float* %h1
  %tmp7 = fmul float %h6, 6.000000e+00
  %fxn_result = call float @modf(float %tmp7, float 2.000000e+00)
  store float %fxn_result, float* %hfac
  %x = alloca float
  %c8 = load float, float* %c
  %hfac9 = load float, float* %hfac
  %tmp10 = fsub float %hfac9, 1.000000e+00
  %fxn_result11 = call float @abs(float %tmp10)
  %tmp12 = fsub float 1.000000e+00, %fxn_result11
  %tmp13 = fmul float %c8, %tmp12
  store float %tmp13, float* %x
  %m = alloca float
  %v14 = load float, float* %v3
  %c15 = load float, float* %c
  %tmp16 = fsub float %v14, %c15
  store float %tmp16, float* %m
  %hh = alloca float
  %h17 = load float, float* %h1
  %tmp18 = fmul float %h17, 6.000000e+00
  store float %tmp18, float* %hh
  %hh19 = load float, float* %hh
  %tmp20 = fcmp olt float %hh19, 1.000000e+00
  %if_tmp = alloca { float, float, float, float }*
  br i1 %tmp20, label %then, label %else

merge:                                            ; preds = %merge30, %then
  %if_tmp85 = load { float, float, float, float }*, { float, float, float, float }** %if_tmp
  ret { float, float, float, float }* %if_tmp85

then:                                             ; preds = %entry
  %v21 = load float, float* %v3
  %x22 = load float, float* %x
  %m23 = load float, float* %m
  %tmp24 = fadd float %x22, %m23
  %m25 = load float, float* %m
  %fxn_result26 = call { float, float, float, float }* @rgb(float %v21, float %tmp24, float %m25)
  store { float, float, float, float }* %fxn_result26, { float, float, float, float }** %if_tmp
  br label %merge

else:                                             ; preds = %entry
  %hh27 = load float, float* %hh
  %tmp28 = fcmp olt float %hh27, 2.000000e+00
  %if_tmp29 = alloca { float, float, float, float }*
  br i1 %tmp28, label %then31, label %else32

merge30:                                          ; preds = %merge42, %then31
  %if_tmp84 = load { float, float, float, float }*, { float, float, float, float }** %if_tmp29
  store { float, float, float, float }* %if_tmp84, { float, float, float, float }** %if_tmp
  br label %merge

then31:                                           ; preds = %else
  %x33 = load float, float* %x
  %m34 = load float, float* %m
  %tmp35 = fadd float %x33, %m34
  %v36 = load float, float* %v3
  %m37 = load float, float* %m
  %fxn_result38 = call { float, float, float, float }* @rgb(float %tmp35, float %v36, float %m37)
  store { float, float, float, float }* %fxn_result38, { float, float, float, float }** %if_tmp29
  br label %merge30

else32:                                           ; preds = %else
  %hh39 = load float, float* %hh
  %tmp40 = fcmp olt float %hh39, 3.000000e+00
  %if_tmp41 = alloca { float, float, float, float }*
  br i1 %tmp40, label %then43, label %else44

merge42:                                          ; preds = %merge54, %then43
  %if_tmp83 = load { float, float, float, float }*, { float, float, float, float }** %if_tmp41
  store { float, float, float, float }* %if_tmp83, { float, float, float, float }** %if_tmp29
  br label %merge30

then43:                                           ; preds = %else32
  %m45 = load float, float* %m
  %v46 = load float, float* %v3
  %x47 = load float, float* %x
  %m48 = load float, float* %m
  %tmp49 = fadd float %x47, %m48
  %fxn_result50 = call { float, float, float, float }* @rgb(float %m45, float %v46, float %tmp49)
  store { float, float, float, float }* %fxn_result50, { float, float, float, float }** %if_tmp41
  br label %merge42

else44:                                           ; preds = %else32
  %hh51 = load float, float* %hh
  %tmp52 = fcmp olt float %hh51, 4.000000e+00
  %if_tmp53 = alloca { float, float, float, float }*
  br i1 %tmp52, label %then55, label %else56

merge54:                                          ; preds = %merge66, %then55
  %if_tmp82 = load { float, float, float, float }*, { float, float, float, float }** %if_tmp53
  store { float, float, float, float }* %if_tmp82, { float, float, float, float }** %if_tmp41
  br label %merge42

then55:                                           ; preds = %else44
  %m57 = load float, float* %m
  %x58 = load float, float* %x
  %m59 = load float, float* %m
  %tmp60 = fadd float %x58, %m59
  %v61 = load float, float* %v3
  %fxn_result62 = call { float, float, float, float }* @rgb(float %m57, float %tmp60, float %v61)
  store { float, float, float, float }* %fxn_result62, { float, float, float, float }** %if_tmp53
  br label %merge54

else56:                                           ; preds = %else44
  %hh63 = load float, float* %hh
  %tmp64 = fcmp olt float %hh63, 5.000000e+00
  %if_tmp65 = alloca { float, float, float, float }*
  br i1 %tmp64, label %then67, label %else68

merge66:                                          ; preds = %else68, %then67
  %if_tmp81 = load { float, float, float, float }*, { float, float, float, float }** %if_tmp65
  store { float, float, float, float }* %if_tmp81, { float, float, float, float }** %if_tmp53
  br label %merge54

then67:                                           ; preds = %else56
  %x69 = load float, float* %x
  %m70 = load float, float* %m
  %tmp71 = fadd float %x69, %m70
  %m72 = load float, float* %m
  %v73 = load float, float* %v3
  %fxn_result74 = call { float, float, float, float }* @rgb(float %tmp71, float %m72, float %v73)
  store { float, float, float, float }* %fxn_result74, { float, float, float, float }** %if_tmp65
  br label %merge66

else68:                                           ; preds = %else56
  %v75 = load float, float* %v3
  %m76 = load float, float* %m
  %x77 = load float, float* %x
  %m78 = load float, float* %m
  %tmp79 = fadd float %x77, %m78
  %fxn_result80 = call { float, float, float, float }* @rgb(float %v75, float %m76, float %tmp79)
  store { float, float, float, float }* %fxn_result80, { float, float, float, float }** %if_tmp65
  br label %merge66
}

define void @startCanvas({ i32, i32, i32 }* %c) {
entry:
  %c1 = alloca { i32, i32, i32 }*
  store { i32, i32, i32 }* %c, { i32, i32, i32 }** %c1
  %c2 = load { i32, i32, i32 }*, { i32, i32, i32 }** %c1
  %fieldadr = getelementptr { i32, i32, i32 }, { i32, i32, i32 }* %c2, i32 0, i32 0
  %width = load i32, i32* %fieldadr
  %c3 = load { i32, i32, i32 }*, { i32, i32, i32 }** %c1
  %fieldadr4 = getelementptr { i32, i32, i32 }, { i32, i32, i32 }* %c3, i32 0, i32 1
  %height = load i32, i32* %fieldadr4
  call void @gl_startRendering(i32 %width, i32 %height)
  ret void
}

define void @cvoid() {
entry:
  ret void
}

define void @drawHelper({ { float, float }**, i32 }* %point_structs, { { float, float, float, float }**, i32 }* %color_structs, i32 %numOfPoints, i32 %i, { float*, i32 }* %points, { float*, i32 }* %colors) {
entry:
  %point_structs1 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %point_structs, { { float, float }**, i32 }** %point_structs1
  %color_structs2 = alloca { { float, float, float, float }**, i32 }*
  store { { float, float, float, float }**, i32 }* %color_structs, { { float, float, float, float }**, i32 }** %color_structs2
  %numOfPoints3 = alloca i32
  store i32 %numOfPoints, i32* %numOfPoints3
  %i4 = alloca i32
  store i32 %i, i32* %i4
  %points5 = alloca { float*, i32 }*
  store { float*, i32 }* %points, { float*, i32 }** %points5
  %colors6 = alloca { float*, i32 }*
  store { float*, i32 }* %colors, { float*, i32 }** %colors6
  %i7 = load i32, i32* %i4
  %numOfPoints8 = load i32, i32* %numOfPoints3
  %tmp = icmp sge i32 %i7, %numOfPoints8
  br i1 %tmp, label %then, label %else

merge:                                            ; preds = %else, %then
  ret void

then:                                             ; preds = %entry
  call void @cvoid()
  br label %merge

else:                                             ; preds = %entry
  %px = alloca float
  %point_structs9 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %point_structs1
  %i10 = load i32, i32* %i4
  %dataref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %point_structs9, i32 0, i32 0
  %data = load { float, float }**, { float, float }*** %dataref
  %elref = getelementptr { float, float }*, { float, float }** %data, i32 %i10
  %el = load { float, float }*, { float, float }** %elref
  %fieldadr = getelementptr { float, float }, { float, float }* %el, i32 0, i32 0
  %x = load float, float* %fieldadr
  store float %x, float* %px
  %py = alloca float
  %point_structs11 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %point_structs1
  %i12 = load i32, i32* %i4
  %dataref13 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %point_structs11, i32 0, i32 0
  %data14 = load { float, float }**, { float, float }*** %dataref13
  %elref15 = getelementptr { float, float }*, { float, float }** %data14, i32 %i12
  %el16 = load { float, float }*, { float, float }** %elref15
  %fieldadr17 = getelementptr { float, float }, { float, float }* %el16, i32 0, i32 1
  %y = load float, float* %fieldadr17
  store float %y, float* %py
  %points18 = load { float*, i32 }*, { float*, i32 }** %points5
  %datarefref = getelementptr { float*, i32 }, { float*, i32 }* %points18, i32 0, i32 0
  %dataref19 = load float*, float** %datarefref
  %i20 = load i32, i32* %i4
  %tmp21 = mul i32 2, %i20
  %px22 = load float, float* %px
  %storeref = getelementptr float, float* %dataref19, i32 %tmp21
  store float %px22, float* %storeref
  %points23 = load { float*, i32 }*, { float*, i32 }** %points5
  %datarefref24 = getelementptr { float*, i32 }, { float*, i32 }* %points23, i32 0, i32 0
  %dataref25 = load float*, float** %datarefref24
  %i26 = load i32, i32* %i4
  %tmp27 = mul i32 2, %i26
  %tmp28 = add i32 %tmp27, 1
  %py29 = load float, float* %py
  %storeref30 = getelementptr float, float* %dataref25, i32 %tmp28
  store float %py29, float* %storeref30
  %cr = alloca float
  %color_structs31 = load { { float, float, float, float }**, i32 }*, { { float, float, float, float }**, i32 }** %color_structs2
  %i32 = load i32, i32* %i4
  %dataref33 = getelementptr { { float, float, float, float }**, i32 }, { { float, float, float, float }**, i32 }* %color_structs31, i32 0, i32 0
  %data34 = load { float, float, float, float }**, { float, float, float, float }*** %dataref33
  %elref35 = getelementptr { float, float, float, float }*, { float, float, float, float }** %data34, i32 %i32
  %el36 = load { float, float, float, float }*, { float, float, float, float }** %elref35
  %fieldadr37 = getelementptr { float, float, float, float }, { float, float, float, float }* %el36, i32 0, i32 0
  %r = load float, float* %fieldadr37
  store float %r, float* %cr
  %cg = alloca float
  %color_structs38 = load { { float, float, float, float }**, i32 }*, { { float, float, float, float }**, i32 }** %color_structs2
  %i39 = load i32, i32* %i4
  %dataref40 = getelementptr { { float, float, float, float }**, i32 }, { { float, float, float, float }**, i32 }* %color_structs38, i32 0, i32 0
  %data41 = load { float, float, float, float }**, { float, float, float, float }*** %dataref40
  %elref42 = getelementptr { float, float, float, float }*, { float, float, float, float }** %data41, i32 %i39
  %el43 = load { float, float, float, float }*, { float, float, float, float }** %elref42
  %fieldadr44 = getelementptr { float, float, float, float }, { float, float, float, float }* %el43, i32 0, i32 1
  %g = load float, float* %fieldadr44
  store float %g, float* %cg
  %cb = alloca float
  %color_structs45 = load { { float, float, float, float }**, i32 }*, { { float, float, float, float }**, i32 }** %color_structs2
  %i46 = load i32, i32* %i4
  %dataref47 = getelementptr { { float, float, float, float }**, i32 }, { { float, float, float, float }**, i32 }* %color_structs45, i32 0, i32 0
  %data48 = load { float, float, float, float }**, { float, float, float, float }*** %dataref47
  %elref49 = getelementptr { float, float, float, float }*, { float, float, float, float }** %data48, i32 %i46
  %el50 = load { float, float, float, float }*, { float, float, float, float }** %elref49
  %fieldadr51 = getelementptr { float, float, float, float }, { float, float, float, float }* %el50, i32 0, i32 2
  %b = load float, float* %fieldadr51
  store float %b, float* %cb
  %ca = alloca float
  %color_structs52 = load { { float, float, float, float }**, i32 }*, { { float, float, float, float }**, i32 }** %color_structs2
  %i53 = load i32, i32* %i4
  %dataref54 = getelementptr { { float, float, float, float }**, i32 }, { { float, float, float, float }**, i32 }* %color_structs52, i32 0, i32 0
  %data55 = load { float, float, float, float }**, { float, float, float, float }*** %dataref54
  %elref56 = getelementptr { float, float, float, float }*, { float, float, float, float }** %data55, i32 %i53
  %el57 = load { float, float, float, float }*, { float, float, float, float }** %elref56
  %fieldadr58 = getelementptr { float, float, float, float }, { float, float, float, float }* %el57, i32 0, i32 3
  %a = load float, float* %fieldadr58
  store float %a, float* %ca
  %colors59 = load { float*, i32 }*, { float*, i32 }** %colors6
  %datarefref60 = getelementptr { float*, i32 }, { float*, i32 }* %colors59, i32 0, i32 0
  %dataref61 = load float*, float** %datarefref60
  %i62 = load i32, i32* %i4
  %tmp63 = mul i32 4, %i62
  %cr64 = load float, float* %cr
  %storeref65 = getelementptr float, float* %dataref61, i32 %tmp63
  store float %cr64, float* %storeref65
  %colors66 = load { float*, i32 }*, { float*, i32 }** %colors6
  %datarefref67 = getelementptr { float*, i32 }, { float*, i32 }* %colors66, i32 0, i32 0
  %dataref68 = load float*, float** %datarefref67
  %i69 = load i32, i32* %i4
  %tmp70 = mul i32 4, %i69
  %tmp71 = add i32 %tmp70, 1
  %cg72 = load float, float* %cg
  %storeref73 = getelementptr float, float* %dataref68, i32 %tmp71
  store float %cg72, float* %storeref73
  %colors74 = load { float*, i32 }*, { float*, i32 }** %colors6
  %datarefref75 = getelementptr { float*, i32 }, { float*, i32 }* %colors74, i32 0, i32 0
  %dataref76 = load float*, float** %datarefref75
  %i77 = load i32, i32* %i4
  %tmp78 = mul i32 4, %i77
  %tmp79 = add i32 %tmp78, 2
  %cb80 = load float, float* %cb
  %storeref81 = getelementptr float, float* %dataref76, i32 %tmp79
  store float %cb80, float* %storeref81
  %colors82 = load { float*, i32 }*, { float*, i32 }** %colors6
  %datarefref83 = getelementptr { float*, i32 }, { float*, i32 }* %colors82, i32 0, i32 0
  %dataref84 = load float*, float** %datarefref83
  %i85 = load i32, i32* %i4
  %tmp86 = mul i32 4, %i85
  %tmp87 = add i32 %tmp86, 3
  %ca88 = load float, float* %ca
  %storeref89 = getelementptr float, float* %dataref84, i32 %tmp87
  store float %ca88, float* %storeref89
  %point_structs90 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %point_structs1
  %color_structs91 = load { { float, float, float, float }**, i32 }*, { { float, float, float, float }**, i32 }** %color_structs2
  %numOfPoints92 = load i32, i32* %numOfPoints3
  %i93 = load i32, i32* %i4
  %tmp94 = add i32 %i93, 1
  %points95 = load { float*, i32 }*, { float*, i32 }** %points5
  %colors96 = load { float*, i32 }*, { float*, i32 }** %colors6
  call void @drawHelper({ { float, float }**, i32 }* %point_structs90, { { float, float, float, float }**, i32 }* %color_structs91, i32 %numOfPoints92, i32 %tmp94, { float*, i32 }* %points95, { float*, i32 }* %colors96)
  br label %merge
}

define void @drawPoints({ { float, float }**, i32 }* %point_structs, { { float, float, float, float }**, i32 }* %color_structs) {
entry:
  %point_structs1 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %point_structs, { { float, float }**, i32 }** %point_structs1
  %color_structs2 = alloca { { float, float, float, float }**, i32 }*
  store { { float, float, float, float }**, i32 }* %color_structs, { { float, float, float, float }**, i32 }** %color_structs2
  %numOfPoints = alloca i32
  %point_structs3 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %point_structs1
  %lenref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %point_structs3, i32 0, i32 1
  %len = load i32, i32* %lenref
  store i32 %len, i32* %numOfPoints
  %points = alloca { float*, i32 }*
  %numOfPoints4 = load i32, i32* %numOfPoints
  %tmp = mul i32 %numOfPoints4, 2
  %malloccall = tail call i8* @malloc(i32 ptrtoint (float* getelementptr (float, float* null, i32 1) to i32))
  %arrdata = bitcast i8* %malloccall to float*
  %storeref = getelementptr float, float* %arrdata, i32 0
  store float 0.000000e+00, float* %storeref
  %malloccall5 = tail call i8* @malloc(i32 ptrtoint ({ float*, i32 }* getelementptr ({ float*, i32 }, { float*, i32 }* null, i32 1) to i32))
  %arr = bitcast i8* %malloccall5 to { float*, i32 }*
  %arrdata6 = getelementptr { float*, i32 }, { float*, i32 }* %arr, i32 0, i32 0
  %arrlen = getelementptr { float*, i32 }, { float*, i32 }* %arr, i32 0, i32 1
  store float* %arrdata, float** %arrdata6
  store i32 1, i32* %arrlen
  %lenref7 = getelementptr { float*, i32 }, { float*, i32 }* %arr, i32 0, i32 1
  %len8 = load i32, i32* %lenref7
  %oflen = mul i32 %tmp, %len8
  %olddataref = getelementptr { float*, i32 }, { float*, i32 }* %arr, i32 0, i32 0
  %olddata = load float*, float** %olddataref
  %mallocsize = mul i32 %oflen, ptrtoint (float* getelementptr (float, float* null, i32 1) to i32)
  %malloccall9 = tail call i8* @malloc(i32 %mallocsize)
  %arrdata10 = bitcast i8* %malloccall9 to float*
  %i = alloca i32
  store i32 0, i32* %i
  %j = alloca i32
  store i32 0, i32* %j
  br label %inner

loop:                                             ; preds = %inner
  %i18 = load i32, i32* %i
  store i32 0, i32* %j
  %tmp19 = icmp slt i32 %i18, %oflen
  br i1 %tmp19, label %inner, label %continue

inner:                                            ; preds = %loop, %inner, %entry
  %i11 = load i32, i32* %j
  %i12 = load i32, i32* %i
  %elref = getelementptr float, float* %olddata, i32 %i11
  %el = load float, float* %elref
  %storeref13 = getelementptr float, float* %arrdata10, i32 %i12
  store float %el, float* %storeref13
  %i14 = add i32 %i12, 1
  store i32 %i14, i32* %i
  %j15 = add i32 %i11, 1
  store i32 %j15, i32* %j
  %j16 = load i32, i32* %j
  %tmp17 = icmp slt i32 %j16, %len8
  br i1 %tmp17, label %inner, label %loop

continue:                                         ; preds = %loop
  %malloccall20 = tail call i8* @malloc(i32 ptrtoint ({ float*, i32 }* getelementptr ({ float*, i32 }, { float*, i32 }* null, i32 1) to i32))
  %arr21 = bitcast i8* %malloccall20 to { float*, i32 }*
  %arrdata22 = getelementptr { float*, i32 }, { float*, i32 }* %arr21, i32 0, i32 0
  %arrlen23 = getelementptr { float*, i32 }, { float*, i32 }* %arr21, i32 0, i32 1
  store float* %arrdata10, float** %arrdata22
  store i32 %oflen, i32* %arrlen23
  store { float*, i32 }* %arr21, { float*, i32 }** %points
  %colors = alloca { float*, i32 }*
  %numOfPoints24 = load i32, i32* %numOfPoints
  %tmp25 = mul i32 %numOfPoints24, 4
  %malloccall26 = tail call i8* @malloc(i32 ptrtoint (float* getelementptr (float, float* null, i32 1) to i32))
  %arrdata27 = bitcast i8* %malloccall26 to float*
  %storeref28 = getelementptr float, float* %arrdata27, i32 0
  store float 0.000000e+00, float* %storeref28
  %malloccall29 = tail call i8* @malloc(i32 ptrtoint ({ float*, i32 }* getelementptr ({ float*, i32 }, { float*, i32 }* null, i32 1) to i32))
  %arr30 = bitcast i8* %malloccall29 to { float*, i32 }*
  %arrdata31 = getelementptr { float*, i32 }, { float*, i32 }* %arr30, i32 0, i32 0
  %arrlen32 = getelementptr { float*, i32 }, { float*, i32 }* %arr30, i32 0, i32 1
  store float* %arrdata27, float** %arrdata31
  store i32 1, i32* %arrlen32
  %lenref33 = getelementptr { float*, i32 }, { float*, i32 }* %arr30, i32 0, i32 1
  %len34 = load i32, i32* %lenref33
  %oflen35 = mul i32 %tmp25, %len34
  %olddataref36 = getelementptr { float*, i32 }, { float*, i32 }* %arr30, i32 0, i32 0
  %olddata37 = load float*, float** %olddataref36
  %mallocsize38 = mul i32 %oflen35, ptrtoint (float* getelementptr (float, float* null, i32 1) to i32)
  %malloccall39 = tail call i8* @malloc(i32 %mallocsize38)
  %arrdata40 = bitcast i8* %malloccall39 to float*
  %i41 = alloca i32
  store i32 0, i32* %i41
  %j42 = alloca i32
  store i32 0, i32* %j42
  br label %inner44

loop43:                                           ; preds = %inner44
  %i55 = load i32, i32* %i41
  store i32 0, i32* %j42
  %tmp56 = icmp slt i32 %i55, %oflen35
  br i1 %tmp56, label %inner44, label %continue45

inner44:                                          ; preds = %loop43, %inner44, %continue
  %i46 = load i32, i32* %j42
  %i47 = load i32, i32* %i41
  %elref48 = getelementptr float, float* %olddata37, i32 %i46
  %el49 = load float, float* %elref48
  %storeref50 = getelementptr float, float* %arrdata40, i32 %i47
  store float %el49, float* %storeref50
  %i51 = add i32 %i47, 1
  store i32 %i51, i32* %i41
  %j52 = add i32 %i46, 1
  store i32 %j52, i32* %j42
  %j53 = load i32, i32* %j42
  %tmp54 = icmp slt i32 %j53, %len34
  br i1 %tmp54, label %inner44, label %loop43

continue45:                                       ; preds = %loop43
  %malloccall57 = tail call i8* @malloc(i32 ptrtoint ({ float*, i32 }* getelementptr ({ float*, i32 }, { float*, i32 }* null, i32 1) to i32))
  %arr58 = bitcast i8* %malloccall57 to { float*, i32 }*
  %arrdata59 = getelementptr { float*, i32 }, { float*, i32 }* %arr58, i32 0, i32 0
  %arrlen60 = getelementptr { float*, i32 }, { float*, i32 }* %arr58, i32 0, i32 1
  store float* %arrdata40, float** %arrdata59
  store i32 %oflen35, i32* %arrlen60
  store { float*, i32 }* %arr58, { float*, i32 }** %colors
  %point_structs61 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %point_structs1
  %color_structs62 = load { { float, float, float, float }**, i32 }*, { { float, float, float, float }**, i32 }** %color_structs2
  %numOfPoints63 = load i32, i32* %numOfPoints
  %points64 = load { float*, i32 }*, { float*, i32 }** %points
  %colors65 = load { float*, i32 }*, { float*, i32 }** %colors
  call void @drawHelper({ { float, float }**, i32 }* %point_structs61, { { float, float, float, float }**, i32 }* %color_structs62, i32 %numOfPoints63, i32 0, { float*, i32 }* %points64, { float*, i32 }* %colors65)
  %points66 = load { float*, i32 }*, { float*, i32 }** %points
  %colors67 = load { float*, i32 }*, { float*, i32 }** %colors
  call void @gl_drawPoint({ float*, i32 }* %points66, { float*, i32 }* %colors67, i32 2)
  ret void
}

define void @drawPath({ { float, float }**, i32 }* %point_structs, { { float, float, float, float }**, i32 }* %color_structs, i32 %colorMode) {
entry:
  %point_structs1 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %point_structs, { { float, float }**, i32 }** %point_structs1
  %color_structs2 = alloca { { float, float, float, float }**, i32 }*
  store { { float, float, float, float }**, i32 }* %color_structs, { { float, float, float, float }**, i32 }** %color_structs2
  %colorMode3 = alloca i32
  store i32 %colorMode, i32* %colorMode3
  %numOfPoints = alloca i32
  %point_structs4 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %point_structs1
  %lenref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %point_structs4, i32 0, i32 1
  %len = load i32, i32* %lenref
  store i32 %len, i32* %numOfPoints
  %points = alloca { float*, i32 }*
  %numOfPoints5 = load i32, i32* %numOfPoints
  %tmp = mul i32 %numOfPoints5, 2
  %malloccall = tail call i8* @malloc(i32 ptrtoint (float* getelementptr (float, float* null, i32 1) to i32))
  %arrdata = bitcast i8* %malloccall to float*
  %storeref = getelementptr float, float* %arrdata, i32 0
  store float 0.000000e+00, float* %storeref
  %malloccall6 = tail call i8* @malloc(i32 ptrtoint ({ float*, i32 }* getelementptr ({ float*, i32 }, { float*, i32 }* null, i32 1) to i32))
  %arr = bitcast i8* %malloccall6 to { float*, i32 }*
  %arrdata7 = getelementptr { float*, i32 }, { float*, i32 }* %arr, i32 0, i32 0
  %arrlen = getelementptr { float*, i32 }, { float*, i32 }* %arr, i32 0, i32 1
  store float* %arrdata, float** %arrdata7
  store i32 1, i32* %arrlen
  %lenref8 = getelementptr { float*, i32 }, { float*, i32 }* %arr, i32 0, i32 1
  %len9 = load i32, i32* %lenref8
  %oflen = mul i32 %tmp, %len9
  %olddataref = getelementptr { float*, i32 }, { float*, i32 }* %arr, i32 0, i32 0
  %olddata = load float*, float** %olddataref
  %mallocsize = mul i32 %oflen, ptrtoint (float* getelementptr (float, float* null, i32 1) to i32)
  %malloccall10 = tail call i8* @malloc(i32 %mallocsize)
  %arrdata11 = bitcast i8* %malloccall10 to float*
  %i = alloca i32
  store i32 0, i32* %i
  %j = alloca i32
  store i32 0, i32* %j
  br label %inner

loop:                                             ; preds = %inner
  %i19 = load i32, i32* %i
  store i32 0, i32* %j
  %tmp20 = icmp slt i32 %i19, %oflen
  br i1 %tmp20, label %inner, label %continue

inner:                                            ; preds = %loop, %inner, %entry
  %i12 = load i32, i32* %j
  %i13 = load i32, i32* %i
  %elref = getelementptr float, float* %olddata, i32 %i12
  %el = load float, float* %elref
  %storeref14 = getelementptr float, float* %arrdata11, i32 %i13
  store float %el, float* %storeref14
  %i15 = add i32 %i13, 1
  store i32 %i15, i32* %i
  %j16 = add i32 %i12, 1
  store i32 %j16, i32* %j
  %j17 = load i32, i32* %j
  %tmp18 = icmp slt i32 %j17, %len9
  br i1 %tmp18, label %inner, label %loop

continue:                                         ; preds = %loop
  %malloccall21 = tail call i8* @malloc(i32 ptrtoint ({ float*, i32 }* getelementptr ({ float*, i32 }, { float*, i32 }* null, i32 1) to i32))
  %arr22 = bitcast i8* %malloccall21 to { float*, i32 }*
  %arrdata23 = getelementptr { float*, i32 }, { float*, i32 }* %arr22, i32 0, i32 0
  %arrlen24 = getelementptr { float*, i32 }, { float*, i32 }* %arr22, i32 0, i32 1
  store float* %arrdata11, float** %arrdata23
  store i32 %oflen, i32* %arrlen24
  store { float*, i32 }* %arr22, { float*, i32 }** %points
  %colors = alloca { float*, i32 }*
  %numOfPoints25 = load i32, i32* %numOfPoints
  %tmp26 = mul i32 %numOfPoints25, 4
  %malloccall27 = tail call i8* @malloc(i32 ptrtoint (float* getelementptr (float, float* null, i32 1) to i32))
  %arrdata28 = bitcast i8* %malloccall27 to float*
  %storeref29 = getelementptr float, float* %arrdata28, i32 0
  store float 0.000000e+00, float* %storeref29
  %malloccall30 = tail call i8* @malloc(i32 ptrtoint ({ float*, i32 }* getelementptr ({ float*, i32 }, { float*, i32 }* null, i32 1) to i32))
  %arr31 = bitcast i8* %malloccall30 to { float*, i32 }*
  %arrdata32 = getelementptr { float*, i32 }, { float*, i32 }* %arr31, i32 0, i32 0
  %arrlen33 = getelementptr { float*, i32 }, { float*, i32 }* %arr31, i32 0, i32 1
  store float* %arrdata28, float** %arrdata32
  store i32 1, i32* %arrlen33
  %lenref34 = getelementptr { float*, i32 }, { float*, i32 }* %arr31, i32 0, i32 1
  %len35 = load i32, i32* %lenref34
  %oflen36 = mul i32 %tmp26, %len35
  %olddataref37 = getelementptr { float*, i32 }, { float*, i32 }* %arr31, i32 0, i32 0
  %olddata38 = load float*, float** %olddataref37
  %mallocsize39 = mul i32 %oflen36, ptrtoint (float* getelementptr (float, float* null, i32 1) to i32)
  %malloccall40 = tail call i8* @malloc(i32 %mallocsize39)
  %arrdata41 = bitcast i8* %malloccall40 to float*
  %i42 = alloca i32
  store i32 0, i32* %i42
  %j43 = alloca i32
  store i32 0, i32* %j43
  br label %inner45

loop44:                                           ; preds = %inner45
  %i56 = load i32, i32* %i42
  store i32 0, i32* %j43
  %tmp57 = icmp slt i32 %i56, %oflen36
  br i1 %tmp57, label %inner45, label %continue46

inner45:                                          ; preds = %loop44, %inner45, %continue
  %i47 = load i32, i32* %j43
  %i48 = load i32, i32* %i42
  %elref49 = getelementptr float, float* %olddata38, i32 %i47
  %el50 = load float, float* %elref49
  %storeref51 = getelementptr float, float* %arrdata41, i32 %i48
  store float %el50, float* %storeref51
  %i52 = add i32 %i48, 1
  store i32 %i52, i32* %i42
  %j53 = add i32 %i47, 1
  store i32 %j53, i32* %j43
  %j54 = load i32, i32* %j43
  %tmp55 = icmp slt i32 %j54, %len35
  br i1 %tmp55, label %inner45, label %loop44

continue46:                                       ; preds = %loop44
  %malloccall58 = tail call i8* @malloc(i32 ptrtoint ({ float*, i32 }* getelementptr ({ float*, i32 }, { float*, i32 }* null, i32 1) to i32))
  %arr59 = bitcast i8* %malloccall58 to { float*, i32 }*
  %arrdata60 = getelementptr { float*, i32 }, { float*, i32 }* %arr59, i32 0, i32 0
  %arrlen61 = getelementptr { float*, i32 }, { float*, i32 }* %arr59, i32 0, i32 1
  store float* %arrdata41, float** %arrdata60
  store i32 %oflen36, i32* %arrlen61
  store { float*, i32 }* %arr59, { float*, i32 }** %colors
  %point_structs62 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %point_structs1
  %color_structs63 = load { { float, float, float, float }**, i32 }*, { { float, float, float, float }**, i32 }** %color_structs2
  %numOfPoints64 = load i32, i32* %numOfPoints
  %points65 = load { float*, i32 }*, { float*, i32 }** %points
  %colors66 = load { float*, i32 }*, { float*, i32 }** %colors
  call void @drawHelper({ { float, float }**, i32 }* %point_structs62, { { float, float, float, float }**, i32 }* %color_structs63, i32 %numOfPoints64, i32 0, { float*, i32 }* %points65, { float*, i32 }* %colors66)
  %points67 = load { float*, i32 }*, { float*, i32 }** %points
  %colors68 = load { float*, i32 }*, { float*, i32 }** %colors
  %colorMode69 = load i32, i32* %colorMode3
  call void @gl_drawCurve({ float*, i32 }* %points67, { float*, i32 }* %colors68, i32 %colorMode69)
  ret void
}

define void @drawShape({ { float, float }**, i32 }* %point_structs, { { float, float, float, float }**, i32 }* %color_structs, i32 %colorMode, i32 %filled) {
entry:
  %point_structs1 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %point_structs, { { float, float }**, i32 }** %point_structs1
  %color_structs2 = alloca { { float, float, float, float }**, i32 }*
  store { { float, float, float, float }**, i32 }* %color_structs, { { float, float, float, float }**, i32 }** %color_structs2
  %colorMode3 = alloca i32
  store i32 %colorMode, i32* %colorMode3
  %filled4 = alloca i32
  store i32 %filled, i32* %filled4
  %numOfPoints = alloca i32
  %point_structs5 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %point_structs1
  %lenref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %point_structs5, i32 0, i32 1
  %len = load i32, i32* %lenref
  store i32 %len, i32* %numOfPoints
  %points = alloca { float*, i32 }*
  %numOfPoints6 = load i32, i32* %numOfPoints
  %tmp = mul i32 %numOfPoints6, 2
  %malloccall = tail call i8* @malloc(i32 ptrtoint (float* getelementptr (float, float* null, i32 1) to i32))
  %arrdata = bitcast i8* %malloccall to float*
  %storeref = getelementptr float, float* %arrdata, i32 0
  store float 0.000000e+00, float* %storeref
  %malloccall7 = tail call i8* @malloc(i32 ptrtoint ({ float*, i32 }* getelementptr ({ float*, i32 }, { float*, i32 }* null, i32 1) to i32))
  %arr = bitcast i8* %malloccall7 to { float*, i32 }*
  %arrdata8 = getelementptr { float*, i32 }, { float*, i32 }* %arr, i32 0, i32 0
  %arrlen = getelementptr { float*, i32 }, { float*, i32 }* %arr, i32 0, i32 1
  store float* %arrdata, float** %arrdata8
  store i32 1, i32* %arrlen
  %lenref9 = getelementptr { float*, i32 }, { float*, i32 }* %arr, i32 0, i32 1
  %len10 = load i32, i32* %lenref9
  %oflen = mul i32 %tmp, %len10
  %olddataref = getelementptr { float*, i32 }, { float*, i32 }* %arr, i32 0, i32 0
  %olddata = load float*, float** %olddataref
  %mallocsize = mul i32 %oflen, ptrtoint (float* getelementptr (float, float* null, i32 1) to i32)
  %malloccall11 = tail call i8* @malloc(i32 %mallocsize)
  %arrdata12 = bitcast i8* %malloccall11 to float*
  %i = alloca i32
  store i32 0, i32* %i
  %j = alloca i32
  store i32 0, i32* %j
  br label %inner

loop:                                             ; preds = %inner
  %i20 = load i32, i32* %i
  store i32 0, i32* %j
  %tmp21 = icmp slt i32 %i20, %oflen
  br i1 %tmp21, label %inner, label %continue

inner:                                            ; preds = %loop, %inner, %entry
  %i13 = load i32, i32* %j
  %i14 = load i32, i32* %i
  %elref = getelementptr float, float* %olddata, i32 %i13
  %el = load float, float* %elref
  %storeref15 = getelementptr float, float* %arrdata12, i32 %i14
  store float %el, float* %storeref15
  %i16 = add i32 %i14, 1
  store i32 %i16, i32* %i
  %j17 = add i32 %i13, 1
  store i32 %j17, i32* %j
  %j18 = load i32, i32* %j
  %tmp19 = icmp slt i32 %j18, %len10
  br i1 %tmp19, label %inner, label %loop

continue:                                         ; preds = %loop
  %malloccall22 = tail call i8* @malloc(i32 ptrtoint ({ float*, i32 }* getelementptr ({ float*, i32 }, { float*, i32 }* null, i32 1) to i32))
  %arr23 = bitcast i8* %malloccall22 to { float*, i32 }*
  %arrdata24 = getelementptr { float*, i32 }, { float*, i32 }* %arr23, i32 0, i32 0
  %arrlen25 = getelementptr { float*, i32 }, { float*, i32 }* %arr23, i32 0, i32 1
  store float* %arrdata12, float** %arrdata24
  store i32 %oflen, i32* %arrlen25
  store { float*, i32 }* %arr23, { float*, i32 }** %points
  %colors = alloca { float*, i32 }*
  %numOfPoints26 = load i32, i32* %numOfPoints
  %tmp27 = mul i32 %numOfPoints26, 4
  %malloccall28 = tail call i8* @malloc(i32 ptrtoint (float* getelementptr (float, float* null, i32 1) to i32))
  %arrdata29 = bitcast i8* %malloccall28 to float*
  %storeref30 = getelementptr float, float* %arrdata29, i32 0
  store float 0.000000e+00, float* %storeref30
  %malloccall31 = tail call i8* @malloc(i32 ptrtoint ({ float*, i32 }* getelementptr ({ float*, i32 }, { float*, i32 }* null, i32 1) to i32))
  %arr32 = bitcast i8* %malloccall31 to { float*, i32 }*
  %arrdata33 = getelementptr { float*, i32 }, { float*, i32 }* %arr32, i32 0, i32 0
  %arrlen34 = getelementptr { float*, i32 }, { float*, i32 }* %arr32, i32 0, i32 1
  store float* %arrdata29, float** %arrdata33
  store i32 1, i32* %arrlen34
  %lenref35 = getelementptr { float*, i32 }, { float*, i32 }* %arr32, i32 0, i32 1
  %len36 = load i32, i32* %lenref35
  %oflen37 = mul i32 %tmp27, %len36
  %olddataref38 = getelementptr { float*, i32 }, { float*, i32 }* %arr32, i32 0, i32 0
  %olddata39 = load float*, float** %olddataref38
  %mallocsize40 = mul i32 %oflen37, ptrtoint (float* getelementptr (float, float* null, i32 1) to i32)
  %malloccall41 = tail call i8* @malloc(i32 %mallocsize40)
  %arrdata42 = bitcast i8* %malloccall41 to float*
  %i43 = alloca i32
  store i32 0, i32* %i43
  %j44 = alloca i32
  store i32 0, i32* %j44
  br label %inner46

loop45:                                           ; preds = %inner46
  %i57 = load i32, i32* %i43
  store i32 0, i32* %j44
  %tmp58 = icmp slt i32 %i57, %oflen37
  br i1 %tmp58, label %inner46, label %continue47

inner46:                                          ; preds = %loop45, %inner46, %continue
  %i48 = load i32, i32* %j44
  %i49 = load i32, i32* %i43
  %elref50 = getelementptr float, float* %olddata39, i32 %i48
  %el51 = load float, float* %elref50
  %storeref52 = getelementptr float, float* %arrdata42, i32 %i49
  store float %el51, float* %storeref52
  %i53 = add i32 %i49, 1
  store i32 %i53, i32* %i43
  %j54 = add i32 %i48, 1
  store i32 %j54, i32* %j44
  %j55 = load i32, i32* %j44
  %tmp56 = icmp slt i32 %j55, %len36
  br i1 %tmp56, label %inner46, label %loop45

continue47:                                       ; preds = %loop45
  %malloccall59 = tail call i8* @malloc(i32 ptrtoint ({ float*, i32 }* getelementptr ({ float*, i32 }, { float*, i32 }* null, i32 1) to i32))
  %arr60 = bitcast i8* %malloccall59 to { float*, i32 }*
  %arrdata61 = getelementptr { float*, i32 }, { float*, i32 }* %arr60, i32 0, i32 0
  %arrlen62 = getelementptr { float*, i32 }, { float*, i32 }* %arr60, i32 0, i32 1
  store float* %arrdata42, float** %arrdata61
  store i32 %oflen37, i32* %arrlen62
  store { float*, i32 }* %arr60, { float*, i32 }** %colors
  %point_structs63 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %point_structs1
  %color_structs64 = load { { float, float, float, float }**, i32 }*, { { float, float, float, float }**, i32 }** %color_structs2
  %numOfPoints65 = load i32, i32* %numOfPoints
  %points66 = load { float*, i32 }*, { float*, i32 }** %points
  %colors67 = load { float*, i32 }*, { float*, i32 }** %colors
  call void @drawHelper({ { float, float }**, i32 }* %point_structs63, { { float, float, float, float }**, i32 }* %color_structs64, i32 %numOfPoints65, i32 0, { float*, i32 }* %points66, { float*, i32 }* %colors67)
  %points68 = load { float*, i32 }*, { float*, i32 }** %points
  %colors69 = load { float*, i32 }*, { float*, i32 }** %colors
  %colorMode70 = load i32, i32* %colorMode3
  %filled71 = load i32, i32* %filled4
  call void @gl_drawShape({ float*, i32 }* %points68, { float*, i32 }* %colors69, i32 %colorMode70, i32 %filled71)
  ret void
}

define void @endCanvas({ i32, i32, i32 }* %c) {
entry:
  %c1 = alloca { i32, i32, i32 }*
  store { i32, i32, i32 }* %c, { i32, i32, i32 }** %c1
  %c2 = load { i32, i32, i32 }*, { i32, i32, i32 }** %c1
  %fieldadr = getelementptr { i32, i32, i32 }, { i32, i32, i32 }* %c2, i32 0, i32 0
  %width = load i32, i32* %fieldadr
  %c3 = load { i32, i32, i32 }*, { i32, i32, i32 }** %c1
  %fieldadr4 = getelementptr { i32, i32, i32 }, { i32, i32, i32 }* %c3, i32 0, i32 1
  %height = load i32, i32* %fieldadr4
  %c5 = load { i32, i32, i32 }*, { i32, i32, i32 }** %c1
  %fieldadr6 = getelementptr { i32, i32, i32 }, { i32, i32, i32 }* %c5, i32 0, i32 2
  %file_number = load i32, i32* %fieldadr6
  call void @gl_endRendering(i32 %width, i32 %height, i32 %file_number)
  ret void
}

\end{lstlisting}}
	
	\subsubsection{Dragon}
	\colorbox{blue!30}{dragon.sos}
	\begin{lstlisting}
import renderer.sos
import vector.sos
import transform.sos
import array.sos
import math.sos

// Creates a dragon curve of depth n
dragon: (n: int) -> path =
    if n == 0 // Base case
    then [point{0.0, 0.0}, point{1.0, 0.0}]
    else
    // Create two copies of the previous depths
    d1: path = dragon(n-1) ;
    d2: path = copy_path(d1) ;

    // Position d1
    s: float = sqrt(2.0)/2.0 ;
    rotate(d1, toradians(45.0), -1, {0.0, 0.0}) ;
    scale(d1, s, s) ;

    // Position d2
    rotate(d2, toradians(135.0), -1, {0., 0.}) ;
    scale(d2,s,s) ;
    trans(d2, {1., 0.}) ;
    reverse(d2) ;

    // Merge the paths
    r: path = append(d1, d2, 1.0) ;
    free_path(d1); free_path(d2); r

// Creates a rainbow color effect
rainbow: (r: int, len: int) -> color =
    h: float = (1.0*r)/len ;
    hsv(h, 0.8, 0.8)

// Render a 400px by 400px canvas, name the image pic0
my_canvas: canvas = {400, 400, 0}

// Start render
startCanvas(my_canvas)
d: path = dragon(7)
// Position the curve (0.4, 0.2 is approximately the center of mass of the 
//curve for large n)
trans(d, {-0.4, -0.2})

// Draw it
drawPath(d, rainbow(ints(d.length), d.length), 0)
endCanvas(my_canvas)
\end{lstlisting}

{\tiny
\colorbox{green!30}{dragon.ll}
\begin{lstlisting}
 ModuleID = 'SOS'
source_filename = "SOS"

declare i32 @printf(i8*, ...)

define i32 @main() {
entry:
  %my_canvas = alloca { i32, i32, i32 }*
  %malloccall = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i64), i64 3) to i32))
  %anon = bitcast i8* %malloccall to { i32, i32, i32 }*
  %fieldaddr = getelementptr { i32, i32, i32 }, { i32, i32, i32 }* %anon, i32 0, i32 0
  store i32 400, i32* %fieldaddr
  %fieldaddr1 = getelementptr { i32, i32, i32 }, { i32, i32, i32 }* %anon, i32 0, i32 1
  store i32 400, i32* %fieldaddr1
  %fieldaddr2 = getelementptr { i32, i32, i32 }, { i32, i32, i32 }* %anon, i32 0, i32 2
  store i32 0, i32* %fieldaddr2
  store { i32, i32, i32 }* %anon, { i32, i32, i32 }** %my_canvas
  %my_canvas3 = load { i32, i32, i32 }*, { i32, i32, i32 }** %my_canvas
  call void @startCanvas({ i32, i32, i32 }* %my_canvas3)
  %d = alloca { { float, float }**, i32 }*
  %fxn_result = call { { float, float }**, i32 }* @dragon(i32 7)
  store { { float, float }**, i32 }* %fxn_result, { { float, float }**, i32 }** %d
  %d4 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %d
  %malloccall5 = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2) to i32))
  %anon6 = bitcast i8* %malloccall5 to { float, float }*
  %fieldaddr7 = getelementptr { float, float }, { float, float }* %anon6, i32 0, i32 0
  store float 0xBFD99999A0000000, float* %fieldaddr7
  %fieldaddr8 = getelementptr { float, float }, { float, float }* %anon6, i32 0, i32 1
  store float 0xBFC99999A0000000, float* %fieldaddr8
  %lenref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %d4, i32 0, i32 1
  %len = load i32, i32* %lenref
  %dataref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %d4, i32 0, i32 0
  %data = load { float, float }**, { float, float }*** %dataref
  %i = alloca i32
  store i32 0, i32* %i
  br label %loop

loop:                                             ; preds = %loop, %entry
  %i9 = load i32, i32* %i
  %elref = getelementptr { float, float }*, { float, float }** %data, i32 %i9
  %el = load { float, float }*, { float, float }** %elref
  call void @trans({ float, float }* %el, { float, float }* %anon6)
  %i10 = add i32 %i9, 1
  store i32 %i10, i32* %i
  %i11 = load i32, i32* %i
  %tmp = icmp slt i32 %i11, %len
  br i1 %tmp, label %loop, label %continue

continue:                                         ; preds = %loop
  %d12 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %d
  %d13 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %d
  %lenref14 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %d13, i32 0, i32 1
  %len15 = load i32, i32* %lenref14
  %fxn_result16 = call { i32*, i32 }* @ints(i32 %len15)
  %d17 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %d
  %lenref18 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %d17, i32 0, i32 1
  %len19 = load i32, i32* %lenref18
  %lenref20 = getelementptr { i32*, i32 }, { i32*, i32 }* %fxn_result16, i32 0, i32 1
  %len21 = load i32, i32* %lenref20
  %dataref22 = getelementptr { i32*, i32 }, { i32*, i32 }* %fxn_result16, i32 0, i32 0
  %data23 = load i32*, i32** %dataref22
  %mallocsize = mul i32 %len21, ptrtoint (i1** getelementptr (i1*, i1** null, i32 1) to i32)
  %malloccall24 = tail call i8* @malloc(i32 %mallocsize)
  %arrdata = bitcast i8* %malloccall24 to { float, float, float, float }**
  %i25 = alloca i32
  store i32 0, i32* %i25
  br label %loop26

loop26:                                           ; preds = %loop26, %continue
  %i28 = load i32, i32* %i25
  %elref29 = getelementptr i32, i32* %data23, i32 %i28
  %el30 = load i32, i32* %elref29
  %fxn_result31 = call { float, float, float, float }* @rainbow(i32 %el30, i32 %len19)
  %storeref = getelementptr { float, float, float, float }*, { float, float, float, float }** %arrdata, i32 %i28
  store { float, float, float, float }* %fxn_result31, { float, float, float, float }** %storeref
  %i32 = add i32 %i28, 1
  store i32 %i32, i32* %i25
  %i33 = load i32, i32* %i25
  %tmp34 = icmp slt i32 %i33, %len21
  br i1 %tmp34, label %loop26, label %continue27

continue27:                                       ; preds = %loop26
  %malloccall35 = tail call i8* @malloc(i32 ptrtoint ({ { float, float, float, float }**, i32 }* getelementptr ({ { float, float, float, float }**, i32 }, { { float, float, float, float }**, i32 }* null, i32 1) to i32))
  %arr = bitcast i8* %malloccall35 to { { float, float, float, float }**, i32 }*
  %arrdata36 = getelementptr { { float, float, float, float }**, i32 }, { { float, float, float, float }**, i32 }* %arr, i32 0, i32 0
  %arrlen = getelementptr { { float, float, float, float }**, i32 }, { { float, float, float, float }**, i32 }* %arr, i32 0, i32 1
  store { float, float, float, float }** %arrdata, { float, float, float, float }*** %arrdata36
  store i32 %len21, i32* %arrlen
  call void @drawPath({ { float, float }**, i32 }* %d12, { { float, float, float, float }**, i32 }* %arr, i32 0)
  %my_canvas37 = load { i32, i32, i32 }*, { i32, i32, i32 }** %my_canvas
  call void @endCanvas({ i32, i32, i32 }* %my_canvas37)
  ret i32 0
}

declare float @sqrtf(float)

declare float @sinf(float)

declare float @cosf(float)

declare float @tanf(float)

declare float @asinf(float)

declare float @acosf(float)

declare float @atanf(float)

declare float @toradiansf(float)

declare void @gl_startRendering(i32, i32)

declare void @gl_endRendering(i32, i32, i32)

declare void @gl_drawCurve({ float*, i32 }*, { float*, i32 }*, i32)

declare void @gl_drawShape({ float*, i32 }*, { float*, i32 }*, i32, i32)

declare void @gl_drawPoint({ float*, i32 }*, { float*, i32 }*, i32)

define float @floor(float %x) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %z = alloca float
  %y = alloca i32
  %x2 = load float, float* %x1
  %cast = fptosi float %x2 to i32
  store i32 %cast, i32* %y
  %cast3 = sitofp i32 %cast to float
  store float %cast3, float* %z
  %z4 = load float, float* %z
  %x5 = load float, float* %x1
  %tmp = fcmp ole float %z4, %x5
  %if_tmp = alloca float
  br i1 %tmp, label %then, label %else

merge:                                            ; preds = %else, %then
  %if_tmp9 = load float, float* %if_tmp
  ret float %if_tmp9

then:                                             ; preds = %entry
  %z6 = load float, float* %z
  store float %z6, float* %if_tmp
  br label %merge

else:                                             ; preds = %entry
  %z7 = load float, float* %z
  %tmp8 = fsub float %z7, 1.000000e+00
  store float %tmp8, float* %if_tmp
  br label %merge
}

define float @ceil(float %x) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %x2 = load float, float* %x1
  %tmp = fneg float %x2
  %fxn_result = call float @floor(float %tmp)
  %tmp3 = fneg float %fxn_result
  ret float %tmp3
}

define float @frac(float %x) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %x2 = load float, float* %x1
  %x3 = load float, float* %x1
  %fxn_result = call float @floor(float %x3)
  %tmp = fsub float %x2, %fxn_result
  ret float %tmp
}

define float @max(float %a, float %b) {
entry:
  %a1 = alloca float
  store float %a, float* %a1
  %b2 = alloca float
  store float %b, float* %b2
  %a3 = load float, float* %a1
  %b4 = load float, float* %b2
  %tmp = fcmp olt float %a3, %b4
  %if_tmp = alloca float
  br i1 %tmp, label %then, label %else

merge:                                            ; preds = %else, %then
  %if_tmp7 = load float, float* %if_tmp
  ret float %if_tmp7

then:                                             ; preds = %entry
  %b5 = load float, float* %b2
  store float %b5, float* %if_tmp
  br label %merge

else:                                             ; preds = %entry
  %a6 = load float, float* %a1
  store float %a6, float* %if_tmp
  br label %merge
}

define float @min(float %a, float %b) {
entry:
  %a1 = alloca float
  store float %a, float* %a1
  %b2 = alloca float
  store float %b, float* %b2
  %a3 = load float, float* %a1
  %b4 = load float, float* %b2
  %tmp = fcmp olt float %a3, %b4
  %if_tmp = alloca float
  br i1 %tmp, label %then, label %else

merge:                                            ; preds = %else, %then
  %if_tmp7 = load float, float* %if_tmp
  ret float %if_tmp7

then:                                             ; preds = %entry
  %a5 = load float, float* %a1
  store float %a5, float* %if_tmp
  br label %merge

else:                                             ; preds = %entry
  %b6 = load float, float* %b2
  store float %b6, float* %if_tmp
  br label %merge
}

define float @clamp(float %x, float %m, float %M) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %m2 = alloca float
  store float %m, float* %m2
  %M3 = alloca float
  store float %M, float* %M3
  %M4 = load float, float* %M3
  %x5 = load float, float* %x1
  %m6 = load float, float* %m2
  %fxn_result = call float @max(float %x5, float %m6)
  %fxn_result7 = call float @min(float %M4, float %fxn_result)
  ret float %fxn_result7
}

define float @abs(float %x) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %x2 = load float, float* %x1
  %tmp = fcmp olt float %x2, 0.000000e+00
  %if_tmp = alloca float
  br i1 %tmp, label %then, label %else

merge:                                            ; preds = %else, %then
  %if_tmp6 = load float, float* %if_tmp
  ret float %if_tmp6

then:                                             ; preds = %entry
  %x3 = load float, float* %x1
  %tmp4 = fneg float %x3
  store float %tmp4, float* %if_tmp
  br label %merge

else:                                             ; preds = %entry
  %x5 = load float, float* %x1
  store float %x5, float* %if_tmp
  br label %merge
}

define float @modf(float %x, float %m) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %m2 = alloca float
  store float %m, float* %m2
  %m3 = load float, float* %m2
  %x4 = load float, float* %x1
  %m5 = load float, float* %m2
  %tmp = fdiv float %x4, %m5
  %fxn_result = call float @frac(float %tmp)
  %tmp6 = fmul float %m3, %fxn_result
  ret float %tmp6
}

define float @sin(float %x) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %x2 = load float, float* %x1
  %fxn_result = call float @sinf(float %x2)
  ret float %fxn_result
}

define float @cos(float %x) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %x2 = load float, float* %x1
  %fxn_result = call float @cosf(float %x2)
  ret float %fxn_result
}

define float @tan(float %x) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %x2 = load float, float* %x1
  %fxn_result = call float @tanf(float %x2)
  ret float %fxn_result
}

define float @asin(float %x) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %x2 = load float, float* %x1
  %fxn_result = call float @asinf(float %x2)
  ret float %fxn_result
}

define float @acos(float %x) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %x2 = load float, float* %x1
  %fxn_result = call float @acosf(float %x2)
  ret float %fxn_result
}

define float @atan(float %x) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %x2 = load float, float* %x1
  %fxn_result = call float @atanf(float %x2)
  ret float %fxn_result
}

define float @sqrt(float %x) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %x2 = load float, float* %x1
  %fxn_result = call float @sqrtf(float %x2)
  ret float %fxn_result
}

define float @toradians(float %x) {
entry:
  %x1 = alloca float
  store float %x, float* %x1
  %x2 = load float, float* %x1
  %fxn_result = call float @toradiansf(float %x2)
  ret float %fxn_result
}

define float @sqrMagnitude({ float, float }* %p) {
entry:
  %p1 = alloca { float, float }*
  store { float, float }* %p, { float, float }** %p1
  %p2 = load { float, float }*, { float, float }** %p1
  %p3 = load { float, float }*, { float, float }** %p1
  %result = call float @__dotf2({ float, float }* %p2, { float, float }* %p3)
  ret float %result
}

define float @__dotf2({ float, float }* %a, { float, float }* %b) {
entry:
  %a1 = alloca { float, float }*
  store { float, float }* %a, { float, float }** %a1
  %a2 = load { float, float }*, { float, float }** %a1
  %b3 = alloca { float, float }*
  store { float, float }* %b, { float, float }** %b3
  %b4 = load { float, float }*, { float, float }** %b3
  %dot = alloca float
  %tmp = alloca float
  store float 0.000000e+00, float* %dot
  %avalref = getelementptr { float, float }, { float, float }* %a2, i32 0, i32 0
  %aval = load float, float* %avalref
  %bvalref = getelementptr { float, float }, { float, float }* %b4, i32 0, i32 0
  %bval = load float, float* %bvalref
  %tmp5 = fmul float %aval, %bval
  store float %tmp5, float* %tmp
  %tmp6 = load float, float* %tmp
  %res = load float, float* %dot
  %tmp7 = fadd float %tmp6, %res
  store float %tmp7, float* %dot
  %avalref8 = getelementptr { float, float }, { float, float }* %a2, i32 0, i32 1
  %aval9 = load float, float* %avalref8
  %bvalref10 = getelementptr { float, float }, { float, float }* %b4, i32 0, i32 1
  %bval11 = load float, float* %bvalref10
  %tmp12 = fmul float %aval9, %bval11
  store float %tmp12, float* %tmp
  %tmp13 = load float, float* %tmp
  %res14 = load float, float* %dot
  %tmp15 = fadd float %tmp13, %res14
  store float %tmp15, float* %dot
  %res16 = load float, float* %dot
  ret float %res16
}

define float @magnitude({ float, float }* %p) {
entry:
  %p1 = alloca { float, float }*
  store { float, float }* %p, { float, float }** %p1
  %p2 = load { float, float }*, { float, float }** %p1
  %fxn_result = call float @sqrMagnitude({ float, float }* %p2)
  %fxn_result3 = call float @sqrt(float %fxn_result)
  ret float %fxn_result3
}

define float @sqrDistance({ float, float }* %a, { float, float }* %b) {
entry:
  %a1 = alloca { float, float }*
  store { float, float }* %a, { float, float }** %a1
  %b2 = alloca { float, float }*
  store { float, float }* %b, { float, float }** %b2
  %p = alloca { float, float }*
  %a3 = load { float, float }*, { float, float }** %a1
  %b4 = load { float, float }*, { float, float }** %b2
  %result = call { float, float }* @__subf2({ float, float }* %a3, { float, float }* %b4)
  store { float, float }* %result, { float, float }** %p
  %d = alloca float
  %p5 = load { float, float }*, { float, float }** %p
  %fxn_result = call float @sqrMagnitude({ float, float }* %p5)
  store float %fxn_result, float* %d
  %p6 = load { float, float }*, { float, float }** %p
  %0 = bitcast { float, float }* %p6 to i8*
  tail call void @free(i8* %0)
  %d7 = load float, float* %d
  ret float %d7
}

define { float, float }* @__subf2({ float, float }* %a, { float, float }* %b) {
entry:
  %a1 = alloca { float, float }*
  store { float, float }* %a, { float, float }** %a1
  %a2 = load { float, float }*, { float, float }** %a1
  %b3 = alloca { float, float }*
  store { float, float }* %b, { float, float }** %b3
  %b4 = load { float, float }*, { float, float }** %b3
  %malloccall = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2) to i32))
  %ret = bitcast i8* %malloccall to { float, float }*
  %avalref = getelementptr { float, float }, { float, float }* %a2, i32 0, i32 0
  %aval = load float, float* %avalref
  %bvalref = getelementptr { float, float }, { float, float }* %b4, i32 0, i32 0
  %bval = load float, float* %bvalref
  %tmp = fsub float %aval, %bval
  %ref = getelementptr { float, float }, { float, float }* %ret, i32 0, i32 0
  store float %tmp, float* %ref
  %avalref5 = getelementptr { float, float }, { float, float }* %a2, i32 0, i32 1
  %aval6 = load float, float* %avalref5
  %bvalref7 = getelementptr { float, float }, { float, float }* %b4, i32 0, i32 1
  %bval8 = load float, float* %bvalref7
  %tmp9 = fsub float %aval6, %bval8
  %ref10 = getelementptr { float, float }, { float, float }* %ret, i32 0, i32 1
  store float %tmp9, float* %ref10
  ret { float, float }* %ret
}

declare noalias i8* @malloc(i32)

declare void @free(i8*)

define float @distance({ float, float }* %a, { float, float }* %b) {
entry:
  %a1 = alloca { float, float }*
  store { float, float }* %a, { float, float }** %a1
  %b2 = alloca { float, float }*
  store { float, float }* %b, { float, float }** %b2
  %a3 = load { float, float }*, { float, float }** %a1
  %b4 = load { float, float }*, { float, float }** %b2
  %fxn_result = call float @sqrDistance({ float, float }* %a3, { float, float }* %b4)
  %fxn_result5 = call float @sqrt(float %fxn_result)
  ret float %fxn_result5
}

define { float, float }* @copy_point({ float, float }* %p) {
entry:
  %p1 = alloca { float, float }*
  store { float, float }* %p, { float, float }** %p1
  %p2 = load { float, float }*, { float, float }** %p1
  %copied = call { float, float }* @__copy2({ float, float }* %p2)
  ret { float, float }* %copied
}

define { float, float }* @__copy2({ float, float }* %to_copy) {
entry:
  %to_copy1 = alloca { float, float }*
  store { float, float }* %to_copy, { float, float }** %to_copy1
  %to_copy2 = load { float, float }*, { float, float }** %to_copy1
  %malloccall = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2) to i32))
  %struct = bitcast i8* %malloccall to { float, float }*
  %flref = getelementptr { float, float }, { float, float }* %to_copy2, i32 0, i32 0
  %fl = load float, float* %flref
  %ref = getelementptr { float, float }, { float, float }* %struct, i32 0, i32 0
  store float %fl, float* %ref
  %flref3 = getelementptr { float, float }, { float, float }* %to_copy2, i32 0, i32 1
  %fl4 = load float, float* %flref3
  %ref5 = getelementptr { float, float }, { float, float }* %struct, i32 0, i32 1
  store float %fl4, float* %ref5
  ret { float, float }* %struct
}

define void @free_point({ float, float }* %p) {
entry:
  %p1 = alloca { float, float }*
  store { float, float }* %p, { float, float }** %p1
  %p2 = load { float, float }*, { float, float }** %p1
  %0 = bitcast { float, float }* %p2 to i8*
  tail call void @free(i8* %0)
  ret void
}

define { { float, float }**, i32 }* @copy_path({ { float, float }**, i32 }* %p) {
entry:
  %p1 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %p, { { float, float }**, i32 }** %p1
  %p2 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  %lenref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p2, i32 0, i32 1
  %len = load i32, i32* %lenref
  %dataref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p2, i32 0, i32 0
  %data = load { float, float }**, { float, float }*** %dataref
  %mallocsize = mul i32 %len, ptrtoint (i1** getelementptr (i1*, i1** null, i32 1) to i32)
  %malloccall = tail call i8* @malloc(i32 %mallocsize)
  %arrdata = bitcast i8* %malloccall to { float, float }**
  %i = alloca i32
  store i32 0, i32* %i
  br label %loop

loop:                                             ; preds = %loop, %entry
  %i3 = load i32, i32* %i
  %elref = getelementptr { float, float }*, { float, float }** %data, i32 %i3
  %el = load { float, float }*, { float, float }** %elref
  %fxn_result = call { float, float }* @copy_point({ float, float }* %el)
  %storeref = getelementptr { float, float }*, { float, float }** %arrdata, i32 %i3
  store { float, float }* %fxn_result, { float, float }** %storeref
  %i4 = add i32 %i3, 1
  store i32 %i4, i32* %i
  %i5 = load i32, i32* %i
  %tmp = icmp slt i32 %i5, %len
  br i1 %tmp, label %loop, label %continue

continue:                                         ; preds = %loop
  %malloccall6 = tail call i8* @malloc(i32 ptrtoint ({ { float, float }**, i32 }* getelementptr ({ { float, float }**, i32 }, { { float, float }**, i32 }* null, i32 1) to i32))
  %arr = bitcast i8* %malloccall6 to { { float, float }**, i32 }*
  %arrdata7 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 0
  %arrlen = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 1
  store { float, float }** %arrdata, { float, float }*** %arrdata7
  store i32 %len, i32* %arrlen
  ret { { float, float }**, i32 }* %arr
}

define void @free_path({ { float, float }**, i32 }* %p) {
entry:
  %p1 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %p, { { float, float }**, i32 }** %p1
  %p2 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  %lenref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p2, i32 0, i32 1
  %len = load i32, i32* %lenref
  %dataref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p2, i32 0, i32 0
  %data = load { float, float }**, { float, float }*** %dataref
  %i = alloca i32
  store i32 0, i32* %i
  br label %loop

loop:                                             ; preds = %loop, %entry
  %i3 = load i32, i32* %i
  %elref = getelementptr { float, float }*, { float, float }** %data, i32 %i3
  %el = load { float, float }*, { float, float }** %elref
  call void @free_point({ float, float }* %el)
  %i4 = add i32 %i3, 1
  store i32 %i4, i32* %i
  %i5 = load i32, i32* %i
  %tmp = icmp slt i32 %i5, %len
  br i1 %tmp, label %loop, label %continue

continue:                                         ; preds = %loop
  ret void
}

define void @appendhelp_copyin({ { float, float }**, i32 }* %in, { { float, float }**, i32 }* %from, i32 %i) {
entry:
  %in1 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %in, { { float, float }**, i32 }** %in1
  %from2 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %from, { { float, float }**, i32 }** %from2
  %i3 = alloca i32
  store i32 %i, i32* %i3
  %i4 = load i32, i32* %i3
  %in5 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %in1
  %lenref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %in5, i32 0, i32 1
  %len = load i32, i32* %lenref
  %tmp = icmp slt i32 %i4, %len
  br i1 %tmp, label %then, label %else

merge:                                            ; preds = %else, %then
  ret void

then:                                             ; preds = %entry
  %in6 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %in1
  %datarefref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %in6, i32 0, i32 0
  %dataref = load { float, float }**, { float, float }*** %datarefref
  %i7 = load i32, i32* %i3
  %from8 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %from2
  %i9 = load i32, i32* %i3
  %tmp10 = add i32 %i9, 1
  %dataref11 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %from8, i32 0, i32 0
  %data = load { float, float }**, { float, float }*** %dataref11
  %elref = getelementptr { float, float }*, { float, float }** %data, i32 %tmp10
  %el = load { float, float }*, { float, float }** %elref
  %copied = call { float, float }* @__copy2.1({ float, float }* %el)
  %storeref = getelementptr { float, float }*, { float, float }** %dataref, i32 %i7
  store { float, float }* %copied, { float, float }** %storeref
  %in12 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %in1
  %from13 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %from2
  %i14 = load i32, i32* %i3
  %tmp15 = add i32 %i14, 1
  call void @appendhelp_copyin({ { float, float }**, i32 }* %in12, { { float, float }**, i32 }* %from13, i32 %tmp15)
  br label %merge

else:                                             ; preds = %entry
  br label %merge
}

define { float, float }* @__copy2.1({ float, float }* %to_copy) {
entry:
  %to_copy1 = alloca { float, float }*
  store { float, float }* %to_copy, { float, float }** %to_copy1
  %to_copy2 = load { float, float }*, { float, float }** %to_copy1
  %malloccall = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2) to i32))
  %struct = bitcast i8* %malloccall to { float, float }*
  %flref = getelementptr { float, float }, { float, float }* %to_copy2, i32 0, i32 0
  %fl = load float, float* %flref
  %ref = getelementptr { float, float }, { float, float }* %struct, i32 0, i32 0
  store float %fl, float* %ref
  %flref3 = getelementptr { float, float }, { float, float }* %to_copy2, i32 0, i32 1
  %fl4 = load float, float* %flref3
  %ref5 = getelementptr { float, float }, { float, float }* %struct, i32 0, i32 1
  store float %fl4, float* %ref5
  ret { float, float }* %struct
}

define { { float, float }**, i32 }* @appendhelp_tail({ { float, float }**, i32 }* %p) {
entry:
  %p1 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %p, { { float, float }**, i32 }** %p1
  %tail = alloca { { float, float }**, i32 }*
  %p2 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  %lenref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p2, i32 0, i32 1
  %len = load i32, i32* %lenref
  %tmp = sub i32 %len, 1
  %malloccall = tail call i8* @malloc(i32 ptrtoint (i1** getelementptr (i1*, i1** null, i32 1) to i32))
  %arrdata = bitcast i8* %malloccall to { float, float }**
  %malloccall3 = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2) to i32))
  %anon = bitcast i8* %malloccall3 to { float, float }*
  %fieldaddr = getelementptr { float, float }, { float, float }* %anon, i32 0, i32 0
  store float 0.000000e+00, float* %fieldaddr
  %fieldaddr4 = getelementptr { float, float }, { float, float }* %anon, i32 0, i32 1
  store float 0.000000e+00, float* %fieldaddr4
  %storeref = getelementptr { float, float }*, { float, float }** %arrdata, i32 0
  store { float, float }* %anon, { float, float }** %storeref
  %malloccall5 = tail call i8* @malloc(i32 ptrtoint ({ { float, float }**, i32 }* getelementptr ({ { float, float }**, i32 }, { { float, float }**, i32 }* null, i32 1) to i32))
  %arr = bitcast i8* %malloccall5 to { { float, float }**, i32 }*
  %arrdata6 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 0
  %arrlen = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 1
  store { float, float }** %arrdata, { float, float }*** %arrdata6
  store i32 1, i32* %arrlen
  %lenref7 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 1
  %len8 = load i32, i32* %lenref7
  %oflen = mul i32 %tmp, %len8
  %olddataref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 0
  %olddata = load { float, float }**, { float, float }*** %olddataref
  %mallocsize = mul i32 %oflen, ptrtoint (i1** getelementptr (i1*, i1** null, i32 1) to i32)
  %malloccall9 = tail call i8* @malloc(i32 %mallocsize)
  %arrdata10 = bitcast i8* %malloccall9 to { float, float }**
  %i = alloca i32
  store i32 0, i32* %i
  %j = alloca i32
  store i32 0, i32* %j
  br label %inner

loop:                                             ; preds = %inner
  %i18 = load i32, i32* %i
  store i32 0, i32* %j
  %tmp19 = icmp slt i32 %i18, %oflen
  br i1 %tmp19, label %inner, label %continue

inner:                                            ; preds = %loop, %inner, %entry
  %i11 = load i32, i32* %j
  %i12 = load i32, i32* %i
  %elref = getelementptr { float, float }*, { float, float }** %olddata, i32 %i11
  %el = load { float, float }*, { float, float }** %elref
  %storeref13 = getelementptr { float, float }*, { float, float }** %arrdata10, i32 %i12
  store { float, float }* %el, { float, float }** %storeref13
  %i14 = add i32 %i12, 1
  store i32 %i14, i32* %i
  %j15 = add i32 %i11, 1
  store i32 %j15, i32* %j
  %j16 = load i32, i32* %j
  %tmp17 = icmp slt i32 %j16, %len8
  br i1 %tmp17, label %inner, label %loop

continue:                                         ; preds = %loop
  %malloccall20 = tail call i8* @malloc(i32 ptrtoint ({ { float, float }**, i32 }* getelementptr ({ { float, float }**, i32 }, { { float, float }**, i32 }* null, i32 1) to i32))
  %arr21 = bitcast i8* %malloccall20 to { { float, float }**, i32 }*
  %arrdata22 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr21, i32 0, i32 0
  %arrlen23 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr21, i32 0, i32 1
  store { float, float }** %arrdata10, { float, float }*** %arrdata22
  store i32 %oflen, i32* %arrlen23
  store { { float, float }**, i32 }* %arr21, { { float, float }**, i32 }** %tail
  %tail24 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %tail
  %p25 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  call void @appendhelp_copyin({ { float, float }**, i32 }* %tail24, { { float, float }**, i32 }* %p25, i32 0)
  %tail26 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %tail
  ret { { float, float }**, i32 }* %tail26
}

define { { float, float }**, i32 }* @append({ { float, float }**, i32 }* %p1, { { float, float }**, i32 }* %p2, float %epsilon) {
entry:
  %p11 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %p1, { { float, float }**, i32 }** %p11
  %p22 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %p2, { { float, float }**, i32 }** %p22
  %epsilon3 = alloca float
  store float %epsilon, float* %epsilon3
  %p14 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p11
  %lenref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p14, i32 0, i32 1
  %len = load i32, i32* %lenref
  %tmp = icmp eq i32 %len, 0
  %if_tmp = alloca { { float, float }**, i32 }*
  br i1 %tmp, label %then, label %else

merge:                                            ; preds = %merge11, %then
  %if_tmp66 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %if_tmp
  ret { { float, float }**, i32 }* %if_tmp66

then:                                             ; preds = %entry
  %p25 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p22
  %fxn_result = call { { float, float }**, i32 }* @copy_path({ { float, float }**, i32 }* %p25)
  store { { float, float }**, i32 }* %fxn_result, { { float, float }**, i32 }** %if_tmp
  br label %merge

else:                                             ; preds = %entry
  %p26 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p22
  %lenref7 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p26, i32 0, i32 1
  %len8 = load i32, i32* %lenref7
  %tmp9 = icmp eq i32 %len8, 0
  %if_tmp10 = alloca { { float, float }**, i32 }*
  br i1 %tmp9, label %then12, label %else13

merge11:                                          ; preds = %contb, %then12
  %if_tmp65 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %if_tmp10
  store { { float, float }**, i32 }* %if_tmp65, { { float, float }**, i32 }** %if_tmp
  br label %merge

then12:                                           ; preds = %else
  %p114 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p11
  %fxn_result15 = call { { float, float }**, i32 }* @copy_path({ { float, float }**, i32 }* %p114)
  store { { float, float }**, i32 }* %fxn_result15, { { float, float }**, i32 }** %if_tmp10
  br label %merge11

else13:                                           ; preds = %else
  %merge16 = alloca i1
  %p117 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p11
  %p118 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p11
  %lenref19 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p118, i32 0, i32 1
  %len20 = load i32, i32* %lenref19
  %tmp21 = sub i32 %len20, 1
  %dataref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p117, i32 0, i32 0
  %data = load { float, float }**, { float, float }*** %dataref
  %elref = getelementptr { float, float }*, { float, float }** %data, i32 %tmp21
  %el = load { float, float }*, { float, float }** %elref
  %p222 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p22
  %dataref23 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p222, i32 0, i32 0
  %data24 = load { float, float }**, { float, float }*** %dataref23
  %elref25 = getelementptr { float, float }*, { float, float }** %data24, i32 0
  %el26 = load { float, float }*, { float, float }** %elref25
  %fxn_result27 = call float @sqrDistance({ float, float }* %el, { float, float }* %el26)
  %epsilon28 = load float, float* %epsilon3
  %epsilon29 = load float, float* %epsilon3
  %tmp30 = fmul float %epsilon28, %epsilon29
  %tmp31 = fcmp olt float %fxn_result27, %tmp30
  store i1 %tmp31, i1* %merge16
  %p2c = alloca { { float, float }**, i32 }*
  %merge32 = load i1, i1* %merge16
  %if_tmp33 = alloca { { float, float }**, i32 }*
  br i1 %merge32, label %then35, label %else36

merge34:                                          ; preds = %else36, %then35
  %if_tmp40 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %if_tmp33
  store { { float, float }**, i32 }* %if_tmp40, { { float, float }**, i32 }** %p2c
  %ret = alloca { { float, float }**, i32 }*
  %p141 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p11
  %fxn_result42 = call { { float, float }**, i32 }* @copy_path({ { float, float }**, i32 }* %p141)
  %p2c43 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p2c
  %fxn_result44 = call { { float, float }**, i32 }* @copy_path({ { float, float }**, i32 }* %p2c43)
  %len1ref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %fxn_result42, i32 0, i32 1
  %len1 = load i32, i32* %len1ref
  %len2ref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %fxn_result44, i32 0, i32 1
  %len2 = load i32, i32* %len2ref
  %n = add i32 %len1, %len2
  %data1ref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %fxn_result42, i32 0, i32 0
  %data1 = load { float, float }**, { float, float }*** %data1ref
  %data2ref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %fxn_result44, i32 0, i32 0
  %data2 = load { float, float }**, { float, float }*** %data2ref
  %mallocsize = mul i32 %n, ptrtoint (i1** getelementptr (i1*, i1** null, i32 1) to i32)
  %malloccall = tail call i8* @malloc(i32 %mallocsize)
  %data45 = bitcast i8* %malloccall to { float, float }**
  %i = alloca i32
  store i32 0, i32* %i
  %j = alloca i32
  store i32 0, i32* %j
  br label %loop1

then35:                                           ; preds = %else13
  %p237 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p22
  %fxn_result38 = call { { float, float }**, i32 }* @appendhelp_tail({ { float, float }**, i32 }* %p237)
  store { { float, float }**, i32 }* %fxn_result38, { { float, float }**, i32 }** %if_tmp33
  br label %merge34

else36:                                           ; preds = %else13
  %p239 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p22
  store { { float, float }**, i32 }* %p239, { { float, float }**, i32 }** %if_tmp33
  br label %merge34

loop1:                                            ; preds = %loop1, %merge34
  %i46 = load i32, i32* %j
  %i47 = load i32, i32* %i
  %elref48 = getelementptr { float, float }*, { float, float }** %data1, i32 %i46
  %el49 = load { float, float }*, { float, float }** %elref48
  %storeref = getelementptr { float, float }*, { float, float }** %data45, i32 %i47
  store { float, float }* %el49, { float, float }** %storeref
  %tmp50 = add i32 %i47, 1
  store i32 %tmp50, i32* %i
  %j51 = add i32 %i46, 1
  store i32 %j51, i32* %j
  %j52 = load i32, i32* %j
  %tmp53 = icmp slt i32 %j52, %len1
  br i1 %tmp53, label %loop1, label %inbtw

inbtw:                                            ; preds = %loop1
  store i32 0, i32* %j
  br label %loop2

loop2:                                            ; preds = %loop2, %inbtw
  %i54 = load i32, i32* %j
  %i55 = load i32, i32* %i
  %elref56 = getelementptr { float, float }*, { float, float }** %data2, i32 %i54
  %el57 = load { float, float }*, { float, float }** %elref56
  %storeref58 = getelementptr { float, float }*, { float, float }** %data45, i32 %i55
  store { float, float }* %el57, { float, float }** %storeref58
  %tmp59 = add i32 %i55, 1
  store i32 %tmp59, i32* %i
  %j60 = add i32 %i54, 1
  store i32 %j60, i32* %j
  %j61 = load i32, i32* %j
  %tmp62 = icmp slt i32 %j61, %len2
  br i1 %tmp62, label %loop2, label %contb

contb:                                            ; preds = %loop2
  %malloccall63 = tail call i8* @malloc(i32 ptrtoint ({ { float, float }**, i32 }* getelementptr ({ { float, float }**, i32 }, { { float, float }**, i32 }* null, i32 1) to i32))
  %arr = bitcast i8* %malloccall63 to { { float, float }**, i32 }*
  %arrdata = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 0
  %arrlen = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 1
  store { float, float }** %data45, { float, float }*** %arrdata
  store i32 %n, i32* %arrlen
  store { { float, float }**, i32 }* %arr, { { float, float }**, i32 }** %ret
  %ret64 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %ret
  store { { float, float }**, i32 }* %ret64, { { float, float }**, i32 }** %if_tmp10
  br label %merge11
}

define void @reversedhelp({ { float, float }**, i32 }* %in, { { float, float }**, i32 }* %from, i32 %i) {
entry:
  %in1 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %in, { { float, float }**, i32 }** %in1
  %from2 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %from, { { float, float }**, i32 }** %from2
  %i3 = alloca i32
  store i32 %i, i32* %i3
  %i4 = load i32, i32* %i3
  %in5 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %in1
  %lenref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %in5, i32 0, i32 1
  %len = load i32, i32* %lenref
  %tmp = icmp slt i32 %i4, %len
  br i1 %tmp, label %then, label %else

merge:                                            ; preds = %else, %then
  ret void

then:                                             ; preds = %entry
  %in6 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %in1
  %i7 = load i32, i32* %i3
  %dataref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %in6, i32 0, i32 0
  %data = load { float, float }**, { float, float }*** %dataref
  %elref = getelementptr { float, float }*, { float, float }** %data, i32 %i7
  %el = load { float, float }*, { float, float }** %elref
  %from8 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %from2
  %in9 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %in1
  %lenref10 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %in9, i32 0, i32 1
  %len11 = load i32, i32* %lenref10
  %tmp12 = sub i32 %len11, 1
  %i13 = load i32, i32* %i3
  %tmp14 = sub i32 %tmp12, %i13
  %dataref15 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %from8, i32 0, i32 0
  %data16 = load { float, float }**, { float, float }*** %dataref15
  %elref17 = getelementptr { float, float }*, { float, float }** %data16, i32 %tmp14
  %el18 = load { float, float }*, { float, float }** %elref17
  %fieldadr = getelementptr { float, float }, { float, float }* %el18, i32 0, i32 0
  %x = load float, float* %fieldadr
  %ref = getelementptr { float, float }, { float, float }* %el, i32 0, i32 0
  store float %x, float* %ref
  %in19 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %in1
  %i20 = load i32, i32* %i3
  %dataref21 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %in19, i32 0, i32 0
  %data22 = load { float, float }**, { float, float }*** %dataref21
  %elref23 = getelementptr { float, float }*, { float, float }** %data22, i32 %i20
  %el24 = load { float, float }*, { float, float }** %elref23
  %from25 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %from2
  %in26 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %in1
  %lenref27 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %in26, i32 0, i32 1
  %len28 = load i32, i32* %lenref27
  %tmp29 = sub i32 %len28, 1
  %i30 = load i32, i32* %i3
  %tmp31 = sub i32 %tmp29, %i30
  %dataref32 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %from25, i32 0, i32 0
  %data33 = load { float, float }**, { float, float }*** %dataref32
  %elref34 = getelementptr { float, float }*, { float, float }** %data33, i32 %tmp31
  %el35 = load { float, float }*, { float, float }** %elref34
  %fieldadr36 = getelementptr { float, float }, { float, float }* %el35, i32 0, i32 1
  %y = load float, float* %fieldadr36
  %ref37 = getelementptr { float, float }, { float, float }* %el24, i32 0, i32 1
  store float %y, float* %ref37
  %in38 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %in1
  %from39 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %from2
  %i40 = load i32, i32* %i3
  %tmp41 = add i32 %i40, 1
  call void @reversedhelp({ { float, float }**, i32 }* %in38, { { float, float }**, i32 }* %from39, i32 %tmp41)
  br label %merge

else:                                             ; preds = %entry
  br label %merge
}

define { { float, float }**, i32 }* @reversed({ { float, float }**, i32 }* %p) {
entry:
  %p1 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %p, { { float, float }**, i32 }** %p1
  %newpath = alloca { { float, float }**, i32 }*
  %p2 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  %lenref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p2, i32 0, i32 1
  %len = load i32, i32* %lenref
  %malloccall = tail call i8* @malloc(i32 ptrtoint (i1** getelementptr (i1*, i1** null, i32 1) to i32))
  %arrdata = bitcast i8* %malloccall to { float, float }**
  %malloccall3 = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2) to i32))
  %anon = bitcast i8* %malloccall3 to { float, float }*
  %fieldaddr = getelementptr { float, float }, { float, float }* %anon, i32 0, i32 0
  store float 0.000000e+00, float* %fieldaddr
  %fieldaddr4 = getelementptr { float, float }, { float, float }* %anon, i32 0, i32 1
  store float 0.000000e+00, float* %fieldaddr4
  %storeref = getelementptr { float, float }*, { float, float }** %arrdata, i32 0
  store { float, float }* %anon, { float, float }** %storeref
  %malloccall5 = tail call i8* @malloc(i32 ptrtoint ({ { float, float }**, i32 }* getelementptr ({ { float, float }**, i32 }, { { float, float }**, i32 }* null, i32 1) to i32))
  %arr = bitcast i8* %malloccall5 to { { float, float }**, i32 }*
  %arrdata6 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 0
  %arrlen = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 1
  store { float, float }** %arrdata, { float, float }*** %arrdata6
  store i32 1, i32* %arrlen
  %lenref7 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 1
  %len8 = load i32, i32* %lenref7
  %oflen = mul i32 %len, %len8
  %olddataref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 0
  %olddata = load { float, float }**, { float, float }*** %olddataref
  %mallocsize = mul i32 %oflen, ptrtoint (i1** getelementptr (i1*, i1** null, i32 1) to i32)
  %malloccall9 = tail call i8* @malloc(i32 %mallocsize)
  %arrdata10 = bitcast i8* %malloccall9 to { float, float }**
  %i = alloca i32
  store i32 0, i32* %i
  %j = alloca i32
  store i32 0, i32* %j
  br label %inner

loop:                                             ; preds = %inner
  %i17 = load i32, i32* %i
  store i32 0, i32* %j
  %tmp18 = icmp slt i32 %i17, %oflen
  br i1 %tmp18, label %inner, label %continue

inner:                                            ; preds = %loop, %inner, %entry
  %i11 = load i32, i32* %j
  %i12 = load i32, i32* %i
  %elref = getelementptr { float, float }*, { float, float }** %olddata, i32 %i11
  %el = load { float, float }*, { float, float }** %elref
  %storeref13 = getelementptr { float, float }*, { float, float }** %arrdata10, i32 %i12
  store { float, float }* %el, { float, float }** %storeref13
  %i14 = add i32 %i12, 1
  store i32 %i14, i32* %i
  %j15 = add i32 %i11, 1
  store i32 %j15, i32* %j
  %j16 = load i32, i32* %j
  %tmp = icmp slt i32 %j16, %len8
  br i1 %tmp, label %inner, label %loop

continue:                                         ; preds = %loop
  %malloccall19 = tail call i8* @malloc(i32 ptrtoint ({ { float, float }**, i32 }* getelementptr ({ { float, float }**, i32 }, { { float, float }**, i32 }* null, i32 1) to i32))
  %arr20 = bitcast i8* %malloccall19 to { { float, float }**, i32 }*
  %arrdata21 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr20, i32 0, i32 0
  %arrlen22 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr20, i32 0, i32 1
  store { float, float }** %arrdata10, { float, float }*** %arrdata21
  store i32 %oflen, i32* %arrlen22
  store { { float, float }**, i32 }* %arr20, { { float, float }**, i32 }** %newpath
  %newpath23 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %newpath
  %p24 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  call void @reversedhelp({ { float, float }**, i32 }* %newpath23, { { float, float }**, i32 }* %p24, i32 0)
  %newpath25 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %newpath
  ret { { float, float }**, i32 }* %newpath25
}

define void @reversehelp({ { float, float }**, i32 }* %p, i32 %i) {
entry:
  %p1 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %p, { { float, float }**, i32 }** %p1
  %i2 = alloca i32
  store i32 %i, i32* %i2
  %i3 = load i32, i32* %i2
  %p4 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  %lenref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p4, i32 0, i32 1
  %len = load i32, i32* %lenref
  %tmp = sdiv i32 %len, 2
  %tmp5 = icmp slt i32 %i3, %tmp
  br i1 %tmp5, label %then, label %else

merge:                                            ; preds = %else, %then
  ret void

then:                                             ; preds = %entry
  %q = alloca { float, float }*
  %p6 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  %i7 = load i32, i32* %i2
  %dataref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p6, i32 0, i32 0
  %data = load { float, float }**, { float, float }*** %dataref
  %elref = getelementptr { float, float }*, { float, float }** %data, i32 %i7
  %el = load { float, float }*, { float, float }** %elref
  store { float, float }* %el, { float, float }** %q
  %p8 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  %datarefref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p8, i32 0, i32 0
  %dataref9 = load { float, float }**, { float, float }*** %datarefref
  %i10 = load i32, i32* %i2
  %p11 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  %p12 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  %lenref13 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p12, i32 0, i32 1
  %len14 = load i32, i32* %lenref13
  %tmp15 = sub i32 %len14, 1
  %i16 = load i32, i32* %i2
  %tmp17 = sub i32 %tmp15, %i16
  %dataref18 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p11, i32 0, i32 0
  %data19 = load { float, float }**, { float, float }*** %dataref18
  %elref20 = getelementptr { float, float }*, { float, float }** %data19, i32 %tmp17
  %el21 = load { float, float }*, { float, float }** %elref20
  %storeref = getelementptr { float, float }*, { float, float }** %dataref9, i32 %i10
  store { float, float }* %el21, { float, float }** %storeref
  %p22 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  %datarefref23 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p22, i32 0, i32 0
  %dataref24 = load { float, float }**, { float, float }*** %datarefref23
  %p25 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  %lenref26 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %p25, i32 0, i32 1
  %len27 = load i32, i32* %lenref26
  %tmp28 = sub i32 %len27, 1
  %i29 = load i32, i32* %i2
  %tmp30 = sub i32 %tmp28, %i29
  %q31 = load { float, float }*, { float, float }** %q
  %storeref32 = getelementptr { float, float }*, { float, float }** %dataref24, i32 %tmp30
  store { float, float }* %q31, { float, float }** %storeref32
  %p33 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  %i34 = load i32, i32* %i2
  %tmp35 = add i32 %i34, 1
  call void @reversehelp({ { float, float }**, i32 }* %p33, i32 %tmp35)
  br label %merge

else:                                             ; preds = %entry
  br label %merge
}

define void @reverse({ { float, float }**, i32 }* %p) {
entry:
  %p1 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %p, { { float, float }**, i32 }** %p1
  %p2 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %p1
  call void @reversehelp({ { float, float }**, i32 }* %p2, i32 0)
  ret void
}

define { float, float, float, float }* @rgb(float %r, float %g, float %b) {
entry:
  %r1 = alloca float
  store float %r, float* %r1
  %g2 = alloca float
  store float %g, float* %g2
  %b3 = alloca float
  store float %b, float* %b3
  %malloccall = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 4) to i32))
  %anon = bitcast i8* %malloccall to { float, float, float, float }*
  %fieldaddr = getelementptr { float, float, float, float }, { float, float, float, float }* %anon, i32 0, i32 0
  %r4 = load float, float* %r1
  store float %r4, float* %fieldaddr
  %fieldaddr5 = getelementptr { float, float, float, float }, { float, float, float, float }* %anon, i32 0, i32 1
  %g6 = load float, float* %g2
  store float %g6, float* %fieldaddr5
  %fieldaddr7 = getelementptr { float, float, float, float }, { float, float, float, float }* %anon, i32 0, i32 2
  %b8 = load float, float* %b3
  store float %b8, float* %fieldaddr7
  %fieldaddr9 = getelementptr { float, float, float, float }, { float, float, float, float }* %anon, i32 0, i32 3
  store float 1.000000e+00, float* %fieldaddr9
  ret { float, float, float, float }* %anon
}

define { float, float, float, float }* @hsv(float %h, float %s, float %v) {
entry:
  %h1 = alloca float
  store float %h, float* %h1
  %s2 = alloca float
  store float %s, float* %s2
  %v3 = alloca float
  store float %v, float* %v3
  %c = alloca float
  %v4 = load float, float* %v3
  %s5 = load float, float* %s2
  %tmp = fmul float %v4, %s5
  store float %tmp, float* %c
  %hfac = alloca float
  %h6 = load float, float* %h1
  %tmp7 = fmul float %h6, 6.000000e+00
  %fxn_result = call float @modf(float %tmp7, float 2.000000e+00)
  store float %fxn_result, float* %hfac
  %x = alloca float
  %c8 = load float, float* %c
  %hfac9 = load float, float* %hfac
  %tmp10 = fsub float %hfac9, 1.000000e+00
  %fxn_result11 = call float @abs(float %tmp10)
  %tmp12 = fsub float 1.000000e+00, %fxn_result11
  %tmp13 = fmul float %c8, %tmp12
  store float %tmp13, float* %x
  %m = alloca float
  %v14 = load float, float* %v3
  %c15 = load float, float* %c
  %tmp16 = fsub float %v14, %c15
  store float %tmp16, float* %m
  %hh = alloca float
  %h17 = load float, float* %h1
  %tmp18 = fmul float %h17, 6.000000e+00
  store float %tmp18, float* %hh
  %hh19 = load float, float* %hh
  %tmp20 = fcmp olt float %hh19, 1.000000e+00
  %if_tmp = alloca { float, float, float, float }*
  br i1 %tmp20, label %then, label %else

merge:                                            ; preds = %merge30, %then
  %if_tmp85 = load { float, float, float, float }*, { float, float, float, float }** %if_tmp
  ret { float, float, float, float }* %if_tmp85

then:                                             ; preds = %entry
  %v21 = load float, float* %v3
  %x22 = load float, float* %x
  %m23 = load float, float* %m
  %tmp24 = fadd float %x22, %m23
  %m25 = load float, float* %m
  %fxn_result26 = call { float, float, float, float }* @rgb(float %v21, float %tmp24, float %m25)
  store { float, float, float, float }* %fxn_result26, { float, float, float, float }** %if_tmp
  br label %merge

else:                                             ; preds = %entry
  %hh27 = load float, float* %hh
  %tmp28 = fcmp olt float %hh27, 2.000000e+00
  %if_tmp29 = alloca { float, float, float, float }*
  br i1 %tmp28, label %then31, label %else32

merge30:                                          ; preds = %merge42, %then31
  %if_tmp84 = load { float, float, float, float }*, { float, float, float, float }** %if_tmp29
  store { float, float, float, float }* %if_tmp84, { float, float, float, float }** %if_tmp
  br label %merge

then31:                                           ; preds = %else
  %x33 = load float, float* %x
  %m34 = load float, float* %m
  %tmp35 = fadd float %x33, %m34
  %v36 = load float, float* %v3
  %m37 = load float, float* %m
  %fxn_result38 = call { float, float, float, float }* @rgb(float %tmp35, float %v36, float %m37)
  store { float, float, float, float }* %fxn_result38, { float, float, float, float }** %if_tmp29
  br label %merge30

else32:                                           ; preds = %else
  %hh39 = load float, float* %hh
  %tmp40 = fcmp olt float %hh39, 3.000000e+00
  %if_tmp41 = alloca { float, float, float, float }*
  br i1 %tmp40, label %then43, label %else44

merge42:                                          ; preds = %merge54, %then43
  %if_tmp83 = load { float, float, float, float }*, { float, float, float, float }** %if_tmp41
  store { float, float, float, float }* %if_tmp83, { float, float, float, float }** %if_tmp29
  br label %merge30

then43:                                           ; preds = %else32
  %m45 = load float, float* %m
  %v46 = load float, float* %v3
  %x47 = load float, float* %x
  %m48 = load float, float* %m
  %tmp49 = fadd float %x47, %m48
  %fxn_result50 = call { float, float, float, float }* @rgb(float %m45, float %v46, float %tmp49)
  store { float, float, float, float }* %fxn_result50, { float, float, float, float }** %if_tmp41
  br label %merge42

else44:                                           ; preds = %else32
  %hh51 = load float, float* %hh
  %tmp52 = fcmp olt float %hh51, 4.000000e+00
  %if_tmp53 = alloca { float, float, float, float }*
  br i1 %tmp52, label %then55, label %else56

merge54:                                          ; preds = %merge66, %then55
  %if_tmp82 = load { float, float, float, float }*, { float, float, float, float }** %if_tmp53
  store { float, float, float, float }* %if_tmp82, { float, float, float, float }** %if_tmp41
  br label %merge42

then55:                                           ; preds = %else44
  %m57 = load float, float* %m
  %x58 = load float, float* %x
  %m59 = load float, float* %m
  %tmp60 = fadd float %x58, %m59
  %v61 = load float, float* %v3
  %fxn_result62 = call { float, float, float, float }* @rgb(float %m57, float %tmp60, float %v61)
  store { float, float, float, float }* %fxn_result62, { float, float, float, float }** %if_tmp53
  br label %merge54

else56:                                           ; preds = %else44
  %hh63 = load float, float* %hh
  %tmp64 = fcmp olt float %hh63, 5.000000e+00
  %if_tmp65 = alloca { float, float, float, float }*
  br i1 %tmp64, label %then67, label %else68

merge66:                                          ; preds = %else68, %then67
  %if_tmp81 = load { float, float, float, float }*, { float, float, float, float }** %if_tmp65
  store { float, float, float, float }* %if_tmp81, { float, float, float, float }** %if_tmp53
  br label %merge54

then67:                                           ; preds = %else56
  %x69 = load float, float* %x
  %m70 = load float, float* %m
  %tmp71 = fadd float %x69, %m70
  %m72 = load float, float* %m
  %v73 = load float, float* %v3
  %fxn_result74 = call { float, float, float, float }* @rgb(float %tmp71, float %m72, float %v73)
  store { float, float, float, float }* %fxn_result74, { float, float, float, float }** %if_tmp65
  br label %merge66

else68:                                           ; preds = %else56
  %v75 = load float, float* %v3
  %m76 = load float, float* %m
  %x77 = load float, float* %x
  %m78 = load float, float* %m
  %tmp79 = fadd float %x77, %m78
  %fxn_result80 = call { float, float, float, float }* @rgb(float %v75, float %m76, float %tmp79)
  store { float, float, float, float }* %fxn_result80, { float, float, float, float }** %if_tmp65
  br label %merge66
}

define void @startCanvas({ i32, i32, i32 }* %c) {
entry:
  %c1 = alloca { i32, i32, i32 }*
  store { i32, i32, i32 }* %c, { i32, i32, i32 }** %c1
  %c2 = load { i32, i32, i32 }*, { i32, i32, i32 }** %c1
  %fieldadr = getelementptr { i32, i32, i32 }, { i32, i32, i32 }* %c2, i32 0, i32 0
  %width = load i32, i32* %fieldadr
  %c3 = load { i32, i32, i32 }*, { i32, i32, i32 }** %c1
  %fieldadr4 = getelementptr { i32, i32, i32 }, { i32, i32, i32 }* %c3, i32 0, i32 1
  %height = load i32, i32* %fieldadr4
  call void @gl_startRendering(i32 %width, i32 %height)
  ret void
}

define void @cvoid() {
entry:
  ret void
}

define void @drawHelper({ { float, float }**, i32 }* %point_structs, { { float, float, float, float }**, i32 }* %color_structs, i32 %numOfPoints, i32 %i, { float*, i32 }* %points, { float*, i32 }* %colors) {
entry:
  %point_structs1 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %point_structs, { { float, float }**, i32 }** %point_structs1
  %color_structs2 = alloca { { float, float, float, float }**, i32 }*
  store { { float, float, float, float }**, i32 }* %color_structs, { { float, float, float, float }**, i32 }** %color_structs2
  %numOfPoints3 = alloca i32
  store i32 %numOfPoints, i32* %numOfPoints3
  %i4 = alloca i32
  store i32 %i, i32* %i4
  %points5 = alloca { float*, i32 }*
  store { float*, i32 }* %points, { float*, i32 }** %points5
  %colors6 = alloca { float*, i32 }*
  store { float*, i32 }* %colors, { float*, i32 }** %colors6
  %i7 = load i32, i32* %i4
  %numOfPoints8 = load i32, i32* %numOfPoints3
  %tmp = icmp sge i32 %i7, %numOfPoints8
  br i1 %tmp, label %then, label %else

merge:                                            ; preds = %else, %then
  ret void

then:                                             ; preds = %entry
  call void @cvoid()
  br label %merge

else:                                             ; preds = %entry
  %px = alloca float
  %point_structs9 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %point_structs1
  %i10 = load i32, i32* %i4
  %dataref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %point_structs9, i32 0, i32 0
  %data = load { float, float }**, { float, float }*** %dataref
  %elref = getelementptr { float, float }*, { float, float }** %data, i32 %i10
  %el = load { float, float }*, { float, float }** %elref
  %fieldadr = getelementptr { float, float }, { float, float }* %el, i32 0, i32 0
  %x = load float, float* %fieldadr
  store float %x, float* %px
  %py = alloca float
  %point_structs11 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %point_structs1
  %i12 = load i32, i32* %i4
  %dataref13 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %point_structs11, i32 0, i32 0
  %data14 = load { float, float }**, { float, float }*** %dataref13
  %elref15 = getelementptr { float, float }*, { float, float }** %data14, i32 %i12
  %el16 = load { float, float }*, { float, float }** %elref15
  %fieldadr17 = getelementptr { float, float }, { float, float }* %el16, i32 0, i32 1
  %y = load float, float* %fieldadr17
  store float %y, float* %py
  %points18 = load { float*, i32 }*, { float*, i32 }** %points5
  %datarefref = getelementptr { float*, i32 }, { float*, i32 }* %points18, i32 0, i32 0
  %dataref19 = load float*, float** %datarefref
  %i20 = load i32, i32* %i4
  %tmp21 = mul i32 2, %i20
  %px22 = load float, float* %px
  %storeref = getelementptr float, float* %dataref19, i32 %tmp21
  store float %px22, float* %storeref
  %points23 = load { float*, i32 }*, { float*, i32 }** %points5
  %datarefref24 = getelementptr { float*, i32 }, { float*, i32 }* %points23, i32 0, i32 0
  %dataref25 = load float*, float** %datarefref24
  %i26 = load i32, i32* %i4
  %tmp27 = mul i32 2, %i26
  %tmp28 = add i32 %tmp27, 1
  %py29 = load float, float* %py
  %storeref30 = getelementptr float, float* %dataref25, i32 %tmp28
  store float %py29, float* %storeref30
  %cr = alloca float
  %color_structs31 = load { { float, float, float, float }**, i32 }*, { { float, float, float, float }**, i32 }** %color_structs2
  %i32 = load i32, i32* %i4
  %dataref33 = getelementptr { { float, float, float, float }**, i32 }, { { float, float, float, float }**, i32 }* %color_structs31, i32 0, i32 0
  %data34 = load { float, float, float, float }**, { float, float, float, float }*** %dataref33
  %elref35 = getelementptr { float, float, float, float }*, { float, float, float, float }** %data34, i32 %i32
  %el36 = load { float, float, float, float }*, { float, float, float, float }** %elref35
  %fieldadr37 = getelementptr { float, float, float, float }, { float, float, float, float }* %el36, i32 0, i32 0
  %r = load float, float* %fieldadr37
  store float %r, float* %cr
  %cg = alloca float
  %color_structs38 = load { { float, float, float, float }**, i32 }*, { { float, float, float, float }**, i32 }** %color_structs2
  %i39 = load i32, i32* %i4
  %dataref40 = getelementptr { { float, float, float, float }**, i32 }, { { float, float, float, float }**, i32 }* %color_structs38, i32 0, i32 0
  %data41 = load { float, float, float, float }**, { float, float, float, float }*** %dataref40
  %elref42 = getelementptr { float, float, float, float }*, { float, float, float, float }** %data41, i32 %i39
  %el43 = load { float, float, float, float }*, { float, float, float, float }** %elref42
  %fieldadr44 = getelementptr { float, float, float, float }, { float, float, float, float }* %el43, i32 0, i32 1
  %g = load float, float* %fieldadr44
  store float %g, float* %cg
  %cb = alloca float
  %color_structs45 = load { { float, float, float, float }**, i32 }*, { { float, float, float, float }**, i32 }** %color_structs2
  %i46 = load i32, i32* %i4
  %dataref47 = getelementptr { { float, float, float, float }**, i32 }, { { float, float, float, float }**, i32 }* %color_structs45, i32 0, i32 0
  %data48 = load { float, float, float, float }**, { float, float, float, float }*** %dataref47
  %elref49 = getelementptr { float, float, float, float }*, { float, float, float, float }** %data48, i32 %i46
  %el50 = load { float, float, float, float }*, { float, float, float, float }** %elref49
  %fieldadr51 = getelementptr { float, float, float, float }, { float, float, float, float }* %el50, i32 0, i32 2
  %b = load float, float* %fieldadr51
  store float %b, float* %cb
  %ca = alloca float
  %color_structs52 = load { { float, float, float, float }**, i32 }*, { { float, float, float, float }**, i32 }** %color_structs2
  %i53 = load i32, i32* %i4
  %dataref54 = getelementptr { { float, float, float, float }**, i32 }, { { float, float, float, float }**, i32 }* %color_structs52, i32 0, i32 0
  %data55 = load { float, float, float, float }**, { float, float, float, float }*** %dataref54
  %elref56 = getelementptr { float, float, float, float }*, { float, float, float, float }** %data55, i32 %i53
  %el57 = load { float, float, float, float }*, { float, float, float, float }** %elref56
  %fieldadr58 = getelementptr { float, float, float, float }, { float, float, float, float }* %el57, i32 0, i32 3
  %a = load float, float* %fieldadr58
  store float %a, float* %ca
  %colors59 = load { float*, i32 }*, { float*, i32 }** %colors6
  %datarefref60 = getelementptr { float*, i32 }, { float*, i32 }* %colors59, i32 0, i32 0
  %dataref61 = load float*, float** %datarefref60
  %i62 = load i32, i32* %i4
  %tmp63 = mul i32 4, %i62
  %cr64 = load float, float* %cr
  %storeref65 = getelementptr float, float* %dataref61, i32 %tmp63
  store float %cr64, float* %storeref65
  %colors66 = load { float*, i32 }*, { float*, i32 }** %colors6
  %datarefref67 = getelementptr { float*, i32 }, { float*, i32 }* %colors66, i32 0, i32 0
  %dataref68 = load float*, float** %datarefref67
  %i69 = load i32, i32* %i4
  %tmp70 = mul i32 4, %i69
  %tmp71 = add i32 %tmp70, 1
  %cg72 = load float, float* %cg
  %storeref73 = getelementptr float, float* %dataref68, i32 %tmp71
  store float %cg72, float* %storeref73
  %colors74 = load { float*, i32 }*, { float*, i32 }** %colors6
  %datarefref75 = getelementptr { float*, i32 }, { float*, i32 }* %colors74, i32 0, i32 0
  %dataref76 = load float*, float** %datarefref75
  %i77 = load i32, i32* %i4
  %tmp78 = mul i32 4, %i77
  %tmp79 = add i32 %tmp78, 2
  %cb80 = load float, float* %cb
  %storeref81 = getelementptr float, float* %dataref76, i32 %tmp79
  store float %cb80, float* %storeref81
  %colors82 = load { float*, i32 }*, { float*, i32 }** %colors6
  %datarefref83 = getelementptr { float*, i32 }, { float*, i32 }* %colors82, i32 0, i32 0
  %dataref84 = load float*, float** %datarefref83
  %i85 = load i32, i32* %i4
  %tmp86 = mul i32 4, %i85
  %tmp87 = add i32 %tmp86, 3
  %ca88 = load float, float* %ca
  %storeref89 = getelementptr float, float* %dataref84, i32 %tmp87
  store float %ca88, float* %storeref89
  %point_structs90 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %point_structs1
  %color_structs91 = load { { float, float, float, float }**, i32 }*, { { float, float, float, float }**, i32 }** %color_structs2
  %numOfPoints92 = load i32, i32* %numOfPoints3
  %i93 = load i32, i32* %i4
  %tmp94 = add i32 %i93, 1
  %points95 = load { float*, i32 }*, { float*, i32 }** %points5
  %colors96 = load { float*, i32 }*, { float*, i32 }** %colors6
  call void @drawHelper({ { float, float }**, i32 }* %point_structs90, { { float, float, float, float }**, i32 }* %color_structs91, i32 %numOfPoints92, i32 %tmp94, { float*, i32 }* %points95, { float*, i32 }* %colors96)
  br label %merge
}

define void @drawPoints({ { float, float }**, i32 }* %point_structs, { { float, float, float, float }**, i32 }* %color_structs) {
entry:
  %point_structs1 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %point_structs, { { float, float }**, i32 }** %point_structs1
  %color_structs2 = alloca { { float, float, float, float }**, i32 }*
  store { { float, float, float, float }**, i32 }* %color_structs, { { float, float, float, float }**, i32 }** %color_structs2
  %numOfPoints = alloca i32
  %point_structs3 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %point_structs1
  %lenref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %point_structs3, i32 0, i32 1
  %len = load i32, i32* %lenref
  store i32 %len, i32* %numOfPoints
  %points = alloca { float*, i32 }*
  %numOfPoints4 = load i32, i32* %numOfPoints
  %tmp = mul i32 %numOfPoints4, 2
  %malloccall = tail call i8* @malloc(i32 ptrtoint (float* getelementptr (float, float* null, i32 1) to i32))
  %arrdata = bitcast i8* %malloccall to float*
  %storeref = getelementptr float, float* %arrdata, i32 0
  store float 0.000000e+00, float* %storeref
  %malloccall5 = tail call i8* @malloc(i32 ptrtoint ({ float*, i32 }* getelementptr ({ float*, i32 }, { float*, i32 }* null, i32 1) to i32))
  %arr = bitcast i8* %malloccall5 to { float*, i32 }*
  %arrdata6 = getelementptr { float*, i32 }, { float*, i32 }* %arr, i32 0, i32 0
  %arrlen = getelementptr { float*, i32 }, { float*, i32 }* %arr, i32 0, i32 1
  store float* %arrdata, float** %arrdata6
  store i32 1, i32* %arrlen
  %lenref7 = getelementptr { float*, i32 }, { float*, i32 }* %arr, i32 0, i32 1
  %len8 = load i32, i32* %lenref7
  %oflen = mul i32 %tmp, %len8
  %olddataref = getelementptr { float*, i32 }, { float*, i32 }* %arr, i32 0, i32 0
  %olddata = load float*, float** %olddataref
  %mallocsize = mul i32 %oflen, ptrtoint (float* getelementptr (float, float* null, i32 1) to i32)
  %malloccall9 = tail call i8* @malloc(i32 %mallocsize)
  %arrdata10 = bitcast i8* %malloccall9 to float*
  %i = alloca i32
  store i32 0, i32* %i
  %j = alloca i32
  store i32 0, i32* %j
  br label %inner

loop:                                             ; preds = %inner
  %i18 = load i32, i32* %i
  store i32 0, i32* %j
  %tmp19 = icmp slt i32 %i18, %oflen
  br i1 %tmp19, label %inner, label %continue

inner:                                            ; preds = %loop, %inner, %entry
  %i11 = load i32, i32* %j
  %i12 = load i32, i32* %i
  %elref = getelementptr float, float* %olddata, i32 %i11
  %el = load float, float* %elref
  %storeref13 = getelementptr float, float* %arrdata10, i32 %i12
  store float %el, float* %storeref13
  %i14 = add i32 %i12, 1
  store i32 %i14, i32* %i
  %j15 = add i32 %i11, 1
  store i32 %j15, i32* %j
  %j16 = load i32, i32* %j
  %tmp17 = icmp slt i32 %j16, %len8
  br i1 %tmp17, label %inner, label %loop

continue:                                         ; preds = %loop
  %malloccall20 = tail call i8* @malloc(i32 ptrtoint ({ float*, i32 }* getelementptr ({ float*, i32 }, { float*, i32 }* null, i32 1) to i32))
  %arr21 = bitcast i8* %malloccall20 to { float*, i32 }*
  %arrdata22 = getelementptr { float*, i32 }, { float*, i32 }* %arr21, i32 0, i32 0
  %arrlen23 = getelementptr { float*, i32 }, { float*, i32 }* %arr21, i32 0, i32 1
  store float* %arrdata10, float** %arrdata22
  store i32 %oflen, i32* %arrlen23
  store { float*, i32 }* %arr21, { float*, i32 }** %points
  %colors = alloca { float*, i32 }*
  %numOfPoints24 = load i32, i32* %numOfPoints
  %tmp25 = mul i32 %numOfPoints24, 4
  %malloccall26 = tail call i8* @malloc(i32 ptrtoint (float* getelementptr (float, float* null, i32 1) to i32))
  %arrdata27 = bitcast i8* %malloccall26 to float*
  %storeref28 = getelementptr float, float* %arrdata27, i32 0
  store float 0.000000e+00, float* %storeref28
  %malloccall29 = tail call i8* @malloc(i32 ptrtoint ({ float*, i32 }* getelementptr ({ float*, i32 }, { float*, i32 }* null, i32 1) to i32))
  %arr30 = bitcast i8* %malloccall29 to { float*, i32 }*
  %arrdata31 = getelementptr { float*, i32 }, { float*, i32 }* %arr30, i32 0, i32 0
  %arrlen32 = getelementptr { float*, i32 }, { float*, i32 }* %arr30, i32 0, i32 1
  store float* %arrdata27, float** %arrdata31
  store i32 1, i32* %arrlen32
  %lenref33 = getelementptr { float*, i32 }, { float*, i32 }* %arr30, i32 0, i32 1
  %len34 = load i32, i32* %lenref33
  %oflen35 = mul i32 %tmp25, %len34
  %olddataref36 = getelementptr { float*, i32 }, { float*, i32 }* %arr30, i32 0, i32 0
  %olddata37 = load float*, float** %olddataref36
  %mallocsize38 = mul i32 %oflen35, ptrtoint (float* getelementptr (float, float* null, i32 1) to i32)
  %malloccall39 = tail call i8* @malloc(i32 %mallocsize38)
  %arrdata40 = bitcast i8* %malloccall39 to float*
  %i41 = alloca i32
  store i32 0, i32* %i41
  %j42 = alloca i32
  store i32 0, i32* %j42
  br label %inner44

loop43:                                           ; preds = %inner44
  %i55 = load i32, i32* %i41
  store i32 0, i32* %j42
  %tmp56 = icmp slt i32 %i55, %oflen35
  br i1 %tmp56, label %inner44, label %continue45

inner44:                                          ; preds = %loop43, %inner44, %continue
  %i46 = load i32, i32* %j42
  %i47 = load i32, i32* %i41
  %elref48 = getelementptr float, float* %olddata37, i32 %i46
  %el49 = load float, float* %elref48
  %storeref50 = getelementptr float, float* %arrdata40, i32 %i47
  store float %el49, float* %storeref50
  %i51 = add i32 %i47, 1
  store i32 %i51, i32* %i41
  %j52 = add i32 %i46, 1
  store i32 %j52, i32* %j42
  %j53 = load i32, i32* %j42
  %tmp54 = icmp slt i32 %j53, %len34
  br i1 %tmp54, label %inner44, label %loop43

continue45:                                       ; preds = %loop43
  %malloccall57 = tail call i8* @malloc(i32 ptrtoint ({ float*, i32 }* getelementptr ({ float*, i32 }, { float*, i32 }* null, i32 1) to i32))
  %arr58 = bitcast i8* %malloccall57 to { float*, i32 }*
  %arrdata59 = getelementptr { float*, i32 }, { float*, i32 }* %arr58, i32 0, i32 0
  %arrlen60 = getelementptr { float*, i32 }, { float*, i32 }* %arr58, i32 0, i32 1
  store float* %arrdata40, float** %arrdata59
  store i32 %oflen35, i32* %arrlen60
  store { float*, i32 }* %arr58, { float*, i32 }** %colors
  %point_structs61 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %point_structs1
  %color_structs62 = load { { float, float, float, float }**, i32 }*, { { float, float, float, float }**, i32 }** %color_structs2
  %numOfPoints63 = load i32, i32* %numOfPoints
  %points64 = load { float*, i32 }*, { float*, i32 }** %points
  %colors65 = load { float*, i32 }*, { float*, i32 }** %colors
  call void @drawHelper({ { float, float }**, i32 }* %point_structs61, { { float, float, float, float }**, i32 }* %color_structs62, i32 %numOfPoints63, i32 0, { float*, i32 }* %points64, { float*, i32 }* %colors65)
  %points66 = load { float*, i32 }*, { float*, i32 }** %points
  %colors67 = load { float*, i32 }*, { float*, i32 }** %colors
  call void @gl_drawPoint({ float*, i32 }* %points66, { float*, i32 }* %colors67, i32 2)
  ret void
}

define void @drawPath({ { float, float }**, i32 }* %point_structs, { { float, float, float, float }**, i32 }* %color_structs, i32 %colorMode) {
entry:
  %point_structs1 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %point_structs, { { float, float }**, i32 }** %point_structs1
  %color_structs2 = alloca { { float, float, float, float }**, i32 }*
  store { { float, float, float, float }**, i32 }* %color_structs, { { float, float, float, float }**, i32 }** %color_structs2
  %colorMode3 = alloca i32
  store i32 %colorMode, i32* %colorMode3
  %numOfPoints = alloca i32
  %point_structs4 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %point_structs1
  %lenref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %point_structs4, i32 0, i32 1
  %len = load i32, i32* %lenref
  store i32 %len, i32* %numOfPoints
  %points = alloca { float*, i32 }*
  %numOfPoints5 = load i32, i32* %numOfPoints
  %tmp = mul i32 %numOfPoints5, 2
  %malloccall = tail call i8* @malloc(i32 ptrtoint (float* getelementptr (float, float* null, i32 1) to i32))
  %arrdata = bitcast i8* %malloccall to float*
  %storeref = getelementptr float, float* %arrdata, i32 0
  store float 0.000000e+00, float* %storeref
  %malloccall6 = tail call i8* @malloc(i32 ptrtoint ({ float*, i32 }* getelementptr ({ float*, i32 }, { float*, i32 }* null, i32 1) to i32))
  %arr = bitcast i8* %malloccall6 to { float*, i32 }*
  %arrdata7 = getelementptr { float*, i32 }, { float*, i32 }* %arr, i32 0, i32 0
  %arrlen = getelementptr { float*, i32 }, { float*, i32 }* %arr, i32 0, i32 1
  store float* %arrdata, float** %arrdata7
  store i32 1, i32* %arrlen
  %lenref8 = getelementptr { float*, i32 }, { float*, i32 }* %arr, i32 0, i32 1
  %len9 = load i32, i32* %lenref8
  %oflen = mul i32 %tmp, %len9
  %olddataref = getelementptr { float*, i32 }, { float*, i32 }* %arr, i32 0, i32 0
  %olddata = load float*, float** %olddataref
  %mallocsize = mul i32 %oflen, ptrtoint (float* getelementptr (float, float* null, i32 1) to i32)
  %malloccall10 = tail call i8* @malloc(i32 %mallocsize)
  %arrdata11 = bitcast i8* %malloccall10 to float*
  %i = alloca i32
  store i32 0, i32* %i
  %j = alloca i32
  store i32 0, i32* %j
  br label %inner

loop:                                             ; preds = %inner
  %i19 = load i32, i32* %i
  store i32 0, i32* %j
  %tmp20 = icmp slt i32 %i19, %oflen
  br i1 %tmp20, label %inner, label %continue

inner:                                            ; preds = %loop, %inner, %entry
  %i12 = load i32, i32* %j
  %i13 = load i32, i32* %i
  %elref = getelementptr float, float* %olddata, i32 %i12
  %el = load float, float* %elref
  %storeref14 = getelementptr float, float* %arrdata11, i32 %i13
  store float %el, float* %storeref14
  %i15 = add i32 %i13, 1
  store i32 %i15, i32* %i
  %j16 = add i32 %i12, 1
  store i32 %j16, i32* %j
  %j17 = load i32, i32* %j
  %tmp18 = icmp slt i32 %j17, %len9
  br i1 %tmp18, label %inner, label %loop

continue:                                         ; preds = %loop
  %malloccall21 = tail call i8* @malloc(i32 ptrtoint ({ float*, i32 }* getelementptr ({ float*, i32 }, { float*, i32 }* null, i32 1) to i32))
  %arr22 = bitcast i8* %malloccall21 to { float*, i32 }*
  %arrdata23 = getelementptr { float*, i32 }, { float*, i32 }* %arr22, i32 0, i32 0
  %arrlen24 = getelementptr { float*, i32 }, { float*, i32 }* %arr22, i32 0, i32 1
  store float* %arrdata11, float** %arrdata23
  store i32 %oflen, i32* %arrlen24
  store { float*, i32 }* %arr22, { float*, i32 }** %points
  %colors = alloca { float*, i32 }*
  %numOfPoints25 = load i32, i32* %numOfPoints
  %tmp26 = mul i32 %numOfPoints25, 4
  %malloccall27 = tail call i8* @malloc(i32 ptrtoint (float* getelementptr (float, float* null, i32 1) to i32))
  %arrdata28 = bitcast i8* %malloccall27 to float*
  %storeref29 = getelementptr float, float* %arrdata28, i32 0
  store float 0.000000e+00, float* %storeref29
  %malloccall30 = tail call i8* @malloc(i32 ptrtoint ({ float*, i32 }* getelementptr ({ float*, i32 }, { float*, i32 }* null, i32 1) to i32))
  %arr31 = bitcast i8* %malloccall30 to { float*, i32 }*
  %arrdata32 = getelementptr { float*, i32 }, { float*, i32 }* %arr31, i32 0, i32 0
  %arrlen33 = getelementptr { float*, i32 }, { float*, i32 }* %arr31, i32 0, i32 1
  store float* %arrdata28, float** %arrdata32
  store i32 1, i32* %arrlen33
  %lenref34 = getelementptr { float*, i32 }, { float*, i32 }* %arr31, i32 0, i32 1
  %len35 = load i32, i32* %lenref34
  %oflen36 = mul i32 %tmp26, %len35
  %olddataref37 = getelementptr { float*, i32 }, { float*, i32 }* %arr31, i32 0, i32 0
  %olddata38 = load float*, float** %olddataref37
  %mallocsize39 = mul i32 %oflen36, ptrtoint (float* getelementptr (float, float* null, i32 1) to i32)
  %malloccall40 = tail call i8* @malloc(i32 %mallocsize39)
  %arrdata41 = bitcast i8* %malloccall40 to float*
  %i42 = alloca i32
  store i32 0, i32* %i42
  %j43 = alloca i32
  store i32 0, i32* %j43
  br label %inner45

loop44:                                           ; preds = %inner45
  %i56 = load i32, i32* %i42
  store i32 0, i32* %j43
  %tmp57 = icmp slt i32 %i56, %oflen36
  br i1 %tmp57, label %inner45, label %continue46

inner45:                                          ; preds = %loop44, %inner45, %continue
  %i47 = load i32, i32* %j43
  %i48 = load i32, i32* %i42
  %elref49 = getelementptr float, float* %olddata38, i32 %i47
  %el50 = load float, float* %elref49
  %storeref51 = getelementptr float, float* %arrdata41, i32 %i48
  store float %el50, float* %storeref51
  %i52 = add i32 %i48, 1
  store i32 %i52, i32* %i42
  %j53 = add i32 %i47, 1
  store i32 %j53, i32* %j43
  %j54 = load i32, i32* %j43
  %tmp55 = icmp slt i32 %j54, %len35
  br i1 %tmp55, label %inner45, label %loop44

continue46:                                       ; preds = %loop44
  %malloccall58 = tail call i8* @malloc(i32 ptrtoint ({ float*, i32 }* getelementptr ({ float*, i32 }, { float*, i32 }* null, i32 1) to i32))
  %arr59 = bitcast i8* %malloccall58 to { float*, i32 }*
  %arrdata60 = getelementptr { float*, i32 }, { float*, i32 }* %arr59, i32 0, i32 0
  %arrlen61 = getelementptr { float*, i32 }, { float*, i32 }* %arr59, i32 0, i32 1
  store float* %arrdata41, float** %arrdata60
  store i32 %oflen36, i32* %arrlen61
  store { float*, i32 }* %arr59, { float*, i32 }** %colors
  %point_structs62 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %point_structs1
  %color_structs63 = load { { float, float, float, float }**, i32 }*, { { float, float, float, float }**, i32 }** %color_structs2
  %numOfPoints64 = load i32, i32* %numOfPoints
  %points65 = load { float*, i32 }*, { float*, i32 }** %points
  %colors66 = load { float*, i32 }*, { float*, i32 }** %colors
  call void @drawHelper({ { float, float }**, i32 }* %point_structs62, { { float, float, float, float }**, i32 }* %color_structs63, i32 %numOfPoints64, i32 0, { float*, i32 }* %points65, { float*, i32 }* %colors66)
  %points67 = load { float*, i32 }*, { float*, i32 }** %points
  %colors68 = load { float*, i32 }*, { float*, i32 }** %colors
  %colorMode69 = load i32, i32* %colorMode3
  call void @gl_drawCurve({ float*, i32 }* %points67, { float*, i32 }* %colors68, i32 %colorMode69)
  ret void
}

define void @drawShape({ { float, float }**, i32 }* %point_structs, { { float, float, float, float }**, i32 }* %color_structs, i32 %colorMode, i32 %filled) {
entry:
  %point_structs1 = alloca { { float, float }**, i32 }*
  store { { float, float }**, i32 }* %point_structs, { { float, float }**, i32 }** %point_structs1
  %color_structs2 = alloca { { float, float, float, float }**, i32 }*
  store { { float, float, float, float }**, i32 }* %color_structs, { { float, float, float, float }**, i32 }** %color_structs2
  %colorMode3 = alloca i32
  store i32 %colorMode, i32* %colorMode3
  %filled4 = alloca i32
  store i32 %filled, i32* %filled4
  %numOfPoints = alloca i32
  %point_structs5 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %point_structs1
  %lenref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %point_structs5, i32 0, i32 1
  %len = load i32, i32* %lenref
  store i32 %len, i32* %numOfPoints
  %points = alloca { float*, i32 }*
  %numOfPoints6 = load i32, i32* %numOfPoints
  %tmp = mul i32 %numOfPoints6, 2
  %malloccall = tail call i8* @malloc(i32 ptrtoint (float* getelementptr (float, float* null, i32 1) to i32))
  %arrdata = bitcast i8* %malloccall to float*
  %storeref = getelementptr float, float* %arrdata, i32 0
  store float 0.000000e+00, float* %storeref
  %malloccall7 = tail call i8* @malloc(i32 ptrtoint ({ float*, i32 }* getelementptr ({ float*, i32 }, { float*, i32 }* null, i32 1) to i32))
  %arr = bitcast i8* %malloccall7 to { float*, i32 }*
  %arrdata8 = getelementptr { float*, i32 }, { float*, i32 }* %arr, i32 0, i32 0
  %arrlen = getelementptr { float*, i32 }, { float*, i32 }* %arr, i32 0, i32 1
  store float* %arrdata, float** %arrdata8
  store i32 1, i32* %arrlen
  %lenref9 = getelementptr { float*, i32 }, { float*, i32 }* %arr, i32 0, i32 1
  %len10 = load i32, i32* %lenref9
  %oflen = mul i32 %tmp, %len10
  %olddataref = getelementptr { float*, i32 }, { float*, i32 }* %arr, i32 0, i32 0
  %olddata = load float*, float** %olddataref
  %mallocsize = mul i32 %oflen, ptrtoint (float* getelementptr (float, float* null, i32 1) to i32)
  %malloccall11 = tail call i8* @malloc(i32 %mallocsize)
  %arrdata12 = bitcast i8* %malloccall11 to float*
  %i = alloca i32
  store i32 0, i32* %i
  %j = alloca i32
  store i32 0, i32* %j
  br label %inner

loop:                                             ; preds = %inner
  %i20 = load i32, i32* %i
  store i32 0, i32* %j
  %tmp21 = icmp slt i32 %i20, %oflen
  br i1 %tmp21, label %inner, label %continue

inner:                                            ; preds = %loop, %inner, %entry
  %i13 = load i32, i32* %j
  %i14 = load i32, i32* %i
  %elref = getelementptr float, float* %olddata, i32 %i13
  %el = load float, float* %elref
  %storeref15 = getelementptr float, float* %arrdata12, i32 %i14
  store float %el, float* %storeref15
  %i16 = add i32 %i14, 1
  store i32 %i16, i32* %i
  %j17 = add i32 %i13, 1
  store i32 %j17, i32* %j
  %j18 = load i32, i32* %j
  %tmp19 = icmp slt i32 %j18, %len10
  br i1 %tmp19, label %inner, label %loop

continue:                                         ; preds = %loop
  %malloccall22 = tail call i8* @malloc(i32 ptrtoint ({ float*, i32 }* getelementptr ({ float*, i32 }, { float*, i32 }* null, i32 1) to i32))
  %arr23 = bitcast i8* %malloccall22 to { float*, i32 }*
  %arrdata24 = getelementptr { float*, i32 }, { float*, i32 }* %arr23, i32 0, i32 0
  %arrlen25 = getelementptr { float*, i32 }, { float*, i32 }* %arr23, i32 0, i32 1
  store float* %arrdata12, float** %arrdata24
  store i32 %oflen, i32* %arrlen25
  store { float*, i32 }* %arr23, { float*, i32 }** %points
  %colors = alloca { float*, i32 }*
  %numOfPoints26 = load i32, i32* %numOfPoints
  %tmp27 = mul i32 %numOfPoints26, 4
  %malloccall28 = tail call i8* @malloc(i32 ptrtoint (float* getelementptr (float, float* null, i32 1) to i32))
  %arrdata29 = bitcast i8* %malloccall28 to float*
  %storeref30 = getelementptr float, float* %arrdata29, i32 0
  store float 0.000000e+00, float* %storeref30
  %malloccall31 = tail call i8* @malloc(i32 ptrtoint ({ float*, i32 }* getelementptr ({ float*, i32 }, { float*, i32 }* null, i32 1) to i32))
  %arr32 = bitcast i8* %malloccall31 to { float*, i32 }*
  %arrdata33 = getelementptr { float*, i32 }, { float*, i32 }* %arr32, i32 0, i32 0
  %arrlen34 = getelementptr { float*, i32 }, { float*, i32 }* %arr32, i32 0, i32 1
  store float* %arrdata29, float** %arrdata33
  store i32 1, i32* %arrlen34
  %lenref35 = getelementptr { float*, i32 }, { float*, i32 }* %arr32, i32 0, i32 1
  %len36 = load i32, i32* %lenref35
  %oflen37 = mul i32 %tmp27, %len36
  %olddataref38 = getelementptr { float*, i32 }, { float*, i32 }* %arr32, i32 0, i32 0
  %olddata39 = load float*, float** %olddataref38
  %mallocsize40 = mul i32 %oflen37, ptrtoint (float* getelementptr (float, float* null, i32 1) to i32)
  %malloccall41 = tail call i8* @malloc(i32 %mallocsize40)
  %arrdata42 = bitcast i8* %malloccall41 to float*
  %i43 = alloca i32
  store i32 0, i32* %i43
  %j44 = alloca i32
  store i32 0, i32* %j44
  br label %inner46

loop45:                                           ; preds = %inner46
  %i57 = load i32, i32* %i43
  store i32 0, i32* %j44
  %tmp58 = icmp slt i32 %i57, %oflen37
  br i1 %tmp58, label %inner46, label %continue47

inner46:                                          ; preds = %loop45, %inner46, %continue
  %i48 = load i32, i32* %j44
  %i49 = load i32, i32* %i43
  %elref50 = getelementptr float, float* %olddata39, i32 %i48
  %el51 = load float, float* %elref50
  %storeref52 = getelementptr float, float* %arrdata42, i32 %i49
  store float %el51, float* %storeref52
  %i53 = add i32 %i49, 1
  store i32 %i53, i32* %i43
  %j54 = add i32 %i48, 1
  store i32 %j54, i32* %j44
  %j55 = load i32, i32* %j44
  %tmp56 = icmp slt i32 %j55, %len36
  br i1 %tmp56, label %inner46, label %loop45

continue47:                                       ; preds = %loop45
  %malloccall59 = tail call i8* @malloc(i32 ptrtoint ({ float*, i32 }* getelementptr ({ float*, i32 }, { float*, i32 }* null, i32 1) to i32))
  %arr60 = bitcast i8* %malloccall59 to { float*, i32 }*
  %arrdata61 = getelementptr { float*, i32 }, { float*, i32 }* %arr60, i32 0, i32 0
  %arrlen62 = getelementptr { float*, i32 }, { float*, i32 }* %arr60, i32 0, i32 1
  store float* %arrdata42, float** %arrdata61
  store i32 %oflen37, i32* %arrlen62
  store { float*, i32 }* %arr60, { float*, i32 }** %colors
  %point_structs63 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %point_structs1
  %color_structs64 = load { { float, float, float, float }**, i32 }*, { { float, float, float, float }**, i32 }** %color_structs2
  %numOfPoints65 = load i32, i32* %numOfPoints
  %points66 = load { float*, i32 }*, { float*, i32 }** %points
  %colors67 = load { float*, i32 }*, { float*, i32 }** %colors
  call void @drawHelper({ { float, float }**, i32 }* %point_structs63, { { float, float, float, float }**, i32 }* %color_structs64, i32 %numOfPoints65, i32 0, { float*, i32 }* %points66, { float*, i32 }* %colors67)
  %points68 = load { float*, i32 }*, { float*, i32 }** %points
  %colors69 = load { float*, i32 }*, { float*, i32 }** %colors
  %colorMode70 = load i32, i32* %colorMode3
  %filled71 = load i32, i32* %filled4
  call void @gl_drawShape({ float*, i32 }* %points68, { float*, i32 }* %colors69, i32 %colorMode70, i32 %filled71)
  ret void
}

define void @endCanvas({ i32, i32, i32 }* %c) {
entry:
  %c1 = alloca { i32, i32, i32 }*
  store { i32, i32, i32 }* %c, { i32, i32, i32 }** %c1
  %c2 = load { i32, i32, i32 }*, { i32, i32, i32 }** %c1
  %fieldadr = getelementptr { i32, i32, i32 }, { i32, i32, i32 }* %c2, i32 0, i32 0
  %width = load i32, i32* %fieldadr
  %c3 = load { i32, i32, i32 }*, { i32, i32, i32 }** %c1
  %fieldadr4 = getelementptr { i32, i32, i32 }, { i32, i32, i32 }* %c3, i32 0, i32 1
  %height = load i32, i32* %fieldadr4
  %c5 = load { i32, i32, i32 }*, { i32, i32, i32 }** %c1
  %fieldadr6 = getelementptr { i32, i32, i32 }, { i32, i32, i32 }* %c5, i32 0, i32 2
  %file_number = load i32, i32* %fieldadr6
  call void @gl_endRendering(i32 %width, i32 %height, i32 %file_number)
  ret void
}

define void @rotate({ float, float }* %p, float %angle, i32 %direction, { float, float }* %about) {
entry:
  %p1 = alloca { float, float }*
  store { float, float }* %p, { float, float }** %p1
  %angle2 = alloca float
  store float %angle, float* %angle2
  %direction3 = alloca i32
  store i32 %direction, i32* %direction3
  %about4 = alloca { float, float }*
  store { float, float }* %about, { float, float }** %about4
  %px = alloca float
  %p5 = load { float, float }*, { float, float }** %p1
  %fieldadr = getelementptr { float, float }, { float, float }* %p5, i32 0, i32 0
  %x = load float, float* %fieldadr
  %about6 = load { float, float }*, { float, float }** %about4
  %fieldadr7 = getelementptr { float, float }, { float, float }* %about6, i32 0, i32 0
  %x8 = load float, float* %fieldadr7
  %tmp = fsub float %x, %x8
  store float %tmp, float* %px
  %py = alloca float
  %p9 = load { float, float }*, { float, float }** %p1
  %fieldadr10 = getelementptr { float, float }, { float, float }* %p9, i32 0, i32 1
  %y = load float, float* %fieldadr10
  %about11 = load { float, float }*, { float, float }** %about4
  %fieldadr12 = getelementptr { float, float }, { float, float }* %about11, i32 0, i32 1
  %y13 = load float, float* %fieldadr12
  %tmp14 = fsub float %y, %y13
  store float %tmp14, float* %py
  %direction15 = load i32, i32* %direction3
  %tmp16 = icmp eq i32 %direction15, -1
  %if_tmp = alloca float
  br i1 %tmp16, label %then, label %else

merge:                                            ; preds = %merge48, %then
  %if_tmp93 = load float, float* %if_tmp
  ret void

then:                                             ; preds = %entry
  %p17 = load { float, float }*, { float, float }** %p1
  %px18 = load float, float* %px
  %angle19 = load float, float* %angle2
  %fxn_result = call float @cos(float %angle19)
  %tmp20 = fmul float %px18, %fxn_result
  %py21 = load float, float* %py
  %angle22 = load float, float* %angle2
  %fxn_result23 = call float @sin(float %angle22)
  %tmp24 = fmul float %py21, %fxn_result23
  %tmp25 = fsub float %tmp20, %tmp24
  %about26 = load { float, float }*, { float, float }** %about4
  %fieldadr27 = getelementptr { float, float }, { float, float }* %about26, i32 0, i32 0
  %x28 = load float, float* %fieldadr27
  %tmp29 = fadd float %tmp25, %x28
  %ref = getelementptr { float, float }, { float, float }* %p17, i32 0, i32 0
  store float %tmp29, float* %ref
  %p30 = load { float, float }*, { float, float }** %p1
  %px31 = load float, float* %px
  %angle32 = load float, float* %angle2
  %fxn_result33 = call float @sin(float %angle32)
  %tmp34 = fmul float %px31, %fxn_result33
  %py35 = load float, float* %py
  %angle36 = load float, float* %angle2
  %fxn_result37 = call float @cos(float %angle36)
  %tmp38 = fmul float %py35, %fxn_result37
  %tmp39 = fadd float %tmp34, %tmp38
  %about40 = load { float, float }*, { float, float }** %about4
  %fieldadr41 = getelementptr { float, float }, { float, float }* %about40, i32 0, i32 1
  %y42 = load float, float* %fieldadr41
  %tmp43 = fadd float %tmp39, %y42
  %ref44 = getelementptr { float, float }, { float, float }* %p30, i32 0, i32 1
  store float %tmp43, float* %ref44
  store float %tmp43, float* %if_tmp
  br label %merge

else:                                             ; preds = %entry
  %direction45 = load i32, i32* %direction3
  %tmp46 = icmp eq i32 %direction45, 1
  %if_tmp47 = alloca float
  br i1 %tmp46, label %then49, label %else50

merge48:                                          ; preds = %else50, %then49
  %if_tmp92 = load float, float* %if_tmp47
  store float %if_tmp92, float* %if_tmp
  br label %merge

then49:                                           ; preds = %else
  %p51 = load { float, float }*, { float, float }** %p1
  %px52 = load float, float* %px
  %angle53 = load float, float* %angle2
  %fxn_result54 = call float @cos(float %angle53)
  %tmp55 = fmul float %px52, %fxn_result54
  %py56 = load float, float* %py
  %angle57 = load float, float* %angle2
  %fxn_result58 = call float @sin(float %angle57)
  %tmp59 = fmul float %py56, %fxn_result58
  %tmp60 = fadd float %tmp55, %tmp59
  %about61 = load { float, float }*, { float, float }** %about4
  %fieldadr62 = getelementptr { float, float }, { float, float }* %about61, i32 0, i32 0
  %x63 = load float, float* %fieldadr62
  %tmp64 = fadd float %tmp60, %x63
  %ref65 = getelementptr { float, float }, { float, float }* %p51, i32 0, i32 0
  store float %tmp64, float* %ref65
  %p66 = load { float, float }*, { float, float }** %p1
  %px67 = load float, float* %px
  %angle68 = load float, float* %angle2
  %fxn_result69 = call float @sin(float %angle68)
  %tmp70 = fmul float %px67, %fxn_result69
  %tmp71 = fneg float %tmp70
  %py72 = load float, float* %py
  %angle73 = load float, float* %angle2
  %fxn_result74 = call float @cos(float %angle73)
  %tmp75 = fmul float %py72, %fxn_result74
  %tmp76 = fadd float %tmp71, %tmp75
  %about77 = load { float, float }*, { float, float }** %about4
  %fieldadr78 = getelementptr { float, float }, { float, float }* %about77, i32 0, i32 1
  %y79 = load float, float* %fieldadr78
  %tmp80 = fadd float %tmp76, %y79
  %ref81 = getelementptr { float, float }, { float, float }* %p66, i32 0, i32 1
  store float %tmp80, float* %ref81
  store float %tmp80, float* %if_tmp47
  br label %merge48

else50:                                           ; preds = %else
  %p82 = load { float, float }*, { float, float }** %p1
  %p83 = load { float, float }*, { float, float }** %p1
  %fieldadr84 = getelementptr { float, float }, { float, float }* %p83, i32 0, i32 0
  %x85 = load float, float* %fieldadr84
  %ref86 = getelementptr { float, float }, { float, float }* %p82, i32 0, i32 0
  store float %x85, float* %ref86
  %p87 = load { float, float }*, { float, float }** %p1
  %p88 = load { float, float }*, { float, float }** %p1
  %fieldadr89 = getelementptr { float, float }, { float, float }* %p88, i32 0, i32 1
  %y90 = load float, float* %fieldadr89
  %ref91 = getelementptr { float, float }, { float, float }* %p87, i32 0, i32 1
  store float %y90, float* %ref91
  store float %y90, float* %if_tmp47
  br label %merge48
}

define void @trans({ float, float }* %p, { float, float }* %direction) {
entry:
  %p1 = alloca { float, float }*
  store { float, float }* %p, { float, float }** %p1
  %direction2 = alloca { float, float }*
  store { float, float }* %direction, { float, float }** %direction2
  %p3 = load { float, float }*, { float, float }** %p1
  %p4 = load { float, float }*, { float, float }** %p1
  %fieldadr = getelementptr { float, float }, { float, float }* %p4, i32 0, i32 0
  %x = load float, float* %fieldadr
  %direction5 = load { float, float }*, { float, float }** %direction2
  %fieldadr6 = getelementptr { float, float }, { float, float }* %direction5, i32 0, i32 0
  %x7 = load float, float* %fieldadr6
  %tmp = fadd float %x, %x7
  %ref = getelementptr { float, float }, { float, float }* %p3, i32 0, i32 0
  store float %tmp, float* %ref
  %p8 = load { float, float }*, { float, float }** %p1
  %p9 = load { float, float }*, { float, float }** %p1
  %fieldadr10 = getelementptr { float, float }, { float, float }* %p9, i32 0, i32 1
  %y = load float, float* %fieldadr10
  %direction11 = load { float, float }*, { float, float }** %direction2
  %fieldadr12 = getelementptr { float, float }, { float, float }* %direction11, i32 0, i32 1
  %y13 = load float, float* %fieldadr12
  %tmp14 = fadd float %y, %y13
  %ref15 = getelementptr { float, float }, { float, float }* %p8, i32 0, i32 1
  store float %tmp14, float* %ref15
  ret void
}

define void @scale({ float, float }* %p, float %sx, float %sy) {
entry:
  %p1 = alloca { float, float }*
  store { float, float }* %p, { float, float }** %p1
  %sx2 = alloca float
  store float %sx, float* %sx2
  %sy3 = alloca float
  store float %sy, float* %sy3
  %p4 = load { float, float }*, { float, float }** %p1
  %p5 = load { float, float }*, { float, float }** %p1
  %fieldadr = getelementptr { float, float }, { float, float }* %p5, i32 0, i32 0
  %x = load float, float* %fieldadr
  %sx6 = load float, float* %sx2
  %tmp = fmul float %x, %sx6
  %ref = getelementptr { float, float }, { float, float }* %p4, i32 0, i32 0
  store float %tmp, float* %ref
  %p7 = load { float, float }*, { float, float }** %p1
  %p8 = load { float, float }*, { float, float }** %p1
  %fieldadr9 = getelementptr { float, float }, { float, float }* %p8, i32 0, i32 1
  %y = load float, float* %fieldadr9
  %sy10 = load float, float* %sy3
  %tmp11 = fmul float %y, %sy10
  %ref12 = getelementptr { float, float }, { float, float }* %p7, i32 0, i32 1
  store float %tmp11, float* %ref12
  ret void
}

define { float, float }* @rotated({ float, float }* %p, float %angle, i32 %direction, { float, float }* %about) {
entry:
  %p1 = alloca { float, float }*
  store { float, float }* %p, { float, float }** %p1
  %angle2 = alloca float
  store float %angle, float* %angle2
  %direction3 = alloca i32
  store i32 %direction, i32* %direction3
  %about4 = alloca { float, float }*
  store { float, float }* %about, { float, float }** %about4
  %q = alloca { float, float }*
  %p5 = load { float, float }*, { float, float }** %p1
  %copied = call { float, float }* @__copy2.2({ float, float }* %p5)
  store { float, float }* %copied, { float, float }** %q
  %q6 = load { float, float }*, { float, float }** %q
  %angle7 = load float, float* %angle2
  %direction8 = load i32, i32* %direction3
  %about9 = load { float, float }*, { float, float }** %about4
  call void @rotate({ float, float }* %q6, float %angle7, i32 %direction8, { float, float }* %about9)
  %q10 = load { float, float }*, { float, float }** %q
  ret { float, float }* %q10
}

define { float, float }* @__copy2.2({ float, float }* %to_copy) {
entry:
  %to_copy1 = alloca { float, float }*
  store { float, float }* %to_copy, { float, float }** %to_copy1
  %to_copy2 = load { float, float }*, { float, float }** %to_copy1
  %malloccall = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2) to i32))
  %struct = bitcast i8* %malloccall to { float, float }*
  %flref = getelementptr { float, float }, { float, float }* %to_copy2, i32 0, i32 0
  %fl = load float, float* %flref
  %ref = getelementptr { float, float }, { float, float }* %struct, i32 0, i32 0
  store float %fl, float* %ref
  %flref3 = getelementptr { float, float }, { float, float }* %to_copy2, i32 0, i32 1
  %fl4 = load float, float* %flref3
  %ref5 = getelementptr { float, float }, { float, float }* %struct, i32 0, i32 1
  store float %fl4, float* %ref5
  ret { float, float }* %struct
}

define { float, float }* @translated({ float, float }* %p, { float, float }* %direction) {
entry:
  %p1 = alloca { float, float }*
  store { float, float }* %p, { float, float }** %p1
  %direction2 = alloca { float, float }*
  store { float, float }* %direction, { float, float }** %direction2
  %q = alloca { float, float }*
  %p3 = load { float, float }*, { float, float }** %p1
  %copied = call { float, float }* @__copy2.3({ float, float }* %p3)
  store { float, float }* %copied, { float, float }** %q
  %q4 = load { float, float }*, { float, float }** %q
  %direction5 = load { float, float }*, { float, float }** %direction2
  call void @trans({ float, float }* %q4, { float, float }* %direction5)
  %q6 = load { float, float }*, { float, float }** %q
  ret { float, float }* %q6
}

define { float, float }* @__copy2.3({ float, float }* %to_copy) {
entry:
  %to_copy1 = alloca { float, float }*
  store { float, float }* %to_copy, { float, float }** %to_copy1
  %to_copy2 = load { float, float }*, { float, float }** %to_copy1
  %malloccall = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2) to i32))
  %struct = bitcast i8* %malloccall to { float, float }*
  %flref = getelementptr { float, float }, { float, float }* %to_copy2, i32 0, i32 0
  %fl = load float, float* %flref
  %ref = getelementptr { float, float }, { float, float }* %struct, i32 0, i32 0
  store float %fl, float* %ref
  %flref3 = getelementptr { float, float }, { float, float }* %to_copy2, i32 0, i32 1
  %fl4 = load float, float* %flref3
  %ref5 = getelementptr { float, float }, { float, float }* %struct, i32 0, i32 1
  store float %fl4, float* %ref5
  ret { float, float }* %struct
}

define { float, float }* @scaled({ float, float }* %p, float %sx, float %sy) {
entry:
  %p1 = alloca { float, float }*
  store { float, float }* %p, { float, float }** %p1
  %sx2 = alloca float
  store float %sx, float* %sx2
  %sy3 = alloca float
  store float %sy, float* %sy3
  %q = alloca { float, float }*
  %p4 = load { float, float }*, { float, float }** %p1
  %copied = call { float, float }* @__copy2.4({ float, float }* %p4)
  store { float, float }* %copied, { float, float }** %q
  %p5 = load { float, float }*, { float, float }** %p1
  %sx6 = load float, float* %sx2
  %sy7 = load float, float* %sy3
  call void @scale({ float, float }* %p5, float %sx6, float %sy7)
  %q8 = load { float, float }*, { float, float }** %q
  ret { float, float }* %q8
}

define { float, float }* @__copy2.4({ float, float }* %to_copy) {
entry:
  %to_copy1 = alloca { float, float }*
  store { float, float }* %to_copy, { float, float }** %to_copy1
  %to_copy2 = load { float, float }*, { float, float }** %to_copy1
  %malloccall = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2) to i32))
  %struct = bitcast i8* %malloccall to { float, float }*
  %flref = getelementptr { float, float }, { float, float }* %to_copy2, i32 0, i32 0
  %fl = load float, float* %flref
  %ref = getelementptr { float, float }, { float, float }* %struct, i32 0, i32 0
  store float %fl, float* %ref
  %flref3 = getelementptr { float, float }, { float, float }* %to_copy2, i32 0, i32 1
  %fl4 = load float, float* %flref3
  %ref5 = getelementptr { float, float }, { float, float }* %struct, i32 0, i32 1
  store float %fl4, float* %ref5
  ret { float, float }* %struct
}

define void @fill_ints({ i32*, i32 }* %a, i32 %i) {
entry:
  %a1 = alloca { i32*, i32 }*
  store { i32*, i32 }* %a, { i32*, i32 }** %a1
  %i2 = alloca i32
  store i32 %i, i32* %i2
  %i3 = load i32, i32* %i2
  %a4 = load { i32*, i32 }*, { i32*, i32 }** %a1
  %lenref = getelementptr { i32*, i32 }, { i32*, i32 }* %a4, i32 0, i32 1
  %len = load i32, i32* %lenref
  %tmp = icmp slt i32 %i3, %len
  br i1 %tmp, label %then, label %else

merge:                                            ; preds = %else, %then
  ret void

then:                                             ; preds = %entry
  %a5 = load { i32*, i32 }*, { i32*, i32 }** %a1
  %datarefref = getelementptr { i32*, i32 }, { i32*, i32 }* %a5, i32 0, i32 0
  %dataref = load i32*, i32** %datarefref
  %i6 = load i32, i32* %i2
  %i7 = load i32, i32* %i2
  %storeref = getelementptr i32, i32* %dataref, i32 %i6
  store i32 %i7, i32* %storeref
  %a8 = load { i32*, i32 }*, { i32*, i32 }** %a1
  %i9 = load i32, i32* %i2
  %tmp10 = add i32 %i9, 1
  call void @fill_ints({ i32*, i32 }* %a8, i32 %tmp10)
  br label %merge

else:                                             ; preds = %entry
  br label %merge
}

define { i32*, i32 }* @ints(i32 %n) {
entry:
  %n1 = alloca i32
  store i32 %n, i32* %n1
  %n2 = load i32, i32* %n1
  %tmp = icmp sle i32 %n2, 0
  %if_tmp = alloca { i32*, i32 }*
  br i1 %tmp, label %then, label %else

merge:                                            ; preds = %continue, %then
  %if_tmp30 = load { i32*, i32 }*, { i32*, i32 }** %if_tmp
  ret { i32*, i32 }* %if_tmp30

then:                                             ; preds = %entry
  %a = alloca { i32*, i32 }*
  %malloccall = tail call i8* @malloc(i32 0)
  %arrdata = bitcast i8* %malloccall to i32*
  %malloccall3 = tail call i8* @malloc(i32 ptrtoint ({ i32*, i32 }* getelementptr ({ i32*, i32 }, { i32*, i32 }* null, i32 1) to i32))
  %arr = bitcast i8* %malloccall3 to { i32*, i32 }*
  %arrdata4 = getelementptr { i32*, i32 }, { i32*, i32 }* %arr, i32 0, i32 0
  %arrlen = getelementptr { i32*, i32 }, { i32*, i32 }* %arr, i32 0, i32 1
  store i32* %arrdata, i32** %arrdata4
  store i32 0, i32* %arrlen
  store { i32*, i32 }* %arr, { i32*, i32 }** %a
  store { i32*, i32 }* %arr, { i32*, i32 }** %if_tmp
  br label %merge

else:                                             ; preds = %entry
  %arr5 = alloca { i32*, i32 }*
  %n6 = load i32, i32* %n1
  %malloccall7 = tail call i8* @malloc(i32 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i32))
  %arrdata8 = bitcast i8* %malloccall7 to i32*
  %storeref = getelementptr i32, i32* %arrdata8, i32 0
  store i32 0, i32* %storeref
  %malloccall9 = tail call i8* @malloc(i32 ptrtoint ({ i32*, i32 }* getelementptr ({ i32*, i32 }, { i32*, i32 }* null, i32 1) to i32))
  %arr10 = bitcast i8* %malloccall9 to { i32*, i32 }*
  %arrdata11 = getelementptr { i32*, i32 }, { i32*, i32 }* %arr10, i32 0, i32 0
  %arrlen12 = getelementptr { i32*, i32 }, { i32*, i32 }* %arr10, i32 0, i32 1
  store i32* %arrdata8, i32** %arrdata11
  store i32 1, i32* %arrlen12
  %lenref = getelementptr { i32*, i32 }, { i32*, i32 }* %arr10, i32 0, i32 1
  %len = load i32, i32* %lenref
  %oflen = mul i32 %n6, %len
  %olddataref = getelementptr { i32*, i32 }, { i32*, i32 }* %arr10, i32 0, i32 0
  %olddata = load i32*, i32** %olddataref
  %mallocsize = mul i32 %oflen, ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i32)
  %malloccall13 = tail call i8* @malloc(i32 %mallocsize)
  %arrdata14 = bitcast i8* %malloccall13 to i32*
  %i = alloca i32
  store i32 0, i32* %i
  %j = alloca i32
  store i32 0, i32* %j
  br label %inner

loop:                                             ; preds = %inner
  %i22 = load i32, i32* %i
  store i32 0, i32* %j
  %tmp23 = icmp slt i32 %i22, %oflen
  br i1 %tmp23, label %inner, label %continue

inner:                                            ; preds = %loop, %inner, %else
  %i15 = load i32, i32* %j
  %i16 = load i32, i32* %i
  %elref = getelementptr i32, i32* %olddata, i32 %i15
  %el = load i32, i32* %elref
  %storeref17 = getelementptr i32, i32* %arrdata14, i32 %i16
  store i32 %el, i32* %storeref17
  %i18 = add i32 %i16, 1
  store i32 %i18, i32* %i
  %j19 = add i32 %i15, 1
  store i32 %j19, i32* %j
  %j20 = load i32, i32* %j
  %tmp21 = icmp slt i32 %j20, %len
  br i1 %tmp21, label %inner, label %loop

continue:                                         ; preds = %loop
  %malloccall24 = tail call i8* @malloc(i32 ptrtoint ({ i32*, i32 }* getelementptr ({ i32*, i32 }, { i32*, i32 }* null, i32 1) to i32))
  %arr25 = bitcast i8* %malloccall24 to { i32*, i32 }*
  %arrdata26 = getelementptr { i32*, i32 }, { i32*, i32 }* %arr25, i32 0, i32 0
  %arrlen27 = getelementptr { i32*, i32 }, { i32*, i32 }* %arr25, i32 0, i32 1
  store i32* %arrdata14, i32** %arrdata26
  store i32 %oflen, i32* %arrlen27
  store { i32*, i32 }* %arr25, { i32*, i32 }** %arr5
  %arr28 = load { i32*, i32 }*, { i32*, i32 }** %arr5
  call void @fill_ints({ i32*, i32 }* %arr28, i32 0)
  %arr29 = load { i32*, i32 }*, { i32*, i32 }** %arr5
  store { i32*, i32 }* %arr29, { i32*, i32 }** %if_tmp
  br label %merge
}

define { { float, float }**, i32 }* @dragon(i32 %n) {
entry:
  %n1 = alloca i32
  store i32 %n, i32* %n1
  %n2 = load i32, i32* %n1
  %tmp = icmp eq i32 %n2, 0
  %if_tmp = alloca { { float, float }**, i32 }*
  br i1 %tmp, label %then, label %else

merge:                                            ; preds = %continue89, %then
  %if_tmp103 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %if_tmp
  ret { { float, float }**, i32 }* %if_tmp103

then:                                             ; preds = %entry
  %malloccall = tail call i8* @malloc(i32 mul (i32 ptrtoint (i1** getelementptr (i1*, i1** null, i32 1) to i32), i32 2))
  %arrdata = bitcast i8* %malloccall to { float, float }**
  %malloccall3 = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2) to i32))
  %point = bitcast i8* %malloccall3 to { float, float }*
  %fieldaddr = getelementptr { float, float }, { float, float }* %point, i32 0, i32 0
  store float 0.000000e+00, float* %fieldaddr
  %fieldaddr4 = getelementptr { float, float }, { float, float }* %point, i32 0, i32 1
  store float 0.000000e+00, float* %fieldaddr4
  %storeref = getelementptr { float, float }*, { float, float }** %arrdata, i32 0
  store { float, float }* %point, { float, float }** %storeref
  %malloccall5 = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2) to i32))
  %point6 = bitcast i8* %malloccall5 to { float, float }*
  %fieldaddr7 = getelementptr { float, float }, { float, float }* %point6, i32 0, i32 0
  store float 1.000000e+00, float* %fieldaddr7
  %fieldaddr8 = getelementptr { float, float }, { float, float }* %point6, i32 0, i32 1
  store float 0.000000e+00, float* %fieldaddr8
  %storeref9 = getelementptr { float, float }*, { float, float }** %arrdata, i32 1
  store { float, float }* %point6, { float, float }** %storeref9
  %malloccall10 = tail call i8* @malloc(i32 ptrtoint ({ { float, float }**, i32 }* getelementptr ({ { float, float }**, i32 }, { { float, float }**, i32 }* null, i32 1) to i32))
  %arr = bitcast i8* %malloccall10 to { { float, float }**, i32 }*
  %arrdata11 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 0
  %arrlen = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %arr, i32 0, i32 1
  store { float, float }** %arrdata, { float, float }*** %arrdata11
  store i32 2, i32* %arrlen
  store { { float, float }**, i32 }* %arr, { { float, float }**, i32 }** %if_tmp
  br label %merge

else:                                             ; preds = %entry
  %d1 = alloca { { float, float }**, i32 }*
  %n12 = load i32, i32* %n1
  %tmp13 = sub i32 %n12, 1
  %fxn_result = call { { float, float }**, i32 }* @dragon(i32 %tmp13)
  store { { float, float }**, i32 }* %fxn_result, { { float, float }**, i32 }** %d1
  %d2 = alloca { { float, float }**, i32 }*
  %d114 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %d1
  %fxn_result15 = call { { float, float }**, i32 }* @copy_path({ { float, float }**, i32 }* %d114)
  store { { float, float }**, i32 }* %fxn_result15, { { float, float }**, i32 }** %d2
  %s = alloca float
  %fxn_result16 = call float @sqrt(float 2.000000e+00)
  %tmp17 = fdiv float %fxn_result16, 2.000000e+00
  store float %tmp17, float* %s
  %d118 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %d1
  %fxn_result19 = call float @toradians(float 4.500000e+01)
  %malloccall20 = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2) to i32))
  %anon = bitcast i8* %malloccall20 to { float, float }*
  %fieldaddr21 = getelementptr { float, float }, { float, float }* %anon, i32 0, i32 0
  store float 0.000000e+00, float* %fieldaddr21
  %fieldaddr22 = getelementptr { float, float }, { float, float }* %anon, i32 0, i32 1
  store float 0.000000e+00, float* %fieldaddr22
  %lenref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %d118, i32 0, i32 1
  %len = load i32, i32* %lenref
  %dataref = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %d118, i32 0, i32 0
  %data = load { float, float }**, { float, float }*** %dataref
  %i = alloca i32
  store i32 0, i32* %i
  br label %loop

loop:                                             ; preds = %loop, %else
  %i23 = load i32, i32* %i
  %elref = getelementptr { float, float }*, { float, float }** %data, i32 %i23
  %el = load { float, float }*, { float, float }** %elref
  call void @rotate({ float, float }* %el, float %fxn_result19, i32 -1, { float, float }* %anon)
  %i24 = add i32 %i23, 1
  store i32 %i24, i32* %i
  %i25 = load i32, i32* %i
  %tmp26 = icmp slt i32 %i25, %len
  br i1 %tmp26, label %loop, label %continue

continue:                                         ; preds = %loop
  %d127 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %d1
  %s28 = load float, float* %s
  %s29 = load float, float* %s
  %lenref30 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %d127, i32 0, i32 1
  %len31 = load i32, i32* %lenref30
  %dataref32 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %d127, i32 0, i32 0
  %data33 = load { float, float }**, { float, float }*** %dataref32
  %i34 = alloca i32
  store i32 0, i32* %i34
  br label %loop35

loop35:                                           ; preds = %loop35, %continue
  %i37 = load i32, i32* %i34
  %elref38 = getelementptr { float, float }*, { float, float }** %data33, i32 %i37
  %el39 = load { float, float }*, { float, float }** %elref38
  call void @scale({ float, float }* %el39, float %s28, float %s29)
  %i40 = add i32 %i37, 1
  store i32 %i40, i32* %i34
  %i41 = load i32, i32* %i34
  %tmp42 = icmp slt i32 %i41, %len31
  br i1 %tmp42, label %loop35, label %continue36

continue36:                                       ; preds = %loop35
  %d243 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %d2
  %fxn_result44 = call float @toradians(float 1.350000e+02)
  %malloccall45 = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2) to i32))
  %anon46 = bitcast i8* %malloccall45 to { float, float }*
  %fieldaddr47 = getelementptr { float, float }, { float, float }* %anon46, i32 0, i32 0
  store float 0.000000e+00, float* %fieldaddr47
  %fieldaddr48 = getelementptr { float, float }, { float, float }* %anon46, i32 0, i32 1
  store float 0.000000e+00, float* %fieldaddr48
  %lenref49 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %d243, i32 0, i32 1
  %len50 = load i32, i32* %lenref49
  %dataref51 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %d243, i32 0, i32 0
  %data52 = load { float, float }**, { float, float }*** %dataref51
  %i53 = alloca i32
  store i32 0, i32* %i53
  br label %loop54

loop54:                                           ; preds = %loop54, %continue36
  %i56 = load i32, i32* %i53
  %elref57 = getelementptr { float, float }*, { float, float }** %data52, i32 %i56
  %el58 = load { float, float }*, { float, float }** %elref57
  call void @rotate({ float, float }* %el58, float %fxn_result44, i32 -1, { float, float }* %anon46)
  %i59 = add i32 %i56, 1
  store i32 %i59, i32* %i53
  %i60 = load i32, i32* %i53
  %tmp61 = icmp slt i32 %i60, %len50
  br i1 %tmp61, label %loop54, label %continue55

continue55:                                       ; preds = %loop54
  %d262 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %d2
  %s63 = load float, float* %s
  %s64 = load float, float* %s
  %lenref65 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %d262, i32 0, i32 1
  %len66 = load i32, i32* %lenref65
  %dataref67 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %d262, i32 0, i32 0
  %data68 = load { float, float }**, { float, float }*** %dataref67
  %i69 = alloca i32
  store i32 0, i32* %i69
  br label %loop70

loop70:                                           ; preds = %loop70, %continue55
  %i72 = load i32, i32* %i69
  %elref73 = getelementptr { float, float }*, { float, float }** %data68, i32 %i72
  %el74 = load { float, float }*, { float, float }** %elref73
  call void @scale({ float, float }* %el74, float %s63, float %s64)
  %i75 = add i32 %i72, 1
  store i32 %i75, i32* %i69
  %i76 = load i32, i32* %i69
  %tmp77 = icmp slt i32 %i76, %len66
  br i1 %tmp77, label %loop70, label %continue71

continue71:                                       ; preds = %loop70
  %d278 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %d2
  %malloccall79 = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2) to i32))
  %anon80 = bitcast i8* %malloccall79 to { float, float }*
  %fieldaddr81 = getelementptr { float, float }, { float, float }* %anon80, i32 0, i32 0
  store float 1.000000e+00, float* %fieldaddr81
  %fieldaddr82 = getelementptr { float, float }, { float, float }* %anon80, i32 0, i32 1
  store float 0.000000e+00, float* %fieldaddr82
  %lenref83 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %d278, i32 0, i32 1
  %len84 = load i32, i32* %lenref83
  %dataref85 = getelementptr { { float, float }**, i32 }, { { float, float }**, i32 }* %d278, i32 0, i32 0
  %data86 = load { float, float }**, { float, float }*** %dataref85
  %i87 = alloca i32
  store i32 0, i32* %i87
  br label %loop88

loop88:                                           ; preds = %loop88, %continue71
  %i90 = load i32, i32* %i87
  %elref91 = getelementptr { float, float }*, { float, float }** %data86, i32 %i90
  %el92 = load { float, float }*, { float, float }** %elref91
  call void @trans({ float, float }* %el92, { float, float }* %anon80)
  %i93 = add i32 %i90, 1
  store i32 %i93, i32* %i87
  %i94 = load i32, i32* %i87
  %tmp95 = icmp slt i32 %i94, %len84
  br i1 %tmp95, label %loop88, label %continue89

continue89:                                       ; preds = %loop88
  %d296 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %d2
  call void @reverse({ { float, float }**, i32 }* %d296)
  %r = alloca { { float, float }**, i32 }*
  %d197 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %d1
  %d298 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %d2
  %fxn_result99 = call { { float, float }**, i32 }* @append({ { float, float }**, i32 }* %d197, { { float, float }**, i32 }* %d298, float 1.000000e+00)
  store { { float, float }**, i32 }* %fxn_result99, { { float, float }**, i32 }** %r
  %d1100 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %d1
  call void @free_path({ { float, float }**, i32 }* %d1100)
  %d2101 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %d2
  call void @free_path({ { float, float }**, i32 }* %d2101)
  %r102 = load { { float, float }**, i32 }*, { { float, float }**, i32 }** %r
  store { { float, float }**, i32 }* %r102, { { float, float }**, i32 }** %if_tmp
  br label %merge
}

define { float, float, float, float }* @rainbow(i32 %r, i32 %len) {
entry:
  %r1 = alloca i32
  store i32 %r, i32* %r1
  %len2 = alloca i32
  store i32 %len, i32* %len2
  %h = alloca float
  %r3 = load i32, i32* %r1
  %cast = sitofp i32 %r3 to float
  %tmp = fmul float 1.000000e+00, %cast
  %len4 = load i32, i32* %len2
  %cast5 = sitofp i32 %len4 to float
  %tmp6 = fdiv float %tmp, %cast5
  store float %tmp6, float* %h
  %h7 = load float, float* %h
  %fxn_result = call { float, float, float, float }* @hsv(float %h7, float 0x3FE99999A0000000, float 0x3FE99999A0000000)
  ret { float, float, float, float }* %fxn_result
}
\end{lstlisting}
}

\newpage
\subsubsection{Dragon}
	\colorbox{blue!30}{dragon.sos}

	\begin{lstlisting}
	
	\end{lstlisting}




	% 
	% Show two or three representative source language programs along with the target language  program generated for each
	% Show the test suites used to test your translator
	% Explain why and how these test cases were chosen
	% What kind of automation was used in testing
	% State who did what
	%
	


\end{document}
