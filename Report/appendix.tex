\documentclass[main.tex]{subfiles}

\begin{document}
	\section{Appendix}
	

\subsection{sos.ml}

\begin{lstlisting}
(* Top-level of the SOS compiler: scan & parse the input,
   check the resulting AST and generate an SAST from it, generate LLVM IR,
   and dump the module 
   Reference: The MicroC compiler *)
(* Written by Sheron *)
 
type action = Ast | Sast | LLVM_IR | Compile

let () =
  let action = ref Compile in
  let set_action a () = action := a in
  let speclist = [
    ("-a", Arg.Unit (set_action Ast), "Print the AST");
    ("-s", Arg.Unit (set_action Sast), "Print the SAST");
    ("-l", Arg.Unit (set_action LLVM_IR), "Print the generated LLVM IR");
    ("-c", Arg.Unit (set_action Compile),
      "Check and print the generated LLVM IR (default)");
  ] in  
  let usage_msg = "usage: ./sos.native [-a|-s|-l|-c] [file.sos]" in
  let channel = ref stdin in
  Arg.parse speclist (fun filename -> channel := open_in filename) usage_msg;
  
  let lexbuf = Lexing.from_channel !channel in
  let ast = Parser.program Scanner.token lexbuf in  
  match !action with
    Ast -> Astprint.basic_print ast
  | _ -> let sast = Semant.check ast in
    match !action with
      Ast     -> ()
    | Sast    -> Sastprint.basic_print sast
    | LLVM_IR -> print_string (Llvm.string_of_llmodule (Codegen.translate sast))
    | Compile -> let m = Codegen.translate sast in
	Llvm_analysis.assert_valid_module m;
	print_string (Llvm.string_of_llmodule m)
\end{lstlisting}

\subsection{scanner.mll}
\begin{lstlisting}
	
(* SOS Scanner *)
(* Written primarily by Sheron, later polish by G *)

{ open Parser 
  
  let find_file file = 
      if Sys.file_exists file then file
      else if Sys.file_exists ("lib/"^file) then ("lib/"^file)
      else raise (Failure ("Could not find file "^file))

  let import_table = Hashtbl.create 10
}

(* Definitions *)
let digit = ['0'-'9']
let digits = digit+

(* Rules *)

rule token = parse
  [' ' '\t' '\r' '\n'] { token lexbuf }
| "/*"     { comment 0 lexbuf }           (* Comments *)
| "//"     { single_comment lexbuf }            (* Single line comments *)
| "import " ([^'\n']+".sos" as file) { 
  let file = find_file file in
  if Hashtbl.mem import_table file then IMPORT [] (* Ignore *)
  else (
  Hashtbl.add import_table file ();
  let read = Lexing.from_channel (open_in file) in
  let parsed = Parser.program token read in
  IMPORT parsed ) } 
| '('      { LPAREN }
| ')'      { RPAREN }
| '{'      { LBRACE }
| '}'      { RBRACE }
| '['      { LBRACK }
| ']'      { RBRACK }
| '$'      { DOLLAR }
| ','      { COMMA }
| ':'      { COLON }
| '.'      { DOT }
| "->"     { TO }
| '+'      { ADD }
| '-'      { SUB }
| "**"     { MMUL }
| '*'      { MUL }
| '/'      { DIV }
| '%'      { MOD }
| '@'      { CONCAT }
| ';'      { SEQ }
| "=="     { EQEQ }
| "!="     { NEQ }
| '!'      { NOT }
| '='      { EQ }
| '<'      { LT }
| '>'      { GT }
| "<="     { LTEQ }
| ">="     { GTEQ }
| "&&"     { AND }
| "||"     { OR }
| "of"     { OF }
| "if"     { IF }
| "then"   { THEN }
| "else"   { ELSE }
| "struct" { STRUCT }
| "alias"  { ALIAS }
| "array"  { ARRAY }
| "func"   { FUNC }
| digits as lxm { INTLIT(int_of_string lxm) } 
| digits '.'  digit* ( ['e' 'E'] ['+' '-']? digits )? as lxm { FLOATLIT(lxm) }
| "true"   { BOOLLIT(true) }
| "false"  { BOOLLIT(false) }
| ['a'-'z' 'A'-'Z']['a'-'z' 'A'-'Z' '0'-'9' '_']*     as lxm { VAR(lxm) }
| eof { EOF }
| _ as char { raise (Failure("illegal character " ^ Char.escaped char)) }


and comment depth = parse
  "*/" { if depth==0 then token lexbuf else comment (depth-1) lexbuf }
| "/*" { comment (depth+1) lexbuf }
| _    { comment depth lexbuf }

and single_comment = parse
  '\n' { token lexbuf }
| _    { single_comment lexbuf }
\end{lstlisting}

\subsection{parser.mly}
\begin{lstlisting}

/* SOS Parser */
/* Written primarily by Sheron, later polish by G */

%{ open Ast %}

/* Declarations */

/* %token statements... */
%token ADD SUB MUL MMUL DIV MOD SEQ
%token NOT EQ LT GT LTEQ GTEQ EQEQ NEQ AND OR
%token CONCAT OF
%token DOT COMMA COLON DOLLAR
%token LPAREN RPAREN LBRACE RBRACE LBRACK RBRACK
%token IF THEN ELSE
%token STRUCT ALIAS ARRAY FUNC TO
%token <Ast.program> IMPORT
%token <int> INTLIT
%token <string> FLOATLIT
%token <bool> BOOLLIT
%token <string> VAR
%token EOF

%start program
%type <Ast.program> program

/* Associativity and Precedence */
%right VAR
%nonassoc IF THEN ELSE
%left COMMA 
%left SEQ
%right EQ
%left AND OR
%left EQEQ NEQ
%left LT GT LTEQ GTEQ
%left OF
%left CONCAT
%left ADD SUB
%right MMUL
%left MUL DIV MOD
%nonassoc LBRACK RBRACK LPAREN RPAREN LBRACE RBRACE
%right NOT
%left DOT


%%

/* rules */
typeid:
    VAR { TypeID($1) }
  | ARRAY typeid { ArrayTypeID($2) }
  | FUNC types TO typeid { FxnTypeID($2, $4) } 

value:
    VAR { Var ($1) }
  | value DOT VAR { StructField($1, $3) }
  | value LBRACK expr RBRACK { ArrayAccess($1, $3) }
  | DOLLAR LPAREN expr RPAREN { $3 }
  | fxn_app { $1 }

fxn_app:
    value LPAREN args RPAREN { FxnApp($1, $3) }

stexpr:
    VAR COLON typeid EQ expr { VarDef($3, $1, $5) }
  | VAR EQ expr { Assign ($1, $3) }
  | value DOT VAR EQ expr { AssignStruct($1, $3, $5) }
  | value LBRACK expr RBRACK EQ expr { AssignArray($1, $3, $6) }
  | IF expr THEN expr ELSE expr { IfElse($2,$4,$6) }
  | fxn_app { $1 }

expr:
    INTLIT { IntLit($1) }
  | FLOATLIT { FloatLit($1) }
  | BOOLLIT { BoolLit($1) }
  | NOT expr { Uop(Not,$2) }
  | SUB expr { Uop(Neg,$2) }
  | expr ADD expr { Binop($1,Add,$3) }
  | expr SUB expr { Binop($1,Sub,$3) }
  | expr MUL expr { Binop($1,Mul,$3) }
  | expr MMUL expr { Binop($1,MMul,$3) }
  | expr DIV expr { Binop($1,Div,$3) }
  | expr MOD expr { Binop($1,Mod,$3) }
  | expr EQEQ expr { Binop($1,Eq,$3) }
  | expr NEQ expr { Binop($1,Neq,$3) }
  | expr LT expr { Binop($1,Less,$3) }
  | expr GT expr { Binop($1,Greater,$3) }
  | expr LTEQ expr { Binop($1,LessEq,$3) }
  | expr GTEQ expr { Binop($1,GreaterEq,$3) }
  | expr AND expr { Binop($1,And,$3) }
  | expr OR expr { Binop($1,Or,$3) }
  | expr SEQ expr { Binop($1,Seq,$3) }
  | expr CONCAT expr {Binop($1,Concat,$3) }
  | expr OF expr { Binop($1,Of,$3) }
  | LPAREN expr RPAREN { $2 }
  | VAR LBRACE args RBRACE { NamedStruct($1, $3) }
  | LBRACE args RBRACE { AnonStruct($2) }
  | LBRACK args RBRACK { ArrayCon($2) }
  | VAR { Var ($1) }
  | value DOT VAR { StructField($1, $3) }
  | value LBRACK expr RBRACK {ArrayAccess($1, $3) }
  | stexpr { $1 }

fxn_args:
    /* nothing */ { [] }
  | fxn_args_list {List.rev $1}

fxn_args_list:
    VAR COLON typeid { [($3,$1)] }
  | fxn_args_list COMMA VAR COLON typeid { ($5,$3) :: $1 }

args:
    /* nothing */ { [] }
  | args_list {List.rev $1}

args_list:
    expr { [$1] }
  | args_list COMMA expr { $3 :: $1 }

types:
    /* nothing */ { [] }
  | rev_types {List.rev $1}

rev_types:
    typeid { [$1] }
  | rev_types COMMA typeid { $3 :: $1 }

typedef:
    ALIAS VAR EQ typeid { Alias($2,$4) }
  | STRUCT VAR EQ LBRACE fxn_args RBRACE { StructDef($2,$5) }

stmt:
    typedef { Typedef($1) }
  | VAR COLON LPAREN fxn_args RPAREN TO typeid EQ expr {FxnDef($7,$1,$4,$9)}
  | stexpr { Expression($1) }

stmts:
    stmt { [$1] }
  | stmts stmt { $2:: $1 }

program:
    stmts EOF { List.rev $1 }
  | IMPORT program { $1 @ $2 }
\end{lstlisting}

\subsection{ast.mli}
\begin{lstlisting}
(* Abstract syntax tree for SOS *)
(* Written by G *)

type operator = 
(*num operators*)
Add | Sub | Mul | Div | Mod | MMul
(*relational operators*)
| Eq | Neq | Less | Greater | LessEq | GreaterEq 
(*boolean operators*)
| And | Or 
(* array combination *)
| Concat | Of
(*sequencing*)
| Seq


type uop = Not | Neg

type id = string (* non-type id *)
type tid = (* type id *)
  TypeID of string
| ArrayTypeID of tid
| FxnTypeID of tid list * tid
type import = string

(* type name pair *)
type argtype = tid * id

(* all possible expression statements, found in LRM sec 4 *)
and expr = 
  VarDef of tid * id * expr                (* type name = val *)
| Assign of id * expr                      (* id = val *)
| AssignStruct of expr * id * expr         (* struct.field = val *)
| AssignArray of expr * expr * expr          (* id[expr] = expr *)
| Uop of uop * expr                        (* uop expr *)
| Binop of expr * operator * expr          (* expr op expr *)
| FxnApp of expr * expr list
| IfElse of expr * expr * expr             (* if expr then expr else expr *)
| ArrayCon of expr list                    (* [expr, ...] *)
| AnonStruct of expr list                  (* {expr, ...} *)
| NamedStruct of id * expr list           (* name{expr, ...} *)
| Var of id                                (* name *)
| ArrayAccess of expr * expr                 (* name[expr] *)
| StructField of expr * id                 (* struct.id *)
| IntLit of int                            (* int *)
| FloatLit of string                       (* float *)
| BoolLit of bool                          (* bool *)

type typedef = 
  Alias of id * tid                       (* alias name = type *)
| StructDef of id * argtype list           (* struct name = {type name, ...} *)

type stmt = 
  Typedef of typedef
| Expression of expr
| FxnDef of tid * id * argtype list * expr

type program = stmt list
\end{lstlisting}

\subsection{astprint.ml}
\begin{lstlisting}
(* Very basic """pretty""" printer for the AST *)
(* Written by G *)
open Ast

let rec comma_list_str f l = match l with
  [] -> ""
| hd :: tl -> match tl with
    [] -> f hd
  | _ -> f hd ^ ", " ^ comma_list_str f tl

let rec typeid_str t = match t with
  TypeID(s) -> s
| ArrayTypeID(p) -> "array " ^ typeid_str p
| FxnTypeID(l, t) -> "func " ^ comma_list_str typeid_str l ^" -> "^typeid_str t

let basic_print prog = 
  let rec print_stmt = function
    Typedef(t) -> let print_tdef = function
      Alias(a, b) -> print_endline ("alias " ^ a ^ " " ^ typeid_str(b))
    | StructDef(a, b) -> print_endline ("struct " ^ a ^ " = {" ^ comma_list_str (fun (a, b) -> typeid_str(a) ^ " " ^ b) b ^ "}")
    in print_tdef t
  | FxnDef(a, b, c, d) -> print_endline (typeid_str(a) ^ " " ^ b ^ "(" ^ comma_list_str (fun (a, b) -> typeid_str(a) ^ " " ^ b) c ^ ") = "); print_stmt (Expression(d))
  | Expression(e) -> let rec expr_str = function
      VarDef(a, b, c) -> typeid_str(a) ^ " " ^ b ^ " = " ^ expr_str c
    | Assign(a, b) -> a ^ " = " ^ expr_str b
    | AssignStruct(a, b, c) -> expr_str a ^ "." ^ b ^ " = " ^ expr_str c
    | AssignArray(a, b, c) -> expr_str a^"["^expr_str b ^"] = "^ expr_str c
    | ArrayAccess(nm, idx) -> expr_str nm^"["^expr_str idx^"]"
    | Uop(a, b) -> let uoperator_str = function Not -> "!" | Neg -> "-" in uoperator_str a ^ expr_str b
    | Binop(a, b, c) -> let operator_str = function
        Add -> "+"
      | Sub -> "-"
      | Mul -> "*"
      | MMul -> "**"
      | Div -> "/"
      | Mod -> "%"
      | Eq -> "="
      | Neq -> "!="
      | Less -> "<"
      | Greater -> ">"
      | LessEq -> "<="
      | GreaterEq -> ">="
      | And -> "&&"
      | Or -> "||"
      | Of -> "of"
      | Concat -> "@"
      | Seq -> ";" in
      "(" ^ expr_str a ^ " " ^ operator_str b ^ " " ^ expr_str c ^ ")"
    | FxnApp(a, b) -> 
        expr_str a ^ "(" ^ comma_list_str expr_str b ^ ")"
    | IfElse(a, b, c) -> "if (" ^ expr_str a ^ ")\n then (" ^ expr_str b ^ ")\n else (" ^ expr_str c ^")\n"
    | ArrayCon(a) -> "[" ^ comma_list_str expr_str a ^ "]"
    | AnonStruct(a) -> "{" ^ comma_list_str expr_str a ^ "}"
    | NamedStruct(a, b) -> a ^ "{" ^ comma_list_str expr_str b ^ "}"
    | Var(a) -> a
    | StructField(a, b) -> expr_str a ^ "." ^ b
    | IntLit(i) -> string_of_int i
    | FloatLit(f) -> f
    | BoolLit(true) -> "true"
    | BoolLit(false) -> "false"
    in print_endline(expr_str e)
  in
  List.iter print_stmt prog

(*let _ =
  let lexbuf = Lexing.from_channel stdin in
  let prog = Parser.program Scanner.token lexbuf in
  basic_print prog *)
\end{lstlisting}

\subsection{semant.ml}
\begin{lstlisting}
(* Semantic checking for the SOS compiler *)
(* Written primarily by G *)

open Ast
open Sast

(* import map for global variables (VarDef, FxnDef, Alias, StructDef) *)
(* we don't have scope defined so a string * tid is enough? *)
module StringMap = Map.Make(String)
module StringSet = Set.Make(String)

(* Semantic checking of the AST. Returns an SAST if successful,
   throws an exception if something is wrong.
   Check each statement *)

(* Environment type for holding all the bindings currently in scope *)
type environment = {
  typemap : typeid StringMap.t;
  fxnnames : StringSet.t;
  varmap : typeid StringMap.t;
}

(* External function signatures *)
(* This is re-used in Codegen *)
(* type, name that to be called in SOS, name in c file *)
let external_functions : (typeid * string) list =
[ Func([Float], Float), "sqrtf" ;
  Func([Float], Float), "sinf" ;
  Func([Float], Float), "cosf" ;
  Func([Float], Float), "tanf" ;
  Func([Float], Float), "asinf" ;
  Func([Float], Float), "acosf" ;
  Func([Float], Float), "atanf" ;
  Func([Float], Float), "toradiansf" ;
  Func([Int; Int], Void), "gl_startRendering" ;
  Func([Int; Int; Int], Void), "gl_endRendering" ;
  Func([Array(Float); Array(Float); Int], Void), "gl_drawCurve" ;
  Func([Array(Float); Array(Float); Int; Int], Void), "gl_drawShape" ;
  Func([Array(Float); Array(Float); Int], Void), "gl_drawPoint" ;
]


let raisestr s = raise (Failure s) 

let check prog =

  (* add built-in function such as basic printing *)
  let built_in_decls =
    let add_bind map (name, ty) = StringMap.add name (Func([ty], Void)) map 
    in List.fold_left add_bind StringMap.empty [ ("print", Int);
                                                 ("printf", Float) ]
  in
  (* add external functions *)
  let built_in_decls = List.fold_left
    (fun map (decl, nm) -> StringMap.add nm decl map)
    built_in_decls external_functions
  in
  let starting_fxns = List.fold_left
    (fun map (_, nm) -> StringSet.add nm map)
    StringSet.empty external_functions
  in
  let starting_fxns = StringSet.add "print" starting_fxns in
  let starting_fxns = StringSet.add "printf" starting_fxns in
(*  (* add math functions *)
  let built_in_decls = List.fold_left
    (fun map (decl, nm) -> StringMap.add nm decl map)
    built_in_decls math_functions
  in *)

  (* add built-in types such as int, float *)
  let built_in_types = (
    let add_type map (name, ty) = StringMap.add name ty map
    in List.fold_left add_type StringMap.empty [("int", Int); ("bool", Bool); ("float", Float); ("void", Void)] )
  in

  (* Void id *)
  let built_in_decls = StringMap.add "void" Void built_in_decls in

  (* Initial environment containing built-in types and functions *)
  let global_env = { typemap = built_in_types; varmap = built_in_decls 
  ; fxnnames = starting_fxns }
  in

  (* resolve the type of a tid to a typeid *)
  let rec resolve_typeid t map = match t with
    TypeID(s) -> if StringMap.mem s map
      then StringMap.find s map
      else raisestr ("Could not resolve type id "^s)
  | ArrayTypeID(s) -> Array(resolve_typeid s map)
  | FxnTypeID(l, r) -> Func(List.map (fun tt -> resolve_typeid tt map) l,
          resolve_typeid r map)
  in

  (* should add a function to add three things above dynamically *)
  (* let add_id_type = ()
  in *)

  (* function to lookup *)
  let type_of_id s map = 
    if StringMap.mem s map then StringMap.find s map
    else raisestr ("Unknown variable name "^s)
  in

  (* function to lookup the type of a struct field *)
  let type_of_field stype f = 
    match stype with
      Struct(sargs) -> 
      let rec find_field f = function
        (ft, fn) :: tl -> if fn = f then ft else find_field f tl
        | _ -> raisestr ("Could not find field "^f)
      in find_field f sargs
     | _ -> raisestr ("Cannot access fields for a non-struct variable")
  in

  let add_typedef td map =
    match td with
      Alias(nm, t) -> if StringMap.mem nm map
        then raisestr ("Cannot create an alias with preexisting name " ^ nm)
        else StringMap.add nm (resolve_typeid t map) map
    | StructDef(nm, l) -> let sargl = List.map (fun (t, i) -> (resolve_typeid t map, i)) l in
      StringMap.add nm (Struct(sargl)) map
  in

  let rec add_formals args vmap tmap = match args with
    (typ, nm) :: tl -> add_formals tl (StringMap.add nm (resolve_typeid typ tmap) vmap) tmap
    | _ -> vmap
  in

  (* Matches a struct type component-wise without names *)
  (* Can also work within arrays or other structs *)
  let rec match_str_type t1 t2 =
    match (t1, t2) with
      (Int, Int) -> true
    | (Float, Float) -> true
    | (Bool, Bool) -> true
    | (Void, Void) -> true
    | (Array(a1), Array(a2)) -> match_str_type a1 a2
    | (Struct(s1), Struct(s2)) -> 
        if List.length s1 != List.length s2 then false
        else
        List.fold_left2
          (fun b (st1, _) (st2, _) -> if match_str_type st1 st2 then
             b else false) true s1 s2
    | _ -> false
  in

  (* Returns a sexp that casts sexp to typ, if possible. *)
  (* Returns sexp if no cast is required *)
  let cast_to typ sexp err_str = 
   let (expt, sx) = sexp in
   if expt=typ then sexp else
   if match_str_type expt typ then (typ, sx) else
   if expt=EmptyArray then
    match typ with
      Array(t) -> (Array(t), SArrayCon([]))
    | _ -> raisestr ("Cannot cast empty array to non-array type")
   else
   (
   (match (typ, expt) with
     (Int, Float)   -> ()
   | (Int, Bool)    -> ()
   | (Bool, Int)    -> ()
   | (Bool, Float)  -> ()
   | (Float, Int)   -> ()
   | (Void, _)      -> ()
   | _ -> raisestr err_str );
   (typ, SCast(sexp)))
  in

  (* Function with the same signature as cast_to
   * Used to ignore casting checks *)
  let no_cast typ sexp err_str = 
    ignore(err_str);
    let (expt, _) = sexp in
    if expt=typ then sexp else
    raisestr ("No type casting allowed within arrays")
  in
  
  (* Converts a type to a string *)
  let rec type_str = function
    Int        -> "int"
  | Float      -> "float"
  | Bool       -> "bool"
  | Void       -> "void"
  | Array(t)   -> "array "^type_str t
  | Struct(sl) -> "struct {"^
    (let rec struct_typ_str = function
      (hdt, _) :: (h::t) -> type_str hdt ^ ", " ^struct_typ_str (h::t) 
    | (hdt, _) :: _ -> type_str hdt
    | _ -> ""
    in struct_typ_str sl)^"}"
  | Func(al, rt) -> "func "^
    (let rec func_typ_str = function
      (hdt) :: (h::t) -> type_str hdt ^", "^func_typ_str (h::t)
    | (hdt) :: _ -> type_str hdt
    | _ -> "" in func_typ_str al)^" -> "^type_str rt
  | EmptyArray -> "[]"
  in

  (* Identifies structs with only ints or only floats *)
  let arith_struct t1 at = 
      match t1 with
        Struct(l) -> 
          List.fold_left (fun b (ft, _) -> if ft=at then b else false)
            true l
      | _ -> false
  in
  let either_struct t1 t2 = 
    match t1 with Struct(_) -> true
    | _ -> match t2 with Struct(_) -> true
    | _ -> false
  in
  let is_struct t1 = match t1 with Struct(_) -> true | _ -> false
  in

  let assert_arith t1 = 
    if arith_struct t1 Float then () else
    if arith_struct t1 Int then () else
    raisestr ("Can only operate on arithmetic structs")
  in

  let sop_type t1 =
    if arith_struct t1 Float then Float else
    if arith_struct t1 Int then Int else
    Void
  in

  let addsub_expr env exp1 op exp2 cast = 
      let (t1, _) = exp1 in let (t2, _) = exp2 in
      (* Can add structs component-wise *)
      if either_struct t1 t2 then
        if match_str_type t1 t2 then
          (assert_arith t1 ;
          (t1, SBinop(exp1, op, exp2)), env)
        else
        raisestr ("Can only add or subtract structs of matching type")

      else
      let err = "Cannot add or subtract "^type_str t1^" and "^type_str t2 in
      match (t1, t2) with
        (Float, _) -> (Float, SBinop(exp1, op, cast Float exp2 err)), env
      | (_, Float) -> (Float, SBinop(cast Float exp1 err, op, exp2)), env
      | (Int, _)   -> (Int,   SBinop(exp1, op, cast Int   exp2 err)), env
      | (_, Int)   -> (Int,   SBinop(cast Int exp1 err, op,   exp2)), env
      | _ -> raisestr (err)
  in

  let mul_expr env exp1 op exp2 cast = 
    let (t1, _) = exp1 in let (t2, _) = exp2 in
    (* Can scale structs and take the dot product *)
    if either_struct t1 t2 then
      if match_str_type t1 t2 then
        (assert_arith t1 ;
        (sop_type t1, SBinop(exp1, op, exp2)), env)

      else if is_struct t1 then
        (assert_arith t1 ;
        (t1, SBinop(exp1, op, cast (sop_type t1) exp2
          "Cannot scale a struct by a non-scalar")), env)
      else
        (assert_arith t2 ;
        (t2, SBinop(exp2, op, cast (sop_type t2) exp1
          "Cannot scale a struct by a non-scalar")), env)
    else
    let err = "Cannot multiply "^type_str t1^" and "^type_str t2 in
    match (t1, t2) with
      (Float, _) -> (Float, SBinop(exp1, op, cast Float exp2 err)), env
    | (_, Float) -> (Float, SBinop(cast Float exp1 err, op, exp2)), env
    | (Int, _)   -> (Int,   SBinop(exp1, op, cast Int   exp2 err)), env
    | (_, Int)   -> (Int,   SBinop(cast Int exp1 err, op,   exp2)), env
    | _ -> raisestr ("Cannot multiply "^type_str t1^" and "^type_str t2)
  in

  let mmul_expr env exp1 op exp2 cast =
    ignore(cast); 
    let (t1, _) = exp1 in let (t2, _) = exp2 in
    (* Can multiply two n * n matrices OR
       Can multiply an n*n matrix with an n*1 vector *)
    match (t1, t2) with
      (Struct(l1), Struct(l2)) ->
      let n1 = List.length l1 in let n2 = List.length l2 in
      let int_sqrt n =
        let rec int_sqrt_inner n m = 
          if m * m = n then Some(m)
          else if m * m < n then int_sqrt_inner n (m+1)
          else None
        in int_sqrt_inner n 1
      in
      let sq1 = int_sqrt n1 in (match sq1 with
        | Some(m1) -> 
          if n1 = n2 then
            (Struct(l1), SBinop(exp1, op, exp2)), env

          else if m1 = n2 then
            (Struct(l2), SBinop(exp1, op, exp2)), env

          else raisestr ("Can only multiply a "^string_of_int m1^" by "^string_of_int m1^" matrix with a square matrix or vector of the same height")
        | None -> raisestr ("Can only multiply square matrices")
      )

    | _ -> raisestr ("Cannot matrix multiply non-structs")
  in

  let div_expr env exp1 op exp2 cast = 
      let (t1, _) = exp1 in let (t2, _) = exp2 in
      (* Can scale structs *)
      if is_struct t1 then
        (assert_arith t1 ;
        (t1, SBinop(exp1, op, cast (sop_type t1) exp2
          "Cannot scale a struct by a non-scalar")), env)
      else
      let err = "Cannot divide "^type_str t1^" and "^type_str t2 in
      match (t1, t2) with
        (Float, _) -> (Float, SBinop(exp1, op, cast Float exp2 err)), env
      | (_, Float) -> (Float, SBinop(cast Float exp1 err, op, exp2)), env
      | (Int, _)   -> (Int,   SBinop(exp1, op, cast Int   exp2 err)), env
      | (_, Int)   -> (Int,   SBinop(cast Int exp1 err, op,   exp2)), env
      | _ -> raisestr ("Cannot divide "^type_str t1^" and "^type_str t2)
  in

  let mod_expr env exp1 op exp2 cast = 
      ignore (cast); 
      let (t1, _) = exp1 in let (t2, _) = exp2 in
      match (t1, t2) with
        (Int, Int) -> (Int, SBinop(exp1, op, exp2)), env
      | _ -> raisestr ("Can only take the modulo with integers")
  in

  let eq_expr env exp1 op exp2 cast = 
      let (t1, _) = exp1 in let (t2, _) = exp2 in
      (* Can equate arith structs *)
      if either_struct t1 t2 then
        if match_str_type t1 t2 then
          (assert_arith t1 ;
          (Bool, SBinop(exp1, op, exp2)), env)
        else
        raisestr ("Can only equate structs of matching type")

      else
      let err = "Cannot equate "^type_str t1^" and "^type_str t2 in
      match (t1, t2) with
        (Float, _) -> (Bool, SBinop(exp1, op, cast Float exp2 err)), env
      | (_, Float) -> (Bool, SBinop(cast Float exp1 err, op, exp2)), env
      | (Int, _)   -> (Bool, SBinop(exp1, op, cast Int   exp2 err)), env
      | (_, Int)   -> (Bool, SBinop(cast Int exp1 err, op,   exp2)), env
      | _ -> raisestr (err)
  in

  let comp_expr env exp1 op exp2 cast = 
      let (t1, _) = exp1 in let (t2, _) = exp2 in
      let err = "Cannot compare "^type_str t1^" and "^type_str t2 in
      match (t1, t2) with
        (Float, _) -> (Bool, SBinop(exp1, op, cast Float exp2 err)), env
      | (_, Float) -> (Bool, SBinop(cast Float exp1 err, op, exp2)), env
      | (Int, _)   -> (Bool, SBinop(exp1, op, cast Int exp2 err  )), env
      | (_, Int)  -> (Bool, SBinop(cast Int exp1 err, op, exp2  )), env
      | _ -> raisestr ("Cannot compare "^type_str t1^" and "^type_str t2)
  in

  let logic_expr env exp1 op exp2 cast = 
      let err_str = "Could not resolve boolean operands to boolean values" in
      (Bool, SBinop(cast Bool exp1 err_str, op, cast Bool exp2 err_str)), env
  in

  let array_expr env exp1 op exp2 = 
      let (t1, _) = exp1 in let (t2, _) = exp2 in
      (match t2 with Array(_) -> ()
       | _ -> raisestr ("Cannot perform array operations on non-array type "^type_str t2)      ) ;
      match op with
        Concat     -> if t1 = t2 then (t2, SBinop(exp1, op, exp2)), env
        else raisestr ("Cannot concatenate arrays of different types")
      | _ (* Of *) -> (t2, SBinop((cast_to Int exp1
                    "First operand of of operator must be an int"),
                  op, exp2)), env
  in

  let rec binop_expr env exp1 op exp2 cast = 
    if op = Of || op = Concat then array_expr env exp1 op exp2
    else
    let e = SVar("empty") in
    let t1, _ = exp1 in
    match t1 with Array(t) ->
      let (ot, _), _ = binop_expr env (t, e) op exp2 no_cast in
      (Array(ot), SBinop(exp1, op, exp2)), env
    | _ ->
    let t2, _ = exp2 in
    match t2 with Array(t) ->
      let (ot, _), _ = binop_expr env exp1 op (t, e) no_cast in
      (Array(ot), SBinop(exp1, op, exp2)), env
    | _ ->
    match op with
      Add -> addsub_expr env exp1 op exp2 cast
    | Sub -> addsub_expr env exp1 op exp2 cast
    | Mul -> mul_expr    env exp1 op exp2 cast
    | MMul-> mmul_expr   env exp1 op exp2 cast
    | Div -> div_expr    env exp1 op exp2 cast
    | Mod -> mod_expr    env exp1 op exp2 cast
    | Eq  -> eq_expr     env exp1 op exp2 cast
    | Neq -> eq_expr     env exp1 op exp2 cast
    | Less      -> comp_expr env exp1 op exp2 cast
    | Greater   -> comp_expr env exp1 op exp2 cast
    | LessEq    -> comp_expr env exp1 op exp2 cast
    | GreaterEq -> comp_expr env exp1 op exp2 cast
    | Or ->  logic_expr env exp1 op exp2 cast
    | And -> logic_expr env exp1 op exp2 cast
    | _ -> raisestr ("Special case, this should never happen")
  in

  (* Takes a pair of sexprs and makes their types agree by adding casts,
   if possible. *)
  let agree_type e1 e2 err_str =
    let ((t1, _), (t2, _)) = (e1, e2) in
    if t1=t2 then (e1, e2) else
    (match (t1, t2) with
     (* Priority is Float -> Int -> Bool *)
      (Void, _)  -> (e1, cast_to t1 e2 err_str)
    | (_, Void)  -> (cast_to t2 e1 err_str, e2)
    | (Float, _) -> (e1, cast_to t1 e2 err_str)
    | (_, Float) -> (cast_to t2 e1 err_str, e2)
    | (Int, _)   -> (e1, cast_to t1 e2 err_str)
    | (_, Int)   -> (cast_to t2 e1 err_str, e2)
    | (Bool, _)  -> (e1, cast_to t1 e2 err_str)
    | (_, Bool)  -> (cast_to t2 e1 err_str, e2)
    | _ -> raisestr err_str )
  in

  let rec assert_nonvoid = function
    Void -> raisestr ("Cannot use a void type in this context")
  | Array(t) -> assert_nonvoid t
  | _ -> ()
  in

  let assert_non_reserved env name =
    if name="copy" || name="free" then
    raisestr ("Cannot create an identifier with reserved name "^name)
    else
    if StringSet.mem name env.fxnnames then
    raisestr ("Cannot create an identifier with defined function name "^name)
    else ()
  in

  let rec expr env = function
     
      VarDef (tstr, name, exp) -> 
        assert_non_reserved env name;
        let (sexp, _) = expr env exp in
        let t = resolve_typeid tstr env.typemap in
        assert_nonvoid t ;
        let (exptype, _) = sexp in
        ((t, SVarDef(t, name, cast_to t sexp
                     ("Could not resolve type when defining "^name^
                      "(Found "^type_str exptype^", expected "^type_str t^")"))),
         { env with varmap = StringMap.add name t env.varmap } )

    | Assign (name, exp) ->
         if StringSet.mem name env.fxnnames then
         raisestr ("Cannot assign a defined (non-variable) function")
         else
         let ((exptype, sexp), _) = expr env exp in
         let t = type_of_id name env.varmap in
         ((t, SAssign(name, cast_to t (exptype, sexp)
                  ("Could not match type when assigning variable "^name^
                  " (Found "^type_str exptype^", expected "^type_str t^")"))),env)

    | AssignStruct (struct_exp, field, exp) ->
         let ((exptype, sexp), env) = expr env exp in
         let (struct_sexp, env)  = expr env struct_exp in 
         let (strt, _) = struct_sexp in
         let t = type_of_field strt field in
         ((t, SAssignStruct(struct_sexp, field, cast_to t (exptype, sexp)
                ("Could not match type when assigning field "^field^
                 " (Found "^type_str exptype^", expected "^type_str t^")"))), env)

    | AssignArray (array_exp, idx, exp) ->
        let ((exptype, sexp), env) = expr env exp in
        let (array_sexp, env) = expr env array_exp in
        let (arrt, _) = array_sexp in
        let (sidx, _) = expr env idx in
        (match sidx with (Int, _) -> () | _ ->
           raisestr ("Array index must be an integer ") );
        let eltype = match arrt with Array(el) -> el | _ -> Void in
        ((eltype, SAssignArray(array_sexp, sidx, cast_to eltype (exptype, sexp)
    ("Could not match type when assigning array "^
    "(Found "^type_str exptype^", expected"^type_str eltype^")"))), env)

    | Uop(op, exp) ->
        let (sexp, env) = expr env exp in (
        match op with
          Not -> (Bool, SUop(op, cast_to Bool sexp 
            "Could not resolve expression to bool")), env
        | Neg -> let (t, _) = sexp in
          (match t with
            Int -> ()
          | Float -> ()
          | _ -> raisestr "Cannot negate non-arithmetic types" );
          (t, SUop(op, sexp)), env )

    | Binop(exp1, op, exp2) -> 
      if op = Seq then
         (* Need to pass new environments *)
         (* jk this happens anyways. but seq still gets to feel special *)
         let (e1, env) = expr env exp1 in
         let (e2, env) = expr env exp2 in
         let (t, _) = e2 in
         (t, SBinop(e1, Seq, e2)), env
      else
         let (e1, env) = expr env exp1 in
         let (e2, env) = expr env exp2 in
         binop_expr env e1 op e2 cast_to

    | FxnApp (exp, args) -> 
         if exp=Var("copy") then (* Copy constructor *)
         (match args with
           [ex] ->
            let (sexp, _) = expr env ex in
            let (t, _) = sexp in
            (match t with
              Array(_) -> ()
            | Struct(_) -> ()
            | _ -> raisestr ("Can only use Copy constructor on reference types"));
             ((t, SFxnApp((Func([t], t), SVar("copy")), [sexp])), env)

         | _ -> raisestr ("Too many arguments for Copy constructor")
         )

         else if exp=Var("free") then (* Free instr *)
         (match args with
           [ex] ->
             let (sexp, _) = expr env ex in
             let (t, _) = sexp in
             (match t with
               Array(_) -> ()
             | Struct(_) -> ()
             | _ -> raisestr ("Can only free memory of struct and array types")) ;
             ((Void, SFxnApp((Func([t], t), SVar("free")), [sexp])), env)
          | _ -> raisestr ("Too many arguments for free()")
          )

         else (* All other functions *)
         let fxn, env = expr env exp in
         let sargs, base_rt = match fxn with (Func(l, t), _) -> l, t
          | _ -> raisestr ("Could not resolve expression to a function") in

         let check_args sigl expl env =
           if (List.length sigl) != (List.length expl) then
           raisestr ("Incorrect number of arguments for function")
           else
           let (l, b) = List.fold_left2 
           (fun (l, arr) typ e ->
            let ((exptype, sexp), _) = expr env e in
            if exptype = Array(typ) then (exptype, sexp) :: l, true
            else (cast_to typ (exptype, sexp) 
                ("Could not match type of argument")) :: l, arr ) 
            ([], false) sigl expl
           in (List.rev l, b)
         in
         let cargs, arrmode = check_args sargs args env in
         if arrmode then
         (( (if base_rt=Void then Void else Array(base_rt)), SIterFxnApp(fxn, cargs)), env)
         else ((base_rt, SFxnApp(fxn, cargs)), env)

    | IfElse (eif, ethen, eelse) -> 
        let (sif, env) = expr env eif in
        let scif = cast_to Bool sif
         "Could not resolve if condition to a bool" in
        let (sthen, _) = expr env ethen in
        let (selse, _)  = expr env eelse in
        let (scthen, scelse) = agree_type sthen selse
          ("Could not reconcile types of then and else clauses ("^
         (let (t,_) = sthen in type_str t)^", "^
         (let (t,_) = selse in type_str t)^")") in
        let (t, _) = scthen in
        ((t, SIfElse(scif, scthen, scelse)), env)

    | ArrayCon l -> (match l with
      hd :: tl ->
        let ((exptype, sexp), env) = expr env hd in 
        assert_nonvoid exptype ;
        let rev_sexprs, env = List.fold_left 
          (fun (l, env) ex -> let (se, env) = expr env ex in
           (cast_to exptype se
             "Could not agree types of array literal") :: l, env)
          ([(exptype, sexp)], env) tl in
        ((Array(exptype), SArrayCon(List.rev rev_sexprs)), env)
      | [] -> ((EmptyArray, SArrayCon([])), env) 
      )

    | AnonStruct l -> 
      let rec create_anon_struct env n = function
        e :: tl -> let ((exptype, sexp), env) = expr env e in
          let (typel, expl), env = create_anon_struct env (n+1) tl in
          ((exptype, "x"^string_of_int n) :: typel, (exptype, sexp) :: expl), env
      | _ -> ([], []), env
      in
      let (typel, expl), env = create_anon_struct env 1 l in
      ((Struct(typel), SStruct("anon", expl)), env)

    | NamedStruct (name, l)  ->
      let st = resolve_typeid (TypeID(name)) env.typemap in
      (match st with
        Struct(sargs) -> 
        let rec create_named_struct env argl = function
          e :: tl -> let (sexp, env) = expr env e in
            (match argl with (t, nm) :: argtl ->
              let stl, env = create_named_struct env argtl tl in
              cast_to t sexp
                ("Could not resolve type of struct field "^nm)
               :: stl, env
            | _ -> raisestr ("Too many arguments for struct "^name))
          | [] -> (match argl with
            [] -> [], env
           | _ -> raisestr ("Not enough arguments for struct "^name))
        in
        let sexprs, env = create_named_struct env sargs l
        in ((st, SStruct(name, sexprs)), env)
      | _ -> raisestr ("Cannot resolve the struct name "^name)
     )

    | Var i -> ((type_of_id i env.varmap, SVar(i)), env)
    | ArrayAccess (arr, idx) -> 
      let (sarr, env) = expr env arr in
      let (sidx, env) = expr env idx in
      let (t, _) = sarr in
      let el_t = (match t with Array(e) -> e
        | _ -> raisestr ("Cannot access elements of non-array variable"))
      in
      ((el_t, SArrayAccess(sarr, cast_to Int sidx
         "Could not cast array index to an integer")), env)
    | StructField (str, fl) -> 
       let (sstr, env) = expr env str in
       let (t, _) = sstr in
       (match t with
         Struct(_) ->
          ((type_of_field t fl, SStructField(sstr ,fl)), env)
       | Array(_) -> if fl="length" then
          (Int, SArrayLength(sstr)), env
          else raisestr ("Cannot access fields for a non-struct variable")
       | _ -> raisestr ("Cannot access fields for a non-struct variable")
      )

    | IntLit i -> ((Int, SIntLit i), env)
    | FloatLit f -> ((Float, SFloatLit f), env)
    | BoolLit b -> ((Bool, SBoolLit b), env)
  in

  let make_stypedef env = function
      Alias(nm, tp) -> SAlias(nm, resolve_typeid tp env.typemap)
    | StructDef(nm , l) -> SStructDef(nm, List.map (fun (t, i) -> let tt = resolve_typeid t env.typemap in assert_nonvoid tt; (tt, i)) l)
  in

  (* check a single statement and update the environment *)
  let stmt env = function
      Expression(e) -> let (se, en) = expr env e in (SExpression (se), en)
    | Typedef(td) -> (STypeDef(make_stypedef env td), {env with typemap = add_typedef td env.typemap})
    | FxnDef (tstr, name, args, exp) ->
        assert_non_reserved env name ;
        let t = resolve_typeid tstr env.typemap in
        let sargs = List.map (fun (tp, nm) -> resolve_typeid tp env.typemap, nm)
          args in
        let argtypes = List.map (fun (tp, _) -> assert_nonvoid tp; tp) sargs in
        let newvarmap = StringMap.add name (Func(argtypes, t)) env.varmap in
        let env = { env with varmap = newvarmap; fxnnames = StringSet.add
            name env.fxnnames } in
        let ((exptype, sx), _) = expr { env with
           varmap = add_formals args env.varmap env.typemap; } exp
        in
        (SFxnDef(t, name, sargs, cast_to t (exptype, sx)
                     ("Incorrect return type for function "^name
                     ^" (Found "^type_str exptype^", expected "^type_str t^")"))),
         env

  in

  let rec stmts env = function 
    hd :: tl -> let (st, en) = stmt env hd in st :: stmts en tl
  | _ -> []
  in stmts global_env prog
\end{lstlisting}

\subsection{sast.mli}
\begin{lstlisting}
(* Semantically-checked AST *)

open Ast

(* Detailed type meaning *)
type typeid =
  Int
| Float
| Bool
| Void
| Array of typeid
| Struct of sargtype list
| Func of typeid list * typeid
| EmptyArray (* The empty array constructor, [] *)
and sargtype = typeid * id

(* Detailed function binding *)
type func_bind = {
  ftype : typeid;
  formals : sargtype list;
}

type sexpr = typeid * sx
and sx = 
  SVarDef of typeid * id * sexpr                (* type name = val *)
| SAssign of id * sexpr                      (* id = val *)
| SAssignStruct of sexpr * id * sexpr           (* id.field = val *)
| SAssignArray of sexpr * sexpr * sexpr          (* id[expr] = expr *)
| SUop of uop * sexpr                        (* uop expr *)
| SBinop of sexpr * operator * sexpr          (* expr op expr *)
| SFxnApp of sexpr * sexpr list
| SIterFxnApp of sexpr * sexpr list
| SIfElse of sexpr * sexpr * sexpr             (* if expr then expr else expr *)
| SArrayCon of sexpr list                    (* [expr, ...] *)
(* | SAnonStruct of sexpr list                  (* {expr, ...} *)
| SNamedStruct of id * sexpr list           (* name{expr, ...} *) *)
| SStruct of id * sexpr list
| SVar of id                                (* name *)
| SArrayAccess of sexpr * sexpr                (* name[expr] *)
| SArrayLength of sexpr                        (* name.length *)
| SStructField of sexpr * id                   (* name.id *)
| SIntLit of int                            (* int *)
| SFloatLit of string                       (* float *)
| SBoolLit of bool                          (* bool *)
| SCast of sexpr                            (* type casting *)

type stypedef = 
  SAlias of id * typeid
| SStructDef of id * sargtype list

type sstmt = 
  STypeDef of stypedef
| SExpression of sexpr
| SFxnDef of typeid * id * sargtype list * sexpr (* type id (type name, ...) = val *)

type sprogram = sstmt list
\end{lstlisting}

\subsection{sastprint.ml}
\begin{lstlisting}
(* Very basic """pretty""" printer for SAST *)
(* Written by G *)
open Sast
open Ast

let basic_print sast = 
  let rec sargl_string l =
    List.fold_left (fun str (t, id) -> (if str = "" then "" else str^", ")^typeid_string t ^" "^id) "" l
  and typeid_string = function
    Int -> "int"
  | Float -> "float"
  | Bool -> "bool"
  | Void -> "void"
  | Array(t) -> "array "^typeid_string t
  | Struct(l) -> "{"^sargl_string l^"}"
  | Func(_) -> "func"
  | EmptyArray -> "[]"
  in

  let print_typedef = function
    SAlias(nm, al) -> print_string("alias "^nm^" = "^typeid_string al^"\n")
  | SStructDef(nm,  l) -> print_string("struct "^nm^" = {"^sargl_string l^"}\n")
  in

  let rec explstr l = List.fold_left
    (fun s e -> (if s="" then s else s^", ")^sexp_string e) "" l

  and sexp_string (t, e) = match e with
    SVarDef(_, var, exp) -> typeid_string t ^" "^var^" = "^sexp_string exp^"\n"
  | SAssign(var, exp) -> "("^typeid_string t^") "^var^" = "^sexp_string exp^"\n"
  | SAssignStruct(var, f, exp) -> "("^typeid_string t^") "^sexp_string var^"."^f^" = "^sexp_string exp^"\n"
  | SAssignArray(var, e1, e2) -> "("^typeid_string t^") "^sexp_string var^"["^sexp_string e1^"] = "^sexp_string e2^"\n"
  | SUop(op, exp) -> "("^typeid_string t^")"^
    (match op with Not -> "!" | Neg -> "-")^sexp_string exp
  | SBinop (e1, op, e2) -> let opstr  = match op with
      Add -> "+" | Sub -> "-" | Mul -> "*" | Div -> "/" | Mod -> "%" |
      MMul -> "**" |
      Eq -> "==" | Neq -> "!=" | Less -> "<" | Greater -> ">" | LessEq -> "<=" |
      GreaterEq -> ">=" | And -> "&&" | Or -> "||" | Seq -> ";" |
      Of -> "of" | Concat -> "@" in
    "("^typeid_string t^") ("^sexp_string e1^" "^opstr^" "^sexp_string e2^")"
  | SIterFxnApp (fe, expl)
  | SFxnApp (fe, expl) -> "("^typeid_string t^") "^sexp_string fe^"("^
    (explstr expl)^")\n"
  | SIfElse(e1, e2, e3) -> "("^typeid_string t^") if "^sexp_string e1^"\nthen "^sexp_string e2^"\nelse "^sexp_string e3^"\n"
  | SArrayCon(expl) -> 
      "("^typeid_string t^") ["^explstr expl^"]"
  | SStruct(nm, expl) -> 
      "("^typeid_string t^") "^nm^"{"^explstr expl^"}"
  | SVar(id) -> "("^typeid_string t^") "^id
  | SStructField(id, f) -> "("^typeid_string t^") "^sexp_string id^"."^f
  | SIntLit(i) -> string_of_int i
  | SFloatLit(f) -> f
  | SBoolLit(b) -> string_of_bool b
  | SArrayAccess(nm, idx) -> "("^typeid_string t^") "^sexp_string nm^"["^sexp_string idx^"]"
  | SArrayLength(nm) -> sexp_string nm^".length"
  | SCast(exp) -> sexp_string exp
  in

  let print_sstmt = function
    STypeDef(td) -> print_typedef td
  | SExpression(sexpr) -> print_string(sexp_string sexpr)
  | SFxnDef(_, var, sargl, exp) ->
      print_string(var^"("^sargl_string sargl^") = "^sexp_string exp^"\n")

  in List.iter print_sstmt sast

(*
let _ =
  let lexbuf = Lexing.from_channel stdin in
  let ast = Parser.program Scanner.token lexbuf in
  let sast = Semant.check ast in 
  basic_print sast *)
\end{lstlisting}

\subsection{codegen.ml}
\begin{lstlisting}
(* Code generation: translate takes a semantically checked AST and
produces LLVM IR *)
(* Written primarily by G, some initial setup by Sitong & Sheron *)

module L = Llvm
open Ast
open Sast 

module StringMap = Map.Make(String)
module StringSet = Set.Make(String)

type environment = {
ebuilder : L.llbuilder;
evars : L.llvalue StringMap.t; (* The storage associated with a given var *)
efxns : StringSet.t; (* Which names are original fxn definitions *)
esfxns : (L.llvalue * func_bind) StringMap.t; (* Decls for struct op fxns *)
ecurrent_fxn : L.llvalue; (* The current function *)
}

(* translate : Sast.program -> Llvm.module *)
let translate prog =
  let context    = L.global_context () in
  
  (* Create the LLVM compilation module into which
     we will generate code *)
  let the_module = L.create_module context "SOS" in

  (* Get types from the context *)
  let i32_t      = L.i32_type     context
  and i8_t       = L.i8_type      context
  and i1_t       = L.i1_type      context
  and float_t    = L.float_type   context
  and void_t     = L.void_type    context 
  and ptr_t      = L.pointer_type 
  and struct_t   = L.struct_type  context in

  (* Convenient notation for GEP instructions, etc *)
  let l0         = L.const_int i32_t 0 in
  let l1         = L.const_int i32_t 1 in

  (* Return the LLVM type for a SOS type *)
  let rec ltype_of_typ = function
      Int      -> i32_t
    | Bool     -> i1_t
    | Float    -> float_t
    | Void     -> void_t
    (* An array is a pointer to a struct containing an array (as a pointer)
      and its length, an int *)
    | Array(t) -> ptr_t (struct_t [|ptr_t (ltype_of_typ t); i32_t|])
    | Struct(l) -> ptr_t (struct_t
       (Array.of_list (List.map (fun (tid, _) -> ltype_of_typ tid) l)))
    | Func(l, r) -> ptr_t (L.function_type (ltype_of_typ r) (Array.of_list (List.map ltype_of_typ l)))
    | EmptyArray-> raise (Failure "Unexpected empty array")

  in

  let printf_t : L.lltype = 
      L.var_arg_function_type i32_t [| L.pointer_type i8_t |] in
  let printf_func : L.llvalue = 
      L.declare_function "printf" printf_t the_module in

  (* External Functions *)
  let add_external_fxn env (decl, name) =
      let formals, rt = match decl with Func(formals, rt) -> formals, rt
        | _ -> raise (Failure "Unexpected external function decl") in
      let ftype = L.function_type (ltype_of_typ rt)
        (Array.of_list (List.map (fun t -> ltype_of_typ t) formals)) in
      let lldecl = L.declare_function name ftype the_module in
      { env with evars = StringMap.add name lldecl env.evars ;
          efxns = StringSet.add name env.efxns }
  in

  (* Setup main function *)
  let main =
      L.define_function "main" (L.function_type i32_t [||]) the_module
  in

  (* Add a variable llvalue to environment.evars *)
  let add_variable env nm lv =
       {env with evars = StringMap.add nm lv env.evars }
  in
  
  (* Get a variable's llvalue from environment.evars *)
  let get_variable env nm = if StringMap.mem nm env.evars then StringMap.find nm env.evars
    else raise (Failure ("Unexpected variable name "^nm))
  in

  (* Add a function declaration to environment.efxns *)
  let add_function env nm llv = 
      {env with evars = StringMap.add nm llv env.evars;
       efxns = StringSet.add nm env.efxns }
  in

  (* Add a formal argument llvalue to environment.evars *)
  let add_formal env (ty, nm) param =
    L.set_value_name nm param;
    let local = L.build_alloca (ltype_of_typ ty) nm env.ebuilder in
    ignore (L.build_store param local env.ebuilder);
    add_variable env nm local
  in

   (* Operator Maps *)
   let opstr = function
     Add -> "Add"
   | Sub -> "Sub"
   | Mul -> "Mul"
   | MMul-> "MMul"
   | Div -> "Div"
   | Mod -> "Mod"
   | Eq -> "Eq"
   | Neq -> "Neq"
   | Less -> "Less"
   | Greater -> "Greater"
   | LessEq -> "LessEq"
   | GreaterEq -> "GreaterEq"
   | And -> "And"
   | Or -> "Or" 
   | Of -> "Of"
   | Concat -> "Concat"
   | Seq -> "Seq"
   in

   let make_opmap l =
     List.fold_left (fun map (op, fxn) -> StringMap.add (opstr op) fxn map)
      StringMap.empty l
   in

   let int_map = make_opmap
   [(Add, L.build_add); (Sub, L.build_sub);
    (Mul, L.build_mul); (Div, L.build_sdiv);
    (Eq, L.build_icmp L.Icmp.Eq); (Neq, L.build_icmp L.Icmp.Ne);
    (Mod, L.build_srem);
    (Less, L.build_icmp L.Icmp.Slt); (Greater, L.build_icmp L.Icmp.Sgt);
    (LessEq, L.build_icmp L.Icmp.Sle); (GreaterEq, L.build_icmp L.Icmp.Sge)
     ]
   in
   
   let float_map = make_opmap
   [(Add, L.build_fadd); (Sub, L.build_fsub);
    (Mul, L.build_fmul); (Div, L.build_fdiv);
    (Eq, L.build_fcmp L.Fcmp.Oeq); (Neq, L.build_fcmp L.Fcmp.One);
    (Less, L.build_fcmp L.Fcmp.Olt); (Greater, L.build_fcmp L.Fcmp.Ogt);
    (LessEq, L.build_fcmp L.Fcmp.Ole); (GreaterEq, L.build_fcmp L.Fcmp.Oge)
     ]
   in

   (* Creates a loop that increments i by 1 each iteration,
    * and branches if i >= length. 
    * i_addr : the address of the int to be iterated on
    * length : the value of i to branch at
    * nm     : the name of the iterated variable, to make the LL readable
    * build  : a llvalue -> llbuilder -> llbuilder that builds all the statements using i
    * loop_bb: the basic block to build in
    * end_bb : the basic block to go to *)
   let build_loop i_addr length nm loop_bb end_bb build = 
     let builder = L.builder_at_end context loop_bb in
     let i = L.build_load i_addr "i" builder in
     let builder = build i builder in
     ignore(L.build_store (L.build_add i l1 nm builder) i_addr builder);
     let i = L.build_load i_addr nm builder in
     ignore (L.build_cond_br (L.build_icmp L.Icmp.Slt i length "tmp" builder)
       loop_bb end_bb builder);
   in

   (* General shorthand *)
   let build_zero builder nm = 
     let addr = L.build_alloca i32_t nm builder in
     ignore(L.build_store l0 addr builder);
     addr
   in
   
   let build_param builder decl typ n nm =
       let param = (Array.get (L.params decl) n) in
       L.set_value_name nm param ;
       let local = L.build_alloca typ nm builder in
       ignore (L.build_store param local builder);
       L.build_load local nm builder
    in

   (* Array operataions *)
   let build_array_load data idx nm builder =
     let elref = L.build_gep data [|idx|] (nm^"ref") builder in
     L.build_load elref nm builder
   in

   let build_array_store data idx llv builder = 
     let ref = L.build_gep data [|idx|] "storeref" builder in
     ignore (L.build_store llv ref builder)
   in

   let build_array_struct lltyp data length nm env = 
     let arr_struct = L.build_malloc (L.element_type lltyp) nm env.ebuilder in
     let data_addr = L.build_gep arr_struct [|l0; l0|] (nm^"data") env.ebuilder in
     let len_addr  = L.build_gep arr_struct [|l0; l1|] (nm^"len")  env.ebuilder in
     ignore (L.build_store data  data_addr env.ebuilder);
     ignore (L.build_store length len_addr env.ebuilder);
     arr_struct
   in

   let build_array_data builder lv nm =
     let data_ref = L.build_gep lv [|l0; l0|] (nm^"ref") builder in
     L.build_load data_ref nm builder
   in

   let build_array_len builder lv nm =
     let lenref = L.build_gep lv [|l0; l1|]
      (nm^"ref") builder in
     L.build_load lenref nm  builder
   in

   let build_of t2 ll1 ll2 env = 
     (* Get ll2's length *)
     let len = build_array_len env.ebuilder ll2 "len" in
    
     (* Compute new length *)
     let n = L.build_mul ll1 len "oflen" env.ebuilder in
     (* Pre-GEP the array *)
     let old_data = build_array_data env.ebuilder ll2 "olddata" in
     
     (* Create a new array *)
     let el_typ = match t2 with Array(et) -> et | _ -> Void in
     let data = L.build_array_malloc (ltype_of_typ el_typ) n
       "arrdata" env.ebuilder in
     (* Set up loop *)
     let i_addr = build_zero env.ebuilder "i" in
     let j_addr = build_zero env.ebuilder "j" in
     let loop_bb = L.append_block context "loop" env.ecurrent_fxn in
     let inner_bb = L.append_block context "inner" env.ecurrent_fxn in
     let continue_bb = L.append_block context "continue" env.ecurrent_fxn in
     ignore (L.build_br inner_bb env.ebuilder);

     (* Inner loop *)
     build_loop j_addr len "j" inner_bb loop_bb
       (fun j builder -> 
        let i = L.build_load i_addr "i" builder in
        let el = build_array_load old_data j "el" builder in
        build_array_store data i el builder ;
        ignore(L.build_store (L.build_add i l1 "i" builder) i_addr builder);
        builder 
       ) ;

     (* Outer loop *)
     let builder = L.builder_at_end context loop_bb in
     let i = L.build_load i_addr "i" builder in
     ignore (L.build_store l0 j_addr builder);
     ignore (L.build_cond_br (L.build_icmp L.Icmp.Slt i n "tmp" builder)
       inner_bb continue_bb builder);

     (* Continue *)
     let builder = L.builder_at_end context continue_bb in
     let env = { env with ebuilder = builder } in

     (* Create array struct *)
     let arr_struct = build_array_struct (ltype_of_typ t2) data n "arr" env in
     arr_struct, env
   in

   let build_concat t2 ll1 ll2 env =
     (* Get lengths *)
     let len1 = build_array_len env.ebuilder ll1 "len1" in
     let len2 = build_array_len env.ebuilder ll2 "len2" in
     let n = L.build_add len1 len2 "n" env.ebuilder in

     (* Pre-GEP the arrays *)
     let data1 = build_array_data env.ebuilder ll1 "data1" in
     let data2 = build_array_data env.ebuilder ll2 "data2" in

     (* Create a new array *)
     let el_typ = match t2 with Array(et) -> et | _ -> Void in
     let data = L.build_array_malloc (ltype_of_typ el_typ) n
       "data" env.ebuilder in 
     (* Set up loop *)
     let i_addr = build_zero env.ebuilder "i" in
     let j_addr = build_zero env.ebuilder "j" in

     let loop1 = L.append_block context "loop1" env.ecurrent_fxn in
     let inbtw = L.append_block context "inbtw" env.ecurrent_fxn in
     let loop2 = L.append_block context "loop2" env.ecurrent_fxn in
     let contb = L.append_block context "contb" env.ecurrent_fxn in
     ignore (L.build_br loop1 env.ebuilder);

     let make_concat_loop sbb tbb from_data len =
       build_loop j_addr len "j" sbb tbb
       (fun j builder ->
       let i = L.build_load i_addr "i" builder in
       let el = build_array_load from_data j "el" builder in
       build_array_store data i el builder ;
       ignore (L.build_store (L.build_add i l1 "tmp" builder)
               i_addr builder) ;
       builder )
     in
     (* Loop 1 *)
     make_concat_loop loop1 inbtw data1 len1 ;
     
     let builder = L.builder_at_end context inbtw in
     ignore(L.build_store l0 j_addr builder);
     ignore(L.build_br loop2 builder);
     (* Loop 2 *)
     make_concat_loop loop2 contb data2 len2 ;

     (* Continue *)
     let builder = L.builder_at_end context contb in
     let env = { env with ebuilder = builder } in
     (* Create array struct *)
     let arr_struct = build_array_struct (ltype_of_typ t2) data n "arr" env in
     arr_struct, env
   in

   (* Struct ops *)
   (* Finds the integer field index *)
   let find_field struct_typ field = 
       let sargl = match struct_typ with Struct(l) -> l | _  -> [] in
       let rec find_field_inner sargl field n = match sargl with sarg :: tl ->
         let (_, nm) = sarg in
         if nm = field then n else find_field_inner tl field n+1
       | _ -> raise (Failure "Field not found")
       in
       find_field_inner sargl field 0
   in

   let build_struct_field builder lv n nm =
     let ref = L.build_gep lv [|l0; L.const_int i32_t n|] (nm^"ref") builder in
     L.build_load ref nm builder
   in     

   let build_struct_store builder lv s_lv n = 
     let ref = L.build_gep s_lv [|l0; L.const_int i32_t n|] "ref" builder in
     ignore (L.build_store lv ref builder)
   in

   let dot_product stype slist env =
     let atype = match slist with
       (hd, _) :: _ -> if hd = Float then Float else Int
     | _ -> Float in
     let len = List.length slist in
     
     let name = "__dot"^(if atype=Float then "f" else "i")^(string_of_int len) in

     if StringMap.mem name env.esfxns then
       StringMap.find name env.esfxns, env
     else (* Make new function *)
       let ltype = ltype_of_typ stype in
       let formals = [|ltype; ltype|] in
       let ftype = L.function_type (ltype_of_typ atype) formals in
       let decl = L.define_function name ftype the_module in
       let builder = L.builder_at_end context (L.entry_block decl) in

       let bind = { ftype = atype; formals = [stype, "a"; stype, "b"] } in

       let a = build_param builder decl ltype 0 "a" in
       let b = build_param builder decl ltype 1 "b" in

       let res = L.build_alloca (ltype_of_typ atype) "dot" builder in
       let tmp = L.build_alloca (ltype_of_typ atype) "tmp" builder in
       ignore(L.build_store (if atype=Float then L.const_float (ltype_of_typ Float) 0.0 else L.const_int i32_t 0) res builder) ;
       let map = (if atype=Float then float_map else int_map) in
       (if StringMap.mem "Mul" map && StringMap.mem "Add" map then () else raise (Failure("Could not find operator in dot_product"))) ;
       let opmul = StringMap.find "Mul" map in
       let opadd = StringMap.find "Add" map in
       let rec dot_prod n = 
         if n < len then 
           let aval = build_struct_field builder a n "aval" in
           let bval = build_struct_field builder b n "bval" in
           ignore (L.build_store (opmul aval bval "tmp" builder) tmp builder);
           let tmpv = L.build_load tmp "tmp" builder in
           let resv = L.build_load res "res" builder in
           ignore (L.build_store (opadd tmpv resv "tmp" builder) res builder);
           dot_prod (n+1)
         else ()
       in
       dot_prod 0 ;

       (* Return *)
       let resv = L.build_load res "res" builder in
       ignore (L.build_ret resv builder) ;
       (decl, bind), { env with esfxns = StringMap.add name (decl, bind) env.esfxns }
   in

   let struct_sum stype slist op env =
     let atype = match slist with
       (hd, _) :: _ -> if hd = Float then Float else Int
     | _ -> Float in
     let len = List.length slist in
     
     let name = "__"^(if op=Add then "add" else "sub")^
      (if atype=Float then "f" else "i")^(string_of_int len) in

     if StringMap.mem name env.esfxns then
       StringMap.find name env.esfxns, env
     else (* Make new function *)
       let ltype = ltype_of_typ stype in
       let formals = [|ltype; ltype|] in
       let ftype = L.function_type ltype formals in
       let decl = L.define_function name ftype the_module in
       let builder = L.builder_at_end context (L.entry_block decl) in

       let bind = { ftype = stype; formals = [stype, "a"; stype, "b"] } in

       let a = build_param builder decl ltype 0 "a" in
       let b = build_param builder decl ltype 1 "b" in

       let struc = L.build_malloc (L.element_type ltype) "ret" builder in
       let map = (if atype=Float then float_map else int_map) in
       (if StringMap.mem (opstr op) map then () else raise (Failure("Could not find op "^(opstr op)^" in struct_sum map")) );
       let sumop = StringMap.find (opstr op) map in
       let rec strsum n = 
         if n < len then 
           let aval = build_struct_field builder a n "aval" in
           let bval = build_struct_field builder b n "bval" in
           build_struct_store builder (sumop aval bval "tmp" builder) struc n;
           strsum (n+1)
         else ()
       in
       strsum 0 ;

       (* Return *)
       ignore (L.build_ret struc builder) ;
       (decl, bind), { env with esfxns = StringMap.add name (decl, bind) env.esfxns }
   in

   let struct_scale stype slist op env =
     let atype = match slist with
       (hd, _) :: _ -> if hd = Float then Float else Int
     | _ -> Float in
     let len = List.length slist in
     
     let name = "__"^(if op=Mul then "mul" else "div")^
      (if atype=Float then "f" else "i")^(string_of_int len) in

     if StringMap.mem name env.esfxns then
       StringMap.find name env.esfxns, env
     else (* Make new function *)
       let ltype = ltype_of_typ stype in
       let altype = ltype_of_typ atype in
       let formals = [|ltype; altype|] in
       let ftype = L.function_type ltype formals in
       let decl = L.define_function name ftype the_module in
       let builder = L.builder_at_end context (L.entry_block decl) in

       let bind = { ftype = stype; formals = [stype, "a"; stype, "b"] } in

       let a = build_param builder decl ltype 0 "a" in
       let b = build_param builder decl altype 1 "b" in

       let struc = L.build_malloc (L.element_type ltype) "ret" builder in
       let map = (if atype=Float then float_map else int_map) in
       (if StringMap.mem (opstr op) map then () else raise (Failure("Could not find op "^(opstr op)^" in struct_scale map")) );
       let sumop = StringMap.find (opstr op) map in
       let rec strscl n = 
         if n < len then 
           let aref = L.build_gep a [|l0; L.const_int i32_t n|] "aref" builder in
           let aval = L.build_load aref "aval" builder in
           build_struct_store builder (sumop aval b "tmp" builder) struc n;
           strscl (n+1)
         else ()
       in
       strscl 0 ;

       (* Return *)
       ignore (L.build_ret struc builder) ;
       (decl, bind), { env with esfxns = StringMap.add name (decl, bind) env.esfxns }
   in
   
   let struct_eq stype slist op env =
     let atype = match slist with
       (hd, _) :: _ -> if hd = Float then Float else Int
     | _ -> Float in
     let len = List.length slist in

     let name = "__"^(if op=Eq then "eq" else "neq")^
       (if atype=Float then "f" else "i")^(string_of_int len) in

     if StringMap.mem name env.esfxns then
       StringMap.find name env.esfxns, env
     else (* Make new function *)
       let ltype = ltype_of_typ stype in
       let formals = [|ltype; ltype|] in
       let ftype = L.function_type (ltype_of_typ Bool) formals in
       let decl = L.define_function name ftype the_module in
       let builder = L.builder_at_end context (L.entry_block decl) in

       let bind = { ftype = Bool; formals =
           [stype, "a"; stype, "b"] } in

       let a = build_param builder decl ltype 0 "a" in
       let b = build_param builder decl ltype 1 "b" in

       let ret = L.build_alloca (ltype_of_typ Bool) "ret" builder in
       let eq = StringMap.find (opstr op) (if atype=Float then float_map
          else int_map) in
       let combine = if op=Eq then L.build_and else L.build_or in
       ignore(L.build_store (L.const_int i1_t (if op=Eq then 1 else 0)) ret builder);
       let rec streq n = 
         if n < len then
           let aval = build_struct_field builder a n "aval" in
           let bval = build_struct_field builder b n "bval" in
           let rval = L.build_load ret "rval" builder in
           ignore(L.build_store
             (combine rval (eq aval bval "eq" builder) "ret" builder) ret builder);
           streq (n+1)
         else ()
       in streq 0 ;

       (* Return *)
       let rv = L.build_load ret "rval" builder in
       ignore(L.build_ret rv builder) ;
       (decl, bind), { env with esfxns = StringMap.add name (decl, bind) env.esfxns }
   in

   let mat_mul rtype slist1 slist2 env =
     let atype = match slist1 with
       (hd, _) :: _ -> if hd = Float then Float else Int
     | _ -> Float in
     let size = List.length slist1 in
     let int_sqrt n = 
       let rec int_sqrt_inner n m = 
         if m * m = n then m
         else if m * m < n then int_sqrt_inner n (m+1)
         else raise (Failure "Unexpected struct size")
       in int_sqrt_inner n 1
     in
     let n = int_sqrt size in
     let m = List.length slist2 in

     let name = "__"^(if m=n then "vec" else "mat")^
       (if atype=Float then "f" else "i")^(string_of_int n) in
     if StringMap.mem name env.esfxns then
       StringMap.find name env.esfxns, env
     else (* Make new function *)
       let rltype = ltype_of_typ rtype in
       let ltype1 = ltype_of_typ (Struct(slist1)) in
       let ltype2 = ltype_of_typ (Struct(slist2)) in
       let altype = ltype_of_typ atype in
       let formals = [|ltype1; ltype2|] in
       let ftype = L.function_type rltype formals in
       let decl = L.define_function name ftype the_module in
       let builder = L.builder_at_end context (L.entry_block decl) in

       let bind =
        { ftype = rtype; formals = [Struct(slist1), "A"; Struct(slist2), "B"] } in
       
       let a = build_param builder decl ltype1 0 "A" in
       let b = build_param builder decl ltype2 1 "B" in

       let struc = L.build_malloc (L.element_type rltype) "ret" builder in
       let map = (if atype=Float then float_map else int_map) in
       let sumop = StringMap.find (opstr Add) map in
       let mulop = StringMap.find (opstr Mul) map in
       let height = n in
       let width = (if m=n then 1 else n) in
       let tmp = L.build_alloca altype "tmp" builder in
       let rec mmul i j =
         if i < width then
         if j < height then (
         ignore(L.build_store (if atype=Float then L.const_float altype 0.0 else L.const_int altype 0) tmp builder) ;
         let rec mmul_inner k = 
           if k < height then (
           let aval = build_struct_field builder a (j+k*n) "aval" in
           let bval = build_struct_field builder b (k+i*n) "bval" in
           let mval = mulop aval bval "tmp2" builder in
           let tval = L.build_load tmp "tval" builder in
           ignore (L.build_store (sumop mval tval "tmp" builder) tmp builder);
           mmul_inner (k+1))
           else ()
         in mmul_inner 0 ;
         let tval = L.build_load tmp "tval" builder in
         build_struct_store builder tval struc (j+i*n);
         mmul (i+1) j )
         else (* j >= height *) ()
         else (* i >= width *)  mmul 0 (j+1)
       in
       mmul 0 0 ;

       (* Return *)
       ignore (L.build_ret struc builder) ;
       (decl, bind), { env with esfxns = StringMap.add name (decl, bind) env.esfxns }
   in

   (* Binops *)
   let rec binop op rt t1 t2 ll1 ll2 env = 
     if op = Of then build_of t2 ll1 ll2 env
     else if op = Concat then build_concat t2 ll1 ll2 env
     else
     (match (t1, t2) with
       (Bool, Bool) ->
         let llop = match op with
           Or -> L.build_or
         | And -> L.build_and
         | _ -> raise(Failure "Unexpected boolean operator") in
         llop ll1 ll2 "tmp" env.ebuilder, env
     | (Int, Int) -> StringMap.find (opstr op) int_map ll1 ll2 "tmp"
         env.ebuilder, env
     | (Float, Float) -> StringMap.find (opstr op) float_map ll1 ll2
         "tmp" env.ebuilder, env
     | (Struct(l1), Struct(l2)) -> let (decl, _), env = 
       (match op with
          Mul -> dot_product t1 l1 env
        | MMul-> mat_mul rt l1 l2 env
        | Eq  -> struct_eq t1 l1 op env
        | Neq -> struct_eq t1 l1 op env
        | Add -> struct_sum t1 l1 op env
        | Sub -> struct_sum t1 l1 op env
        | _ -> raise (Failure("Unexpected struct operator "^(opstr op))) ) in
       L.build_call decl [|ll1; ll2|] "result" env.ebuilder, env
     | (Array(el_typ), _) ->
       let len = build_array_len env.ebuilder ll1 "len" in
      
       (* Pre-GEP the array *)
       let argdata = build_array_data env.ebuilder ll1 "argdata" in
     
       (* Create a new array *)
       let rtel_typ = match rt with Array(et) -> et | _ -> Void in
       let data = L.build_array_malloc (ltype_of_typ rtel_typ) len
         "arrdata" env.ebuilder in
       (* Set up loop *)
       let i_addr = build_zero env.ebuilder "i" in
       let loop_bb = L.append_block context "loop" env.ecurrent_fxn in
       let cont_bb = L.append_block context "cont" env.ecurrent_fxn in
       ignore (L.build_br loop_bb env.ebuilder);
       (* Build loop *)
       build_loop i_addr len "i" loop_bb cont_bb (
         fun i builder -> 
         let v = build_array_load argdata i "v" builder in
         let fenv = { env with ebuilder = builder } in
         let llv, fenv = binop op rtel_typ el_typ t2 v ll2 fenv in
         let builder = fenv.ebuilder in
         build_array_store data i llv builder;
         builder ) ;
       (* Continue *)
       let builder = L.builder_at_end context cont_bb in
       let env = { env with ebuilder = builder } in
       (* Create array struct *)
       let arr_struct = build_array_struct (ltype_of_typ rt) data len "arr" env in
       arr_struct, env

     | (_, Array(el_typ)) -> 
       let len = build_array_len env.ebuilder ll2 "len" in
      
       (* Pre-GEP the array *)
       let argdata = build_array_data env.ebuilder ll2 "argdata" in
     
       (* Create a new array *)
       let rtel_typ = match rt with Array(et) -> et | _ -> Void in
       let data = L.build_array_malloc (ltype_of_typ rtel_typ) len
         "arrdata" env.ebuilder in
       (* Set up loop *)
       let i_addr = build_zero env.ebuilder "i" in
       let loop_bb = L.append_block context "loop" env.ecurrent_fxn in
       let cont_bb = L.append_block context "cont" env.ecurrent_fxn in
       ignore (L.build_br loop_bb env.ebuilder);
       (* Build loop *)
       build_loop i_addr len "i" loop_bb cont_bb (
         fun i builder -> 
         let v = build_array_load argdata i "v" builder in
         let fenv = { env with ebuilder = builder } in
         let llv, fenv = binop op rtel_typ t1 el_typ ll1 v fenv in
         let builder = fenv.ebuilder in
         build_array_store data i llv builder;
         builder ) ;
       (* Continue *)
       let builder = L.builder_at_end context cont_bb in
       let env = { env with ebuilder = builder } in
       (* Create array struct *)
       let arr_struct = build_array_struct (ltype_of_typ rt) data len "arr" env in
       arr_struct, env
     | (Struct(l1), _) -> let (decl, _), env = struct_scale t1 l1 op env 
       in L.build_call decl [|ll1; ll2|] "result" env.ebuilder, env
     | _ -> raise (Failure "Unsupported operation")
     )
   in

   (* Construct code for an expression
      Return its llvalue and the updated builder *)
   let rec expr env sexpr = 
     let (t, e) = sexpr in match e with
     (* Literals *)
     SIntLit(i) -> L.const_int i32_t i, env
   | SFloatLit(f) -> L.const_float_of_string float_t f, env
   | SBoolLit(b) -> L.const_int i1_t (if b then 1 else 0), env
   | SArrayCon(expl) -> 
     let n = List.length expl in
     let el_typ = match t with Array(et) -> et | _ -> Void in
     (* Create data *)
     let data = L.build_array_malloc
       (ltype_of_typ el_typ)
       (L.const_int i32_t n) "arrdata" env.ebuilder in 
     let (_, env) = List.fold_left
       (fun (n, env) sx -> 
         let (lv, env) = expr env sx in
         build_array_store data (L.const_int i32_t n) lv env.ebuilder;
         (n+1, env) ) (0, env) expl in
     (* Create struct *)
     let arr_struct = build_array_struct (ltype_of_typ t) data
       (L.const_int i32_t n) "arr" env in
     arr_struct, env

   | SStruct(nm, expl) ->
     let struc = L.build_malloc (L.element_type (ltype_of_typ t)) nm env.ebuilder in
     let rec set_fields env n = function
       exp :: tl -> 
         let fieldaddr = L.build_gep struc [|l0; L.const_int i32_t n|]
           "fieldaddr" env.ebuilder in 
         let (lv, env) = expr env exp in
         ignore(L.build_store lv fieldaddr env.ebuilder);
         set_fields env (n+1) tl
       | [] -> env
     in
     let env = set_fields env 0 expl in
     struc, env

     (* Access *)
   | SVar(nm) -> 
     if nm="void" then l0, env else (* Void id *)
     if StringSet.mem nm env.efxns then (* Global fxn name, don't load *)
     get_variable env nm, env
     else (* All other variables *) 
     (L.build_load (get_variable env nm) nm env.ebuilder),env

   | SArrayAccess(arr_exp, idx) -> 
     let (arr, env) = expr env arr_exp in
     let (idx_lv, env) = expr env idx in
     (* Access the struct pointer, then the field *)
     let elref = L.build_gep arr [|l0; l0|]
       ("dataref") env.ebuilder in
     (* Access data *)
     let d = L.build_load elref ("data") env.ebuilder in
     build_array_load d idx_lv "el" env.ebuilder, env

   | SArrayLength (arr_exp) -> let (arr, env) = expr env arr_exp in
     build_array_len env.ebuilder arr "len", env

   | SStructField (str_exp, fl) ->
       let (stype, _) = str_exp in
       let (struc, env) = expr env str_exp in
       let idx = find_field stype fl in
       let adr = L.build_gep struc [|l0; L.const_int i32_t idx|]
         "fieldadr" env.ebuilder in
         L.build_load adr (fl) env.ebuilder, env

     (* Definitions *)
   | SVarDef(ty, nm, ex) ->  
       let var = L.build_alloca (ltype_of_typ ty) nm env.ebuilder in
       let env = add_variable env nm var in
       expr env (t, SAssign(nm, ex)) (* Bootstrap off Assign *)

     (* Assignments *)
   | SAssign(nm, ex) ->
       let ex' = expr env ex in
       let (lv, env) = ex' in
       ignore(L.build_store lv (get_variable env nm) env.ebuilder); ex'

   | SAssignStruct (str_exp, fl, ex) ->
       let (stype, _) = str_exp in
       let (struc, env) = expr env str_exp in
       let ex' = expr env ex in
       let (lv, env) = ex' in
       (* Find field index *)
       let idx = find_field stype fl in
       build_struct_store env.ebuilder lv struc idx; ex'

   | SAssignArray (arr_exp, idx, ex) ->
       let (arr, env) = expr env arr_exp in
       let data = build_array_data env.ebuilder arr "dataref" in
       let (i, env) = expr env idx in
       let (el, env) = expr env ex in
       build_array_store data i el env.ebuilder; (el, env)

     (* Operators *)
   | SUop (op, exp) ->
       let (l, env) = expr env exp in
       (match op with
         Neg when t = Float -> L.build_fneg
       | Neg                -> L.build_neg
       | Not                -> L.build_not) l "tmp" env.ebuilder, env

   | SBinop(exp1, op, exp2) ->
       (match op with
         Seq ->
           let (_, env) = expr env exp1 in
           expr env exp2 
       | _ -> 
         let (t1, _) = exp1 in let (t2, _) = exp2 in
         let (ll1, env) = expr env exp1 in
         let (ll2, env) = expr env exp2 in
         binop op t t1 t2 ll1 ll2 env       
       )

     (* Function application *)
    (* Special functions *)
   | SFxnApp((_, SVar("printf")), [e]) -> 
      let float_format_str =
       L.build_global_stringptr "%g\n" "fmt" env.ebuilder in
      let arg, env  = expr env e in 
      let dval = L.build_fpext arg (L.double_type context) "fmtp" env.ebuilder in
      L.build_call printf_func [| float_format_str; dval |]
        "printf" env.ebuilder, env
   | SFxnApp((_, SVar("print")), [e]) ->
      let int_format_str = 
       L.build_global_stringptr "%d\n" "fmt" env.ebuilder in
      let arg, env = expr env e in
      L.build_call printf_func [| int_format_str ; arg |]
        "printf" env.ebuilder, env


   | SFxnApp((_, SVar("copy")), [e]) ->
      let (ctype, _) = e in
      let arg, env = expr env e in
      (
      match ctype with
        Array(atype)    -> 
          let n = build_array_len env.ebuilder arg "len"in
          (* Pre-GEP the array *)
          let cdata = build_array_data env.ebuilder arg "cdata" in
     
          (* Create a new array *)
          let data = L.build_array_malloc (ltype_of_typ atype) n
            "arrdata" env.ebuilder in
          (* Set up loop *)
          let i_addr = build_zero env.ebuilder "i" in
          let loop_bb = L.append_block context "loop" env.ecurrent_fxn in
          let continue_bb = L.append_block context "continue" env.ecurrent_fxn in
          ignore (L.build_br loop_bb env.ebuilder);

          (* Loop *)
          build_loop i_addr n "i" loop_bb continue_bb
            (fun i builder ->
             let el = build_array_load cdata i "el" builder in
             build_array_store data i el builder ; builder ) ;

         (* Continue *)
         let builder = L.builder_at_end context continue_bb in
         let env = { env with ebuilder = builder } in
         (* Create array struct *)
         let arr_struct = build_array_struct (ltype_of_typ t) data n
           "arr" env in
         arr_struct, env
          
      | Struct(sfields) ->
         let len = List.length sfields in
         let name = "__copy"^(string_of_int len) in

         let (decl, _), env = if StringMap.mem name env.esfxns
         then StringMap.find name env.esfxns, env
         else (* Make a new copy fxns *)
           let formals = [|ltype_of_typ ctype|] in
           let ftype = L.function_type (ltype_of_typ ctype) formals in
           let decl = L.define_function name ftype the_module in
           let builder = L.builder_at_end context (L.entry_block decl) in

           let bind = { ftype = ctype; formals = [ctype, "to_copy"] } in

           let tocopy = build_param builder decl (ltype_of_typ ctype) 0 "to_copy" in

           (* Create a new struct *)
           let struc = L.build_malloc (L.element_type (ltype_of_typ ctype))
             "struct" builder in
           let rec copy_struct n =
             if n < len then
             let fl = build_struct_field builder tocopy n "fl" in
             build_struct_store builder fl struc n;
             copy_struct (n+1)
             else ()
           in
           copy_struct 0 ;

           (* Return *)
           ignore (L.build_ret struc builder) ;
           (decl, bind), { env with esfxns = StringMap.add name (decl, bind) env.esfxns }
         in
         L.build_call decl [|arg|] "copied" env.ebuilder, env


      | _ -> raise (Failure "Copy constructor only works on reference types")
      )

   (* Free instruction *)
   | SFxnApp((_, SVar("free")), [e]) ->
      let (ctype, _) = e in
      let arg, env = expr env e in
      (
      match ctype with
        Array(_)    -> 
         (* Need to free data as well as the structure *)
         let dataref = build_array_data env.ebuilder arg "data" in
         ignore(L.build_free dataref env.ebuilder);
      | _ -> () ) ;
      (* Free structure *)
      ignore(L.build_free arg env.ebuilder) ;
      l0, env

    (* General functions *)
   | SFxnApp(fexp, args) ->  
      let fdef, env = expr env fexp in
      let (fxntype, _) = fexp in
      let _, rt = match fxntype with Func(l, t) -> l, t | _ -> 
        raise (Failure "Unexpected function type") in

      (* Get llvalues of args and accumualte env *)
      let (llargs_rev, env) = List.fold_left
        (fun (l, env) a -> let (ll, e) = expr env a in (ll::l, e))
        ([], env) args in
      let llargs = List.rev llargs_rev in
      let result = (match rt with
                      Void -> ""
                    | _ -> "fxn_result") in
      (* Normal function application *)
      L.build_call fdef (Array.of_list llargs) result env.ebuilder, env

    | SIterFxnApp(fexp, args) ->
      let fdef, env = expr env fexp in
      let (fxntype, _) = fexp in
      let fargs, rt = match fxntype with Func(l, t) -> l, t | _ -> 
        raise (Failure "Unexpected function type") in

      (* Get llvalues of args and accumualte env *)
      let (llargs_rev, env) = List.fold_left
        (fun (l, env) a -> let (ll, e) = expr env a in (ll::l, e))
        ([], env) args in
      let llargs = List.rev llargs_rev in
      let result = (match rt with
                      Void -> ""
                    | _ -> "fxn_result") in

      (* Iterated fxn application *)
      let arr_args = List.map2 (fun (ty, _) fty -> ty=Array(fty) )
           args fargs in
      let rec find_first bools = function 
        (hd :: tl) -> if List.hd bools then hd else find_first (List.tl bools) tl
      | _ -> raise (Failure "Unexpected arguments")
      in let first = find_first arr_args llargs in
      let len = build_array_len env.ebuilder first "len" in
      (* Pre-GEP all the arrays *)
      let datalist = List.map2
        (fun llarg b -> if b then 
          Some(build_array_data env.ebuilder llarg "data")
         else None) llargs arr_args in

      (* Create a new array *)
      let data = if t=Void then None else 
        Some(L.build_array_malloc (ltype_of_typ rt) len
       "arrdata" env.ebuilder) in
      (* Set up loop *)
      let i_addr = build_zero env.ebuilder "i" in
      let loop_bb = L.append_block context "loop" env.ecurrent_fxn in
      let cont_bb = L.append_block context "continue" env.ecurrent_fxn in
      ignore (L.build_br loop_bb env.ebuilder);

      (* Loop *)
      build_loop i_addr len "i" loop_bb cont_bb
        (fun i builder ->
          let llargs_i = List.map2
           (fun llarg data_opt -> match data_opt with
             Some(data) -> build_array_load data i "el" builder
           | None -> llarg ) llargs datalist in
          let ret = L.build_call fdef (Array.of_list llargs_i) result builder in
          (match data with 
           Some(d) -> build_array_store d i ret builder |_->()) ; builder ) ;    

     (* Continue *)
     let builder = L.builder_at_end context cont_bb in
     let env = { env with ebuilder = builder } in
     (* Create array struct *)
     (match data with Some(d) ->
     let arr_struct = build_array_struct (ltype_of_typ t) d len
       "arr" env in
     arr_struct, env
     | _ -> l0, env )

    (* Control flow *)
   | SIfElse (eif, ethen, eelse) ->
      let (cond, env) = expr env eif in
      (* Memory to store the value of this expression *)
      let ret = (if t != Void then
        Some(L.build_alloca (ltype_of_typ t) "if_tmp" env.ebuilder)
        else None) in
      let merge_bb = L.append_block context "merge" env.ecurrent_fxn in
      let then_bb = L.append_block context "then" env.ecurrent_fxn in
      let else_bb = L.append_block context "else" env.ecurrent_fxn in
      ignore (L.build_cond_br cond then_bb else_bb env.ebuilder);

      let (thenv, then_env) = expr {env with ebuilder=(L.builder_at_end context then_bb)} ethen in
      (match ret with Some(rv) ->
        ignore (L.build_store thenv rv then_env.ebuilder)
        | None -> () );
      ignore (L.build_br merge_bb then_env.ebuilder);

      let (elsev, else_env) = expr {env with ebuilder=(L.builder_at_end context else_bb)} eelse in
      (match ret with Some(rv) ->
        ignore (L.build_store elsev rv else_env.ebuilder)
        | None -> () );
      ignore (L.build_br merge_bb else_env.ebuilder);

      let env ={env with ebuilder=(L.builder_at_end context merge_bb)} in
      (match ret with
        Some(rv) -> (L.build_load rv "if_tmp" env.ebuilder), env
      | None -> (L.const_int (ltype_of_typ Bool) 0), env)

    (* Type casting *)
   | SCast (ex) -> let t_to = t in let (t_from, _) = ex in 
      let normal_cast command = 
        let (lv, env) = expr env ex in
        (command lv (ltype_of_typ t_to) "cast" env.ebuilder, env)
      in
      let il i = (Int, SIntLit(i)) in
      let fl f = (Float, SFloatLit(f)) in
      (
      match (t_to, t_from) with
        (Int, Float)  -> normal_cast L.build_fptosi 
      | (Int, Bool)   -> expr env (Int, SIfElse(ex, il 1, il 0))
      | (Float, Int)  -> normal_cast L.build_sitofp
      | (Bool, Int)   -> expr env (Bool, SBinop(ex, Neq, il 0))
      | (Bool, Float) -> expr env (Bool, SBinop(ex, Neq, fl "0"))
      | (Void, _)     -> expr env ex
      | _             -> raise (Failure "Unknown type cast")
      )
   
   in

   (* Builds an SOS statement and returns the updated environment *)
   let build_stmt env = function
     STypeDef(_) -> env (* Everything handled in semant *)
   | SExpression(ex) -> let (_, env) = expr env ex 
     in env
   | SFxnDef(ty, nm, args, ex) ->
     let formal_types =
         Array.of_list (List.map (fun (t, _) -> ltype_of_typ t) args) in
     let ftype = L.function_type (ltype_of_typ ty) formal_types in
     let decl = L.define_function nm ftype the_module in
     let new_builder = L.builder_at_end context (L.entry_block decl) in

     (* Add function to fxns set *)
     let env = add_function env nm decl in

     let new_env = { env with ebuilder=new_builder } in
     let new_env = List.fold_left2 add_formal new_env args (
            Array.to_list (L.params decl)) in
     let new_env = {new_env with ebuilder = new_builder; ecurrent_fxn=decl} in
     let (lv, ret_env) = expr new_env ex in
     
     (* End with a return statement *)
     ( if ty=Void then
     ignore (L.build_ret_void ret_env.ebuilder)
     else
     ignore (L.build_ret lv ret_env.ebuilder) );

     env
   in
  
   (* Build the main function, the entry point for the whole program *)
   let build_main stmts = 
     (* Init the builder at the beginning of main() *)
     let builder = L.builder_at_end context (L.entry_block main) in
     (* Init the starting environment from exeternal functions *)
     let start_env = { ebuilder = builder; evars = StringMap.empty;
       efxns = StringSet.empty; esfxns = StringMap.empty; 
       ecurrent_fxn = main } in
     let start_env = List.fold_left add_external_fxn start_env
       Semant.external_functions in
     (* Build the program *)
     let end_env = List.fold_left build_stmt start_env stmts in
     (* Add a return statement *)
     L.build_ret (L.const_int i32_t 0) end_env.ebuilder    

   in
   ignore(build_main prog);
   the_module
\end{lstlisting}

\subsection{util\_math.c}
\begin{lstlisting}
#include <math.h>

float toradiansf(float x) {
    return (float) x * (M_PI / 180.0);
} 

#ifdef BUILD_TEST
int main() {
    toradiansf(12.5);
    return 0;
}
#endif
\end{lstlisting}

\subsection{util\_opengl.c}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "GL/osmesa.h"

/* reference: 
   https://github.com/freedesktop/mesa-demos/blob/master/src/osdemos/osdemo.c
   (mainly for gl_startRendering, write_ppm and gl_endRendering)
*/

#define maxpoints 50000

struct array {
    float *arr;
    int length;
};

OSMesaContext ctx;
void *buffer;

static void rendering_helper_init() {
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
   glMatrixMode(GL_MODELVIEW);
   glClear(GL_COLOR_BUFFER_BIT);
   glPushMatrix();
   glEnableClientState(GL_VERTEX_ARRAY);
   glEnableClientState(GL_COLOR_ARRAY);
   glColor4f(1.0, 1.0, 1.0, 1.0); //initalize color as white
}

static void rendering_helper_close() {
    glFinish();
}

/*
 * startRendering: an initalization that must be called before drawing
 * any image. Creates Mesa and OpenGL contexts and image buffer.
 */
void gl_startRendering(int width, int height) {
    ctx = OSMesaCreateContextExt(OSMESA_RGBA, 16, 0, 0, NULL);
    if (!ctx) {
        printf("OSMesaCreateContext failed!\n");
    }

    buffer = malloc( width * height * 4 * sizeof(GLubyte) );
    if (!buffer) {
        printf("Alloc image buffer failed!\n");
    }

    // Bind the buffer to the context and make it current
    if (!OSMesaMakeCurrent(ctx, buffer, GL_UNSIGNED_BYTE, width, height)) {
        printf("OSMesaMakeCurrent failed!\n");
    }
    printf("startRendering...\n");
    rendering_helper_init();
}

/*
 * drawCurve: draws segments between a list of points,
 * meaning n-1 segments for n points
 *
 * points: an array of points, with a point (x,y) located at [2i, 2i+1]
 * colors: an array of colors, with a the RGBA values of a point located at [4i, 4i+1, 4i+2, 4i+3]
 * size_arr: the number of points
 * color_mode: 0 -> between points i and i+1, the color of the segment is the color of point i+1
 *             1 -> each point has its own color. The segment between each point is a gradient between point colors
 */
void gl_drawCurve(struct array *spoints, struct array *scolors, int color_mode) {
    if (spoints->length!=scolors->length/2) {
        fprintf( stderr, "Unable to draw: The length of points array and colors array mismatched!\n" );
        return;
    }
    glPushMatrix();
    
    if (color_mode == 0) {
        glShadeModel(GL_FLAT);
    }
    else {
        glShadeModel(GL_SMOOTH);
    }

    float points[maxpoints];
    memcpy(points, spoints->arr, sizeof(float)*spoints->length);
    float colors[maxpoints];
    memcpy(colors, scolors->arr, sizeof(float)*scolors->length);
    int size_arr = spoints->length;
    size_arr = size_arr/2;

    glVertexPointer(2, GL_FLOAT, 0, points);
    glColorPointer(4, GL_FLOAT, 0, colors);
    glDrawArrays(GL_LINE_STRIP, 0, size_arr);
    
    glPopMatrix();
}

/*
 * drawShape: draws segments between a list of points,
 * including the segment connecting the first and last point
 *
 * points: an array of points, with a point (x,y) located at [2i, 2i+1]
 * colors: an array of colors, with a the RGBA values of a point located at [4i, 4i+1, 4i+2, 4i+3]
 * size_arr: the number of points
 * color_mode: 0 -> between points i and i+1, the color of the segment is the color of point i+1
 *             1 -> each point has its own color. The segment between each point is a gradient between point colors
 * filed: 0 -> shape is not filled with color
 *        1 -> shape will be filled with color
 */
void gl_drawShape(struct array *spoints, struct array *scolors, int color_mode, int filled) {
    if (spoints->length!=scolors->length/2) {
        printf("%d %d", spoints->length, scolors->length);
        fprintf( stderr, "Unable to draw: The length of points array and colors array mismatched!\n" );
        return;
    }
    glPushMatrix();

    if (color_mode == 0) {
        glShadeModel(GL_FLAT);
    }
    else {
        glShadeModel(GL_SMOOTH);
    }

    float points[maxpoints];
    memcpy(points, spoints->arr, sizeof(float)*spoints->length);
    float colors[maxpoints];
    memcpy(colors, scolors->arr, sizeof(float)*spoints->length);
    int size_arr = spoints->length;;
    size_arr = size_arr/2;

    glVertexPointer(2, GL_FLOAT, 0, points);
    glColorPointer(3, GL_FLOAT, 0, colors);

    if (filled==1) {
        glDrawArrays(GL_POLYGON, 0, size_arr);
    }
    else {
        glDrawArrays(GL_LINE_LOOP, 0, size_arr);
    }

    glPopMatrix();
}

/*
 * drawPoint: draws all points without creating segments
 *
 * points: an array of points, with a point (x,y) located at [2i, 2i+1]
 * colors: an array of colors, with a the RGBA values of a point located at [4i, 4i+1, 4i+2, 4i+3]
 * size_arr: the number of points
 * point_size: the size of each point
 */
void gl_drawPoint(struct array *spoints, struct array *scolors, int point_size) {
    if (spoints->length!=scolors->length/2) {
        fprintf( stderr, "Unable to draw: The length of points array and colors array mismatched!\n" );
        return;
    }
    glPushMatrix();
    
    float points[maxpoints];
    memcpy(points, spoints->arr, sizeof(float)*spoints->length);
    float colors[maxpoints];
    memcpy(colors, scolors->arr, sizeof(float)*spoints->length);
    int size_arr = spoints->length;
    size_arr = size_arr/2;

    glVertexPointer(2, GL_FLOAT, 0, points);
    glColorPointer(3, GL_FLOAT, 0, colors);
    glPointSize(point_size);
    glDrawArrays(GL_POINTS, 0, size_arr);
    glPopMatrix();
}

static void gl_clearCanvas() {
    glMatrixMode(GL_MODELVIEW);
    glClear(GL_COLOR_BUFFER_BIT);
}

/*
 * write_ppm: saves drawing
 *
 * filename: file name
 * buffer: 
 * width: canvas width
 * height: canvas height
 */
static void write_ppm(int fileNumber, const GLubyte *buffer, int width, int height) {
    char filename[50];
    char filenumasstr[50];
    sprintf(filenumasstr, "%d.ppm", fileNumber);
    strcpy(filename, "pic");
    strcat(filename, filenumasstr);
    const int binary = 0;
    FILE *f = fopen( filename, "w" );
    if (f) {
       int i, x, y;
       const GLubyte *ptr = buffer;
       if (binary) {
          fprintf(f,"P6\n");
          fprintf(f,"# ppm-file created by util_opengl.c\n");
          fprintf(f,"%i %i\n", width,height);
          fprintf(f,"255\n");
          fclose(f);
          f = fopen( filename, "ab" );  /* reopen in binary append mode */
          for (y=height-1; y>=0; y--) {
             for (x=0; x<width; x++) {
                i = (y*width + x) * 4;
                fputc(ptr[i], f);   /* write red */
                fputc(ptr[i+1], f); /* write green */
                fputc(ptr[i+2], f); /* write blue */
             }
          }
       }
       else {
          /*ASCII*/
          int counter = 0;
          fprintf(f,"P3\n");
          fprintf(f,"# ascii ppm file created by util_opengl.c\n");
          fprintf(f,"%i %i\n", width, height);
          fprintf(f,"255\n");
          for (y=height-1; y>=0; y--) {
             for (x=0; x<width; x++) {
                i = (y*width + x) * 4;
                fprintf(f, " %3d %3d %3d", ptr[i], ptr[i+1], ptr[i+2]);
                counter++;
                if (counter % 5 == 0)
                   fprintf(f, "\n");
             }
          }
       }
       fclose(f);
    }
}

/*
 * endRendering: closes OpenGL and Mesa contexts and saves drawing
 * by calling write_ppm
 */
void gl_endRendering(int width, int height, int fileNumber) {
    rendering_helper_close();
    write_ppm(fileNumber, buffer, width, height);
    free(buffer);
    OSMesaDestroyContext(ctx);
    printf("endRendering...\n");
}
/*
//sample program
//#ifdef BUILD_TEST
int main(int argc, char *argv[]) {
    startRendering();
    
    float p[]= {-.5, 0, .5, 0, 0, .5};
    struct array points;
    memcpy(points.arr, p, sizeof(p));
    points.length = 6;

    float c[] = {1.0, 0.5, 1.0, 1.0, 1.0, 0.5, 0, 1.0,  0.5, 1.0, 1.0, 1.0};
    struct array colors;
    memcpy(colors.arr, c, sizeof(c));
    colors.length = 12;

    int fileNumber = 1;

    startRendering();

    drawCurve(points, colors, 1);
    
    glTranslatef(-.2,-.2,0);
    drawCurve(points, colors, 0);

    glTranslatef(-.2, -.2, 0);
    drawShape(points, colors, 1, 1);

    glTranslatef(.6, 0 , 0);
    drawShape(points, colors, 0, 0);

    glTranslatef(-.3, -.2, 0);
    drawPoint(points, colors, 10);

    endRendering(1);

    return 0;
}
//#endif
*/
\end{lstlisting}

\subsection{Makefile}
\begin{lstlisting}
.PHONY : all
all: sos.native util_math.o util_opengl.o

# Creates the main compiler
sos.native:
	opam config exec -- \
	ocamlbuild -use-ocamlfind sos.native

util_math: util_math.c
	cc -lm -o util_math -DBUILD_TEST util_math.c

util_opengl: util_opengl.c
	cc -o util_opengl -DBUILD_TEST util_opengl.c -I/usr/local/include/ -L/user/local/lib/ -lOSMesa -lGLU -lm

.PHONY : clean

test: 
	./testall.sh

clean : 
	ocamlbuild -clean
	rm util_math.o util_opengl.o

\end{lstlisting}

\subsection{Dockerfile}
\begin{lstlisting}
# Sheron Wang
# Based on 20.04 LTS
FROM ubuntu:focal

# Set timezone:
RUN ln -snf /usr/share/zoneinfo/$CONTAINER_TIMEZONE /etc/localtime && echo $CONTAINER_TIMEZONE > /etc/timezone

RUN apt-get -yq update && \
    apt-get -y upgrade && \
    apt-get -yq --no-install-suggests --no-install-recommends install \
    ocaml \
    menhir \
    llvm-10 \
    llvm-10-dev \
    m4 \
    git \
    aspcud \
    ca-certificates \
    python \
    pkg-config \
    cmake \
    opam \
    python3 \
    python3-distutils \
    ninja-build

##################################################################
# for building MESA
##################################################################
# add environment variable
RUN export PATH="/usr/bin/python:$PATH"

# add Mako and meson dependency from python
RUN wget https://bootstrap.pypa.io/get-pip.py
RUN python3 get-pip.py
RUN pip install Mako
RUN pip install meson
RUN apt-get install libpciaccess-dev -y

# download and install newest libdrm
RUN wget https://dri.freedesktop.org/libdrm/libdrm-2.4.105.tar.xz
RUN tar xf libdrm-2.4.105.tar.xz && rm libdrm-2.4.105.tar.xz
WORKDIR libdrm-2.4.105/
RUN meson build/ && cd build && ninja && ninja install
WORKDIR ../
RUN rm -r libdrm-2.4.105/

# download mesa
RUN wget https://archive.mesa3d.org//mesa-20.3.5.tar.xz
RUN tar xf mesa-20.3.5.tar.xz && rm mesa-20.3.5.tar.xz
WORKDIR mesa-20.3.5

# add things to sources.list
RUN cp /etc/apt/sources.list /etc/apt/sources.list~
RUN sed -Ei 's/^# deb-src /deb-src /' /etc/apt/sources.list
RUN apt-get update

# add dependencies
RUN apt-get install -y libdrm-dev libxxf86vm-dev libxt-dev xutils-dev flex bison xcb libx11-xcb-dev libxcb-glx0 libxcb-glx0-dev xorg-dev libxcb-dri2-0-dev
RUN apt-get install -y libelf-dev libunwind-dev valgrind libwayland-dev wayland-protocols libwayland-egl-backend-dev
RUN apt-get install -y libxcb-shm0-dev libxcb-dri3-dev libxcb-present-dev libxshmfence-dev
RUN apt-get build-dep mesa -y

# build, compile and install
RUN meson build/ -Dosmesa=classic && ninja -C build/ && ninja -C build/ install
WORKDIR ../

# add OSMesa to path
RUN echo "export LD_LIBRARY_PATH=/usr/local/lib/x86_64-linux-gnu/:$LD_LIBRARY_PATH" >> ~/.bashrc

# install MESA GLU if you need more advanced features
# RUN git clone https://gitlab.freedesktop.org/mesa/glu.git
# RUN cd glu && ./autogen.sh && ./configure --enable-osmesa --prefix=/usr/local/ && make && make install
# RUN rm -r glu mesa-20.3.5 get-pip.py

# add GLU to path
# RUN echo "export LD_LIBRARY_PATH=/usr/local/lib/:$LD_LIBRARY_PATH" >> ~/.bashrc

# install vim for testing
# RUN apt-get install vim -y

##################################################################
# for building LLVM & others
##################################################################
RUN ln -s /usr/bin/lli-10 /usr/bin/lli
RUN ln -s /usr/bin/llc-10 /usr/bin/llc

RUN opam init --disable-sandboxing -y
RUN opam install \
    llvm.10.0.0 \
    ocamlfind \
    ocamlbuild -y
RUN eval `opam config env`

WORKDIR /root

ENTRYPOINT ["opam", "config", "exec", "--"]

CMD ["bash"]
\end{lstlisting}

\subsection{compile\_exec.sh}
\begin{lstlisting}
#!/bin/sh

# Builds a .sos file to an executable file
# Requires that ./sos.native has been built

# Path to the LLVM interpreter
LLI="lli"

# Path to the LLVM compiler
LLC="llc"

# Path to the C compiler
CC="cc"

# Path to the SOS compiler
SOS="./sos.native"

if [ ! -f util_math.o ]
then
    echo "Could not find util_math.o"
    echo "Try \"make util_math.o\""
    exit 1
fi

filename=$1
basename=${filename%.sos}

$SOS $filename >${basename}.ll
$LLC -relocation-model=pic ${basename}.ll >${basename}.s
$CC -o ${basename}.exe ${basename}.s util_math.o -lm util_opengl.o -I/usr/local/include/ -L/user/local/lib/ -lOSMesa

rm ${basename}.ll ${basename}.s

./${basename}.exe
\end{lstlisting}

\subsection{docker\_connect.sh}
\begin{lstlisting}
#!/bin/sh

docker run --rm -it -v `pwd`:/home/sos -w=/home/sos sheronw1174/sos-env:latest
\end{lstlisting}

\subsection{docker\_image\_fetching.sh}
\begin{lstlisting}
#!/bin/sh

if [ "$1" = "build" ]
then
    docker build . -t sheronw1174/sos-env
elif [ "$1" = "pull" ]
then
    docker pull sheronw1174/sos-env
else
    echo "usage: $0 [build|pull]"
fi
\end{lstlisting}

\subsection{testall.sh}
\begin{lstlisting}
#!/bin/sh

# Regression testing script for SOS
# Step through a list of files
#  Compile, run, and check the output of each expected-to-work test
#  Compile and check the error of each expected-to-fail test

# Path to the LLVM interpreter
#LLI="/usr/local/Cellar/llvm/9.0.1_2/bin/lli"
LLI="lli"

# Path to the LLVM compiler
#LLC="/usr/local/Cellar/llvm/9.0.1_2/bin/lli"
LLC="llc"

# Path to the C compiler
CC="cc"

# Path to the SOS compiler.  Usually "./sos.native"
# Try "_build/sos.native" if ocamlbuild was unable to create a symbolic link.
SOS="./sos.native"

OPENGL_FLAGS="-lOSMesa -lm"

# Set time limit for all operations
ulimit -t 30

globallog=testall.log
rm -f $globallog
error=0
globalerror=0

keep=0

Usage() {
    echo "Usage: testall.sh [options] [.sos files]"
    echo "-k    Keep intermediate files"
    echo "-h    Print this help"
    exit 1
}

SignalError() {
    if [ $error -eq 0 ] ; then
	echo "FAILED"
	error=1
    fi
    echo "  $1"
}

# Compare <outfile> <reffile> <difffile>
# Compares the outfile with reffile.  Differences, if any, written to difffile
Compare() {
    generatedfiles="$generatedfiles $3"
    echo diff -b $1 $2 ">" $3 1>&2
    diff -b "$1" "$2" > "$3" 2>&1 || {
	SignalError "$1 differs"
	echo "FAILED $1 differs from $2" 1>&2
    }
}

# Run <args>
# Report the command, run it, and report any errors
Run() {
    echo $* 1>&2
    eval $* || {
	SignalError "$1 failed on $*"
	return 1
    }
}

# RunFail <args>
# Report the command, run it, and expect an error
RunFail() {
    echo $* 1>&2
    eval $* && {
	SignalError "failed: $* did not report an error"
	return 1
    }
    return 0
}

Check() {
    error=0
    basename=`echo $1 | sed 's/.*\\///
                             s/.sos//'`
    reffile=`echo $1 | sed 's/.sos$//'`
    basedir="`echo $1 | sed 's/\/[^\/]*$//'`/."

    echo -n "$basename..."

    echo 1>&2
    echo "###### Testing $basename" 1>&2

    generatedfiles=""
    
    generatedfiles="$generatedfiles ${basename}.ll ${basename}.s ${basename}.exe ${basename}.out" &&
    Run "$SOS" "$1" ">" "${basename}.ll" &&
    Run "$LLC" "-relocation-model=pic" "${basename}.ll" ">" "${basename}.s" &&
    Run "$CC" "-o" "${basename}.exe" "${basename}.s" "util_opengl.o" "util_math.o" "$OPENGL_FLAGS" &&
    Run "./${basename}.exe" > "${basename}.out" &&
    Compare ${basename}.out ${reffile}.out ${basename}.diff

    # Report the status and clean up the generated files

    if [ $error -eq 0 ] ; then
	if [ $keep -eq 0 ] ; then
	    rm -f $generatedfiles
	fi
	echo "OK"
	echo "###### SUCCESS" 1>&2
    else
	echo "###### FAILED" 1>&2
	globalerror=$error
    fi
}

CheckFail() {
    error=0
    basename=`echo $1 | sed 's/.*\\///
                             s/.sos//'`
    reffile=`echo $1 | sed 's/.sos$//'`
    basedir="`echo $1 | sed 's/\/[^\/]*$//'`/."

    echo -n "$basename..."

    echo 1>&2
    echo "###### Testing $basename" 1>&2

    generatedfiles=""

    generatedfiles="$generatedfiles ${basename}.err ${basename}.diff" &&
    RunFail "$SOS" "<" $1 "2>" "${basename}.err" ">>" $globallog &&
    Compare ${basename}.err ${reffile}.err ${basename}.diff

    # Report the status and clean up the generated files

    if [ $error -eq 0 ] ; then
	if [ $keep -eq 0 ] ; then
	    rm -f $generatedfiles
	fi
	echo "OK"
	echo "###### SUCCESS" 1>&2
    else
	echo "###### FAILED" 1>&2
	globalerror=$error
    fi
}

while getopts kdpsh c; do
    case $c in
	k) # Keep intermediate files
	    keep=1
	    ;;
	h) # Help
	    Usage
	    ;;
    esac
done

shift `expr $OPTIND - 1`

LLIFail() {
  echo "Could not find the LLVM interpreter \"$LLI\"."
  echo "Check your LLVM installation and/or modify the LLI variable in testall.sh"
  exit 1
}

which "$LLI" >> $globallog || LLIFail

if [ ! -f util_opengl.o ]
then
    echo "Could not find util_opengl.o"
    echo "Try \"make util_opengl.o\""
    exit 1
fi

if [ $# -ge 1 ]
then
    files=$@
else
    files="tests/test-*.sos tests/fail-*.sos"
fi

for file in $files
do
    case $file in
	*test-*)
	    Check $file 2>> $globallog
	    ;;
	*fail-*)
	    CheckFail $file 2>> $globallog
	    ;;
	*)
	    echo "unknown file type $file"
	    globalerror=1
	    ;;
    esac
done

exit $globalerror
\end{lstlisting}

\subsection{helloworld.sos}
\begin{lstlisting}
import renderer.sos

a: int = 5
print(a)

p1: point = {-0.9, -0.9}
p2: point = {-0.9, -0.7}
p3: point = {-0.7, -0.7}
p4: point = {-0.7, -0.9}

point_arr : path = [p1, p2, p3, p4]

c1 : color = {255.0, 0.0, 0.0, 0.8}
c2 : color = {0.0, 255.0, 0.0, 0.8}
c3 : color = {0.0, 0.0, 255.0, 0.8}
c4 : color = {100.0, 100.0, 0.0, 0.8}
color_arr : colors = [c1, c2, c3, c4]

my_canvas : canvas = {400, 400, 2}

startCanvas(my_canvas)
drawShape(point_arr, color_arr, 0, 1)
endCanvas(my_canvas)
\end{lstlisting}

\subsection{lib/affine.sos}

\begin{lstlisting}

import point.sos

struct mat2 = {a11: float, a21: float, a12: float, a22: float}
struct mat3 = {a11: float, a21: float, a31: float,
               a12: float, a22: float, a32: float,
               a13: float, a23: float, a33: float}
alias affine = mat3

affine_mul : (A: affine, v: point, w: float) -> point =
    to: point3 = {v.x, v.y, w};
    res: point3 = A ** to;
    free(to);
    if w == 0 || res.z == 1 then
    ret: point = {res.x, res.y};
    free(res) ; ret
    else
    ret: point = {res.x/res.z, res.y/res.z};
    free(res) ; ret

rotation : (r: float) -> mat2 = 
    c: float = cos(r) ; s: float = sin(r);
    {c,s,-s,c}

scale : (sx: float, sy: float) -> mat2 = 
    {sx,0.0,0.0,sy}

translate : (dx: float, dy: float) -> affine =
    {1.0,0.0,0.0, 0.0,1.0,0.0, dx,dy,1.0}

// For internal use only
// Functions not normally free their arguments like this
make_affine__ : (m: mat2) -> affine = 
    ret: affine = {m.a11, m.a21, 0.0,
                   m.a12, m.a22, 0.0,
                   0.0, 0.0, 1.0};
    free(m) ; ret

rotation_aff : (r: float) -> affine = make_affine__(rotation(r))
scale_aff : (sx: float, sy: float) -> affine = make_affine__(scale(sx,sy))
\end{lstlisting}

\subsection{lib/array.sos}

\begin{lstlisting}


fill_ints : (a: array int, i: int) -> void = 
    if i < a.length then a[i] = i; fill_ints(a, i+1)
    else 0

// A very useful function that makes an array of consecutive ints
// Use with implicit iteration for very nice results
ints : (n : int) -> array int = 
  if n <= 0 then (a: array int = [])
  else arr : array int = n of [0];
  fill_ints(arr, 0) ; arr
\end{lstlisting}

\subsection{lib/color.sos}

\begin{lstlisting}

import math.sos

struct color = {r: float, g: float, b: float, a: float}

alias colors = array color

// Standard: r,g,b in [0, 1]
rgb: (r: float, g: float, b: float) -> color = {r,g,b,1.0}

// Hue/saturation/value: hsv in [0, 1]
hsv: (h: float, s: float, v: float) -> color =
   c: float = v * s ;
   hfac: float = modf(h*6.0, 2.0) ;
   x: float = c * (1.0-abs(hfac-1.0)) ;
   m: float = v - c ;
   hh: float = h*6.0 ;

   if hh < 1.0 then rgb(v,x+m,m) else
   if hh < 2.0 then rgb(x+m,v,m) else
   if hh < 3.0 then rgb(m,v,x+m) else
   if hh < 4.0 then rgb(m,x+m,v) else
   if hh < 5.0 then rgb(x+m,m,v) else
                    rgb(v,m,x+m)
    
\end{lstlisting}

\subsection{lib/math.sos}

\begin{lstlisting}

// Some floating point ops

floor : (x: float) -> float = 
    z: float = (y: int = x);
    if z <= x then z
    else z - 1.0

ceil : (x: float) -> float = -floor(-x)

frac : (x: float) -> float = x - floor(x) 

max : (a: float, b: float) -> float = if a<b then b else a
min : (a: float, b: float) -> float = if a<b then a else b

clamp : (x: float, m: float, M: float) -> float = min(M, max(x, m))

abs : (x: float) -> float = if x < 0 then -x else x

// Returns the value y between 0 and m such that y = x+mn for an integer n
modf : (x: float, m: float) -> float = m * frac(x/m)

sin : (x: float) -> float = sinf(x)
cos : (x: float) -> float = cosf(x)
tan : (x: float) -> float = tanf(x)
asin : (x: float) -> float = asinf(x)
acos : (x: float) -> float = acosf(x)
atan : (x: float) -> float = atanf(x)
sqrt : (x: float) -> float = sqrtf(x)
toradians : (x: float) -> float = toradiansf(x)
\end{lstlisting}

\subsection{lib/point.sos}

\begin{lstlisting}

import math.sos

struct point = {x: float, y: float}
struct point3 = {x: float, y: float, z: float}

sqrMagnitude : (p: point) -> float = p * p
magnitude : (p: point) -> float = sqrt(sqrMagnitude(p))

sqrDistance : (a: point, b: point) -> float = 
   p: point = a - b;
   d: float = sqrMagnitude(p);
   free(p) ; d
distance : (a: point, b: point) -> float = sqrt(sqrDistance(a,b))
\end{lstlisting}

\subsection{lib/random.sos}

\begin{lstlisting}

// Wichmann-Hill PRNG
// en.wikipedia.org/wiki/Wichmann-Hill
import math.sos

struct rng = {s1: int, s2: int, s3: int}

randf : (r: rng) -> float =
   r.s1 = 171 * r.s1 % 30269;
   r.s2 = 172 * r.s2 % 30307;
   r.s3 = 170 * r.s3 % 30323;
   frac(r.s1/30269.0 + r.s2/30307.0 + r.s3/30323.0)
\end{lstlisting}

\subsection{lib/renderer.sos}

\begin{lstlisting}

import shape.sos
import color.sos

struct canvas = {width: int, height: int, file_number: int}

startCanvas: (c : canvas) -> void = gl_startRendering(c.width, c.height)

cvoid : () -> void = 0

drawHelper : (point_structs: path, color_structs: array color, numOfPoints: int, i: int,  points: array float, colors: array float) -> void =
    if i >= numOfPoints /*i>=numOfPoints-1?*/
    then cvoid()
    else
        px : float = point_structs[i].x;
        py : float= point_structs[i].y;
        points[2*i] = px;
        points[2*i+1] = py;

        cr : float = color_structs[i].r;
        cg : float = color_structs[i].g;
        cb : float= color_structs[i].b;
        ca : float= color_structs[i].a;
        colors[4*i] = cr;
        colors[4*i+1] = cg;
        colors[4*i+2] = cb;
        colors[4*i+3] = ca;

        drawHelper(point_structs, color_structs, numOfPoints, i + 1, points, colors)

drawPoints : (point_structs : path, color_structs : array color) -> void = 
        numOfPoints : int = point_structs.length;
        points : array float = numOfPoints*2 of [0.0];
        colors : array float = numOfPoints*4 of [0.0];
        
        drawHelper(point_structs, color_structs, numOfPoints, 0,  points, colors);

        gl_drawPoint(points, colors, 2)

drawPath : (point_structs : path, color_structs : array color,  colorMode : int) -> void = 
        numOfPoints : int= point_structs.length;
        points : array float= numOfPoints*2 of [0.0];
        colors : array float= numOfPoints*4 of [0.0];

        drawHelper(point_structs, color_structs, numOfPoints, 0,  points, colors);
        
        gl_drawCurve(points, colors, colorMode)


drawShape : (point_structs : path, color_structs : array color,  colorMode : int, filled : int) ->
    void = 
        numOfPoints : int = point_structs.length;
        points : array float = numOfPoints*2 of [0.0];
        colors : array float = numOfPoints*4 of [0.0];

        drawHelper(point_structs, color_structs, numOfPoints, 0,  points, colors);

        gl_drawShape(points, colors, colorMode, filled)


endCanvas : (c : canvas) -> void = gl_endRendering(c.width, c.height, c.file_number)
\end{lstlisting}

\subsection{lib/shape.sos}

\begin{lstlisting}

import point.sos

alias path = array point
alias shape = array point

// Wrappers to enable array iteration
copy_point : (p: point) -> point = copy(p)
free_point : (p: point) -> void = free(p)

// More convenient names
copy_path : (p: path) -> path = copy_point(p)
free_path : (p: path) -> void = free_point(p)

appendhelp_copyin : (in: path, from: path, i: int) -> void = 
    if i<in.length then
    in[i] = copy(from[i+1]);
    appendhelp_copyin (in, from, i+1)
    else 0

appendhelp_tail : (p: path) -> path = 
    tail: path = p.length-1 of [{0.0, 0.0}];
    appendhelp_copyin(tail, p, 0); tail

// Appends two paths, merging them at their endpoints, if needed
// Epsilon is the max distance that can be merged
append : (p1: path, p2: path, epsilon: float) -> path = 
    if p1.length == 0 then copy_path(p2)
    else if p2.length == 0 then copy_path(p1)
    else 
    merge: bool = sqrDistance(p1[p1.length-1], p2[0]) < epsilon*epsilon;
    p2c: path = (if merge then appendhelp_tail(p2) else p2);
    ret: path = copy_path(p1) @ copy_path(p2c);
    ret

reversedhelp: (in: path, from: path, i: int) -> void = 
    if i < in.length then
    in[i].x = from[in.length-1-i].x;
    in[i].y = from[in.length-1-i].y;
    reversedhelp(in, from, i+1)
    else 0

// Creates a new array that is p reversed
reversed: (p : path) -> path =
    newpath : path = p.length of [{0.0, 0.0}];
    reversedhelp(newpath, p, 0);
    newpath

reversehelp : (p: path, i: int) -> void =
    if i < p.length/2 then
    q: point = p[i];
    p[i] = p[p.length-1-i];
    p[p.length-1-i] = q;
    reversehelp (p, i+1)
    else 0

// Reverses p in-place
reverse: (p: path) -> void = reversehelp(p, 0)
    
\end{lstlisting}

\subsection{lib/size.sos}

\begin{lstlisting}

import shape.sos

struct minPoint = {float x, float y}

// scale rightward downward
// should based on a rectangular box aound the object and get that vertex? or just use opengl

min(a: point, b: minPoint) -> void =
    if a.x < b.x and a.y < b.y then b.x = a.x and b.y = a.y
    else 0

// shape size(float multiple) =
    

\end{lstlisting}

\subsection{lib/std.sos}

\begin{lstlisting}

import vector.sos
import affine.sos
import renderer.sos
\end{lstlisting}

\subsection{lib/transform.sos}

\begin{lstlisting}

import shape.sos
import math.sos
import vector.sos

// Rotates the given point by angle radians about the given point
// Either rotate clockwise (1) or counterclockwise (-1)
rotate : (p: point, angle: float, direction: int, about: point) -> void =
    //shifted
    px : float = p.x - about.x;
    py : float = p.y - about.y;

    if direction == -1
    then //counterclockwise
        p.x = (px*cos(angle) - py*sin(angle)) + about.x;
        p.y = (px*sin(angle) + py*cos(angle)) + about.y
    else if direction == 1
    then //clockwise
        p.x = (px*cos(angle) + py*sin(angle)) + about.x;
        p.y = (-px*sin(angle)+ py*cos(angle)) + about.y
    else //do no rotation
        p.x = p.x;
        p.y = p.y 

// Translates the given point by the given vector
trans : (p: point, direction: vector) -> void = 
    p.x = p.x + direction.x ; p.y = p.y + direction.y

// Scales the point by (sx, sy)
scale : (p: point, sx: float, sy: float) -> void =
    p.x = p.x * sx ; p.y = p.y * sy

// Performs rotate() on a new point
rotated : (p: point, angle: float, direction: int, about: point) -> point =
    q: point = copy(p) ;
    rotate(q, angle, direction, about) ;
    q

// Performs translate() on a new point
translated : (p: point, direction: vector) -> point =
    q: point = copy(p) ;
    trans(q, direction) ;
    q

scaled : (p: point, sx: float, sy: float) -> point = 
    q: point = copy(p) ; 
    scale(p, sx, sy) ;
    q
\end{lstlisting}

\subsection{lib/vector.sos}

\begin{lstlisting}

struct vector = {x: float, y: float}

\end{lstlisting}

\subsection{sample\_programs/dragon.sos}

\begin{lstlisting}

import renderer.sos
import vector.sos
import transform.sos
import array.sos
import math.sos

// Creates a dragon curve of depth n
dragon: (n: int) -> path = 
    if n == 0 // Base case
    then [point{0.0, 0.0}, point{1.0, 0.0}]
    else
    // Create two copies of the previous depths
    d1: path = dragon(n-1) ; 
    d2: path = copy_path(d1) ;

    // Position d1
    s: float = sqrt(2.0)/2.0 ;
    rotate(d1, toradians(45.0), -1, {0.0, 0.0}) ; 
    scale(d1, s, s) ; 

    // Position d2
    rotate(d2, toradians(135.0), -1, {0., 0.}) ;
    scale(d2,s,s) ;
    trans(d2, {1., 0.}) ;
    reverse(d2) ;

    // Merge the paths
    r: path = append(d1, d2, 1.0) ;
    free_path(d1); free_path(d2); r

// Creates a rainbow color effect
rainbow: (r: int, len: int) -> color = 
    h: float = (1.0*r)/len ;
    hsv(h, 0.8, 0.8)

// Render a 400px by 400px canvas, name the image pic0
my_canvas: canvas = {400, 400, 0}

// Start render
startCanvas(my_canvas)
d: path = dragon(7)
// Position the curve (0.4, 0.2 is approximately the center of mass of the curve for large n)
trans(d, {-0.4, -0.2})

// Draw it
drawPath(d, rainbow(ints(d.length), d.length), 0)
endCanvas(my_canvas)
\end{lstlisting}

\subsection{sample\_programs/drunk.sos}

\begin{lstlisting}

import renderer.sos
import random.sos

n: int = 100
p: path = n of [{0.0, 0.0}]
c: colors = n of [{0.5, 0.5, 0.5, 0.5}]
r: rng = {1,2,3}

drunk_walk : (i: int, p: path, c: colors, r: rng) -> void = 
    if i < p.length then
      theta: float = randf(r) * 6.28319;
      d: float = randf(r)*0.1 + 0.02;
      dx: float = cos(theta)*d ; dy: float = sin(theta)*d ;
      p[i] = {p[i-1].x+dx, p[i-1].y+dy} ;
      dc: float = 0.1 ; 
      dr: float = (randf(r) - 0.5) * dc ;
      dg: float = (randf(r) - 0.5) * dc ;
      db: float = (randf(r) - 0.5) * dc ;
      c[i] = rgb(c[i-1].r + dr, c[i-1].g+dg, c[i-1].b+db) ;
      drunk_walk(i+1,p,c,r)

    else void


my_canvas: canvas = {400, 400, 0}
startCanvas(my_canvas)

draw_walks : (count: int, p: path, c: colors, r: rng) -> void =
    if count > 0 then
    p[0] = {randf(r)*0.5-0.25, randf(r)*0.5-0.25};
    c[0] = hsv(randf(r), 0.8, 0.8) ;
    drunk_walk(1, p, c, r) ;
    drawPath(p,c,0) ;
    draw_walks(count-1,p,c,r)
    else void

draw_walks(20, p, c, r)

endCanvas(my_canvas)

\end{lstlisting}

\subsection{sample\_programs/lorenz.sos}

\begin{lstlisting}

import renderer.sos
import array.sos
alias path3 = array point3

create_lorenz : (p: path3, i: int, sigma: float, rho: float, beta: float) -> void = 
    if i == 0 then p[i] = {0.1,0.1,0.1}; create_lorenz(p,i+1,sigma,rho,beta)
    else if i < p.length then
      q: point3 = p[i-1] ;
      dx: float = sigma * (q.y - q.x) ;
      dy: float = q.x * (rho - q.z) - q.y ;
      dz: float = q.x*q.y - beta * q.z ;
      dt: float = 0.005 ;
      p[i] = {q.x + dx*dt, q.y + dy*dt, q.z + dz*dt} ;
      create_lorenz(p,i+1,sigma,rho,beta)
    else void

len: int = 5000
l3: path3 = len of [{0.0,0.0,0.0}]
create_lorenz (l3, 0, 10, 28, 8.0/3)
rainbow: (r: int, len: int) -> color = 
    h: float = (1.0*r)/len ;
    hsv(h, 0.8, 0.8)
c: colors = rainbow(ints(len), len+1000)


reduce : (p: point3) -> point = {p.x/30.0, p.y/30.0}

l: path = reduce(l3)

my_canvas : canvas = {400,400,1}

startCanvas(my_canvas)
drawPath(l, c, 0)
endCanvas(my_canvas)

\end{lstlisting}

\subsection{sample\_programs/square.sos}
\begin{lstlisting}
import renderer.sos

a: int = 5 
print(a)

p1: point = {-0.5, -0.5}
p2: point = {-0.5, 0.5}
p3: point = {0.5, 0.5}
p4: point = {0.5, -0.5}
point_arr : path = [p1, p2, p3, p4] 

c1 : color = {255.0, 0.0, 0.0, 0.8}
c2 : color = {0.0, 255.0, 0.0, 0.8}
c3 : color = {0.0, 0.0, 255.0, 0.8}
c4 : color = {100.0, 100.0, 0.0, 0.8}
color_arr : colors = [c1, c2, c3, c4] 

canvas1 : canvas = {400, 400, 0}

startCanvas(canvas1)
drawShape(point_arr, color_arr, 0, 1)
endCanvas(canvas1)

canvas2 : canvas = {400, 400, 1}

startCanvas(canvas2)
drawShape(point_arr, color_arr, 0, 1)
endCanvas(canvas2)
\end{lstlisting}


\subsection{sample\_programs/tree.sos}

\begin{lstlisting}

import affine.sos
import renderer.sos

branchHelper : (p: path, i: int, A: affine) -> void = 
    if i < p.length then
    p[i] = affine_mul(A, p[i-1]-p[i-2], 0) + p[i-1];
    branchHelper(p,i+1,A)
    else void

makeBranch : (n: int, A: affine) -> path =
    p: path = n of [{0.0,0.0}];
    p[1] = {0.0, 0.2};
    branchHelper(p, 2, A); p

powersHelper : (arr: array affine, i: int, A: affine) -> void = 
    if i < arr.length then
    arr[i] = A ** arr[i-1];
    powersHelper(arr,i+1,A)
    else void

powers : (n: int, A: affine) -> array affine = 
    arr: array affine = n of [copy(A)];
    powersHelper(arr, 1, A) ; arr

A: affine = translate(0, 0.2) ** rotation_aff(0.13) ** scale_aff(0.8, 0.8)
As: array affine = powers(8, A)
L: affine = scale_aff(0.36, 0.36) ** rotation_aff(0.66)
R: affine = scale_aff(0.49,0.49) ** rotation_aff(-0.78)
base: path = makeBranch(10, A)

white: colors = 10 of [rgb(1.0,1.0,1.0)]
green: colors = 10 of [rgb(0.0,0.8,0.0)]

my_canvas: canvas = {400,400,0}
startCanvas(my_canvas)

drawTree : (base: path, T: affine, A: affine, As: array affine, L: affine, R: affine, depth: int, c1: colors, c2: colors)
  -> void = 
  if depth==0 then drawPath(affine_mul(T,base,1), c2, 0) else
  drawPath(affine_mul(T,base,1), c1, 0) ;
  drawTree(base, T ** As ** L, A, As, L, R, depth-1, c1, c2) ;
  drawTree(base, T ** As ** R, A, As, L, R, depth-1, c1, c2)

T: affine = {1.8,0.0,0.0,0.0,1.8,0.0,0.0,-0.8,1.0}
drawTree (base, T, A, As, L, R, 3, white, green)

endCanvas(my_canvas)

\end{lstlisting}

\subsection{sample\_programs/web.sos}

\begin{lstlisting}

import renderer.sos
import random.sos
import array.sos
import math.sos

build_ring : (i: int, r: int, radius: float) -> point = 
    angle: float = (i*6.2831852)/r  + 0.134;
    {cos(angle) * radius, sin(angle) * radius}

build_rings : (n: int, r: int, radius_interval: float, rr: rng) -> array point =
    build_ring(ints(r), r, radius_interval * n * (randf(rr)*0.18+0.91))

build_points : (n : int, r : int, max_radius: float, rr: rng) -> array array point = 
    build_rings (ints(n), r, max_radius/(n-1), rr) 

connect_ring_inner : (i: int, a: array point, c: colors) -> void =
    if  i==a.length-1 then drawPath([a[i], a[0]], c, 0)
    else drawPath([a[i], a[i+1]], c, 0); connect_ring_inner(i+1,a,c)

connect_ring : (a: array point, c: colors) -> void =
    connect_ring_inner(0, a, c) 

ring_iter : (w: array array point, c: colors, i: int, j: int, r: rng,
        f: func array array point, colors, int, int, rng -> void) -> void = 
    if i < w.length then if j < w[i].length then
    f(w,c,i,j,r) ; ring_iter(w,c,i,j+1,r,f)
    else ring_iter(w,c,i+1,0,r,f) else void

connect_lines_in : (w: array array point, c: colors, i: int, j: int, r: rng) -> void = 
    if i < w.length - 1 then
    drawPath([w[i][j], w[i+1][j]], c, 0)
    else drawPath([w[i][j], 5*w[i][j]], c, 0)

connect_lines : (w: array array point, c: colors, r: rng) -> void = 
    ring_iter(w,c,0,0,r, connect_lines_in)

random_connections_in : (w: array array point, c: colors, i: int, j: int, r: rng) -> void =
    if i < w.length - 1 then
    (if randf(r) > 0.65 then drawPath([w[i][j], w[i+1][(j+1)%w[0].length]], c, 0) else void); 
    if randf(r) > 0.65 then
      drawPath([w[i][j], w[i+1][(j-1+w[0].length)%w[0].length]], c, 0) else void
    else void

random_connections : (w: array array point, c: colors, r: rng) -> void = 
   ring_iter(w,c,1,0,r, random_connections_in)

perturb_in : (w: array array point, c: colors, i: int, j: int, r: rng) -> void =
    s: float = 0.1 ;
    dx: float = randf(r) * s + 1.0 - s/2;
    dy: float = randf(r) * s + 1.0 - s/2;
    w[i][j].x = w[i][j].x * dx ;
    w[i][j].y = w[i][j].y * dy

perturb : (w: array array point, c: colors, r: rng) -> void = 
   ring_iter(w,c,1,0,r, perturb_in)

my_canvas: canvas = {400, 400, 3}
r: rng = {35,62,21}
startCanvas(my_canvas)

w: array array point = build_points(7, 7, 0.95, r)
perturb(w, [], r)
connect_ring(w, [rgb(1,1,1), rgb(1,1,1)])
connect_lines(w, [rgb(1,1,1), rgb(1,1,1)], r)
random_connections(w, [rgb(1,1,1), rgb(1,1,1)], r)

endCanvas(my_canvas)
\end{lstlisting}

\end{document}
